<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <generator>NUAA</generator>
    <id>https://blogroll.a2os.club</id>
    <title>NUAARSS</title>
    <updated>2022-08-16T18:21:38+08:00</updated>
    <link href="https://blogroll.a2os.club"/>
    <author>
        <name>NUAARSS</name>
    </author>
    
    
    <entry>
        <id>https://blog.zeddyu.info/2022/08/16/2022-08-10-h2-push/</id>
        <title><![CDATA[A Magic Way of XSS in HTTP/2]]></title>
        <updated>2022-08-16T02:27:21+08:00</updated>
        <link href="https://blog.zeddyu.info/2022/08/16/2022-08-10-h2-push/"/>
        <content type="text/html" src="https://blog.zeddyu.info/2022/08/16/2022-08-10-h2-push/"><![CDATA[<p>上周周末结束的 corCTF 中有一个题目提出了一种很有意思的攻击，该攻击方式可以利用 HTTP/2 Server Push 机制 XSS 到其他域，尽管利用条件有点苛刻，但是我个人非常喜欢这种 Magic 的攻击方式。（在征求了原作者 <a class="link" href="https://larry.sh/" target="_blank" rel="noopener"
>@ehhthing</a> 同意下将该方法分享给大家）</p>]]></content>
        <author>
            <name><![CDATA[Zedd’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.zwlin.io/post/go-append/</id>
        <title><![CDATA[Go 1.18 的 append 变化]]></title>
        <updated>2022-08-02T14:39:17+08:00</updated>
        <link href="https://blog.zwlin.io/post/go-append/"/>
        <content type="text/html" src="https://blog.zwlin.io/post/go-append/"><![CDATA[<p>很多 Go 的文章都提到 append 扩容的具体实现，为了确认文章中提到的 1024 阈值，我翻了下 Go 1.18 的源码，发现实现切片扩容的 growslice 函数实际已经变化了，源代码的位置也有一定的改变，因此在此记录一下。实际上 Go 的源代码变化的非常快，函数的位置也经常改变，我这里记录的源码也只是Go 1.18 这个特定版本的实现和代码位置。</p>
<p>同时在 <a href="https://tip.golang.org/doc/go1.18#runtime">Go 1.18 Release Notes</a> 中提到:</p>
<blockquote>
<p>The built-in function <code>append</code> now <strong>uses a slightly different formula</strong> when deciding how much to grow a slice when it must allocate a new underlying array. The new formula is less prone to sudden transitions in allocation behavior.</p>
</blockquote>
<p>以下只摘出核心代码：</p>
<p>append 的中间代码生成部分挪到了 <a href="https://github.com/golang/go/blob/f2a9f3e2e0ce7e582d226ad9a41d3c36b146fc25/src/cmd/compile/internal/ssagen/ssa.go#L3346">src/cmd/compile/internal/ssagen/ssa.go</a></p>
<p>核心的 gorwslice 函数在 <a href="https://github.com/golang/go/blob/f2a9f3e2e0ce7e582d226ad9a41d3c36b146fc25/src/runtime/slice.go#L200-L223">src/runtime/slice.go</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kd">func</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"> <span class="c1">//...
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span> <span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"> <span class="nx">doublecap</span> <span class="o">:=</span> <span class="nx">newcap</span> <span class="o">+</span> <span class="nx">newcap</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"> <span class="k">if</span> <span class="nx">cap</span> <span class="p">&gt;</span> <span class="nx">doublecap</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"> <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"> <span class="kd">const</span> <span class="nx">threshold</span> <span class="p">=</span> <span class="mi">256</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"> <span class="k">if</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span> <span class="p">&lt;</span> <span class="nx">threshold</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"> <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">doublecap</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"> <span class="c1">// Check 0 &lt; newcap to detect overflow
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span> <span class="c1">// and prevent an infinite loop.
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span> <span class="k">for</span> <span class="mi">0</span> <span class="p">&lt;</span> <span class="nx">newcap</span> <span class="o">&amp;&amp;</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"> <span class="c1">// Transition from growing 2x for small slices
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span> <span class="c1">// to growing 1.25x for large slices. This formula
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span> <span class="c1">// gives a smooth-ish transition between the two.
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span> <span class="nx">newcap</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">newcap</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="nx">threshold</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"> <span class="c1">// Set newcap to the requested cap when
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span> <span class="c1">// the newcap calculation overflowed.
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="nx">newcap</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"> <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"> <span class="c1">//...
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>可以看出在 Go 1.18 中，扩容策略（不考虑内存对齐的情况下）变成了：</p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量</li>
<li>如果当前切片的长度小于 256 就会将容量翻倍</li>
<li>如果当前切片的长度大于 256 就会每次增加 25% 的同时再增加 192(256的3/4)，直到新容量大于期望容量</li>
</ol>
<p>按照注释的说法是新的公式 newcap += (newcap + 3*threshold) / 4 会使得容量的变化更加平滑。顺带一提，在之前的版本中公式为 newcap += newcap / 4</p>
<p>源码中的实现才是最准确的，网上的文章都有时效性，切勿奉为圭臬。</p>]]></content>
        <author>
            <name><![CDATA[Zwlin’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.suruifu.com/posts/714</id>
        <title><![CDATA[单庄园对苏瑞辅优点的列举]]></title>
        <updated>2022-07-03T08:19:53+08:00</updated>
        <link href="https://www.suruifu.com/posts/714"/>
        <content type="text/html" src="https://www.suruifu.com/posts/714"><![CDATA[<h2>说明</h2>
<ol>
<li>这是手搞，没有合并及整理，没有整理句子使语句通顺</li>
<li>过去的事情就过去了，我们都要向前看，这里只是做个记录</li>
</ol>
<h2>原文</h2>
<ul>
<li>目标拆解与完成技术</li>
<li>每天都很坚持</li>
<li>每天保持事情的好奇</li>
<li>决策效率高</li>
<li>有自己的追求</li>
<li>对自己有奇妙的自信</li>
<li>乐观</li>
<li>语言鲜活，思维清晰</li>
<li>做事情很负责</li>
<li>做事情有信念</li>
</ul>]]></content>
        <author>
            <name><![CDATA[苏瑞辅的个人网站]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.suruifu.com/posts/712</id>
        <title><![CDATA[成就别人就是成就自己]]></title>
        <updated>2022-06-28T15:08:36+08:00</updated>
        <link href="https://www.suruifu.com/posts/712"/>
        <content type="text/html" src="https://www.suruifu.com/posts/712"><![CDATA[]]></content>
        <author>
            <name><![CDATA[苏瑞辅的个人网站]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.zwlin.io/post/modern-unix/</id>
        <title><![CDATA[Modern Unix]]></title>
        <updated>2022-06-21T02:00:54+08:00</updated>
        <link href="https://blog.zwlin.io/post/modern-unix/"/>
        <content type="text/html" src="https://blog.zwlin.io/post/modern-unix/"><![CDATA[<p>所谓工欲善其事，必先利其器，我相信很多程序员都喜欢 Unix 风格的命令行，而 Unix 历史久远， 很多 Unix 上的命令行工具都有了更加 Modern 的替代品，其中由 Rust/Go 编写的命令行工具，更成了这类工具的主流， 它们要么速度更快，要么更加“花里胡哨”。这篇文章打算介绍一些我正在使用的 Modern Unix 工具以及我的终端环境。</p>
<h2 id="starshiphttpsgithubcomstarshipstarship"><a href="https://github.com/starship/starship">starship</a></h2>
<p>starship 是一个通用的终端提示符（prompt）自定义工具，由 Rust 编写，支持任何 shell，包括 Windows 上的 Powershell，用法很简单，有一点小要求就是你的终端需要支持 <a href="https://github.com/ryanoasis/nerd-fonts/tree/gh-pages">Nerd Font</a>，我用 starship 定制了一个仿 ohmyzsh 的 ys 主题，预览效果如下：</p>
<p><img src="starship.png" alt="starship"></p>
<p>我选择 starship 的原因是他给了我更多自定义终端的可能，而且语法简单，配置文件写起来也毫无障碍，我不喜欢 ys 主题的 git status 功能，而且我想给我的终端加上 Haskell 的提示，这些都可以通过 starship 做到。</p>
<p>但是 starship 的自定义功能现在还稍显孱弱,当我想实现不同的发行版提示不同的图标，这一点在 Powerlevel10k 可以做到，但是 statrship 就暂时没有办法很方便的配置（<a href="https://github.com/starship/starship/issues/3251">相关issue</a>），我也很期待 starship 未来的开发。</p>
<h2 id="neovimhttpsgithubcomneovimneovim"><a href="https://github.com/neovim/neovim">neovim</a></h2>
<p>noevim 是更加现代的 vim，在之前的博客中也介绍了，这里就不多描述了。</p>
<h2 id="bathttpsgithubcomsharkdpbat"><a href="https://github.com/sharkdp/bat">bat</a></h2>
<p>bat 是一个更加现代化的 cat ，支持语法高亮和 git 集成，我个人是把完全使用 bat 来替换 cat 了，在我日常使用中，bat 对于 cat 的行为几乎是完全兼容的。
我设置了 alias 来无缝迁移到 bat：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln">1</span><span class="cl"><span class="nb">alias</span> <span class="nv">cat</span><span class="o">=</span><span class="s2">&#34;bat&#34;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nb">alias</span> <span class="nv">catp</span><span class="o">=</span><span class="s2">&#34;bat -p&#34;</span>
</span></span></code></pre></div><p>下面是一些功能展示：</p>
<p><img src="https://camo.githubusercontent.com/7b7c397acc5b91b4c4cf7756015185fe3c5f700f70d256a212de51294a0cf673/68747470733a2f2f696d6775722e636f6d2f724773646e44652e706e67" alt="语法高亮"></p>
<p><img src="https://camo.githubusercontent.com/c436c206f2c86605ab2f9fb632dd485afc05fccbf14af472770b0c59d876c9cc/68747470733a2f2f692e696d6775722e636f6d2f326c53573452452e706e67" alt="git 集成"></p>
<h2 id="exahttpsgithubcomoghamexa"><a href="https://github.com/ogham/exa">exa</a></h2>
<p>exa 是更现代化的 ls 命令，和 bat 一样，我也用 exa 替代了一些命令，如果需要显示图标，同样需要 nerd font，下面给出我的 alias 设置:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln">1</span><span class="cl"><span class="nb">alias</span> <span class="nv">l</span><span class="o">=</span><span class="s2">&#34;exa -lg --icons&#34;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nb">alias</span> <span class="nv">la</span><span class="o">=</span><span class="s1">&#39;exa -lghHa --group-directories-first --icons&#39;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="nb">alias</span> <span class="nv">ll</span><span class="o">=</span><span class="s1">&#39;exa -lghH --group-directories-first --icons&#39;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="nb">alias</span> <span class="nv">ls</span><span class="o">=</span><span class="s2">&#34;ls --color=auto&#34;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="nb">alias</span> <span class="nv">tree</span><span class="o">=</span><span class="s2">&#34;exa -T --group-directories-first --icons&#34;</span>
</span></span></code></pre></div><p>下面是 la 的示例：</p>
<p><img src="image-20220621111124431.png" alt="image-20220621111124431"></p>
<h2 id="fdhttpsgithubcomsharkdpfd"><a href="https://github.com/sharkdp/fd">fd</a></h2>
<p>fd 是 find 命令的现代化替代，同样也是使用 Rust 编写，语法简单，速度快，也是我的常用命令。例如： 删除所有的 mp3 文件可以写成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln">1</span><span class="cl">fd -e .mp3 --exec rm
</span></span></code></pre></div><h2 id="fzfhttpsgithubcomjunegunnfzf"><a href="https://github.com/junegunn/fzf">fzf</a></h2>
<p>fzf 是我非常喜欢的命令行模糊查找工具，可以和很多工具配合，例如 fd、neovim、rg、 z.lua 中，都可以集成 fzf，可以说是一个非常强大的工具了。下面是我的一些 fzf 配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">if</span> <span class="nb">type</span> rg <span class="p">&amp;</span>&gt; /dev/null<span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"> <span class="nb">export</span> <span class="nv">FZF_DEFAULT_COMMAND</span><span class="o">=</span><span class="s1">&#39;rg --files&#39;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"> <span class="nb">export</span> <span class="nv">FZF_DEFAULT_OPTS</span><span class="o">=</span><span class="s1">&#39;-m --height 50% --border&#39;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="k">fi</span>
</span></span></code></pre></div><p>在命令行：</p>
<p><img src="image-20220621112406501.png" alt="image-20220621112406501"></p>
<p>在vim：</p>
<p><img src="image-20220621112748929.png" alt="image-20220621112748929"></p>
<h2 id="ripgrephttpsgithubcomburntsushiripgrep"><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a></h2>
<p>ripgrep 简称 rg，是 grep 命令的现在替代，功能强大，语法简单，性能强劲。也是我的常用工具。配合 fzf 十分好用。
在上面的截图中，配合 fzf 的工具就是 rg。</p>
<h2 id="zluahttpsgithubcomskywind3000zlua"><a href="https://github.com/skywind3000/z.lua">z.lua</a></h2>
<p>z.lua 是一个快速路径切换工具（类似 z.sh / autojump），特点就是速度快，支持 fzf 补全。可以免去 cd 到具体路径的重复操作，它会跟踪你在 shell 下访问过的路径，通过一套称为 Frecent 的机制（源自 FireFox），经过一段简短的学习之后，z.lua 会帮你跳转到所有匹配正则关键字的路径里 Frecent 值最高的那条路径去。</p>
<p>我的一些 alias：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln">1</span><span class="cl"><span class="nb">alias</span> <span class="nv">zb</span><span class="o">=</span><span class="s2">&#34;z -b&#34;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nb">alias</span> <span class="nv">zf</span><span class="o">=</span><span class="s2">&#34;z -I&#34;</span>
</span></span></code></pre></div><h2 id="other">Other</h2>
<p>还有很多现代的命令行工具，可以在 <a href="https://github.com/ibraheemdev/modern-unix">Modern Unix</a> 这个 repo 看到更多 modern unix 工具，其中有些我不是很常用，这里也不多介绍了。</p>
<p>上文介绍的都是我非常常用的一些工具，非常推荐朋友们试试，我相信你会喜欢的。</p>]]></content>
        <author>
            <name><![CDATA[Zwlin’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.suruifu.com/posts/699</id>
        <title><![CDATA[20220611]]></title>
        <updated>2022-06-11T00:23:54+08:00</updated>
        <link href="https://www.suruifu.com/posts/699"/>
        <content type="text/html" src="https://www.suruifu.com/posts/699"><![CDATA[<p>经过一段时间的努力工作，生活逐步入正轨，走出了一地鸡毛的处境。我要继续努力工作，绘制更加宏伟的人生画卷。</p>]]></content>
        <author>
            <name><![CDATA[苏瑞辅的个人网站]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.stdioa.com/2022/06/encode-ipv6-into-utf8/</id>
        <title><![CDATA[一种 IPv6 地址编码方案]]></title>
        <updated>2022-06-10T12:57:53+08:00</updated>
        <link href="https://blog.stdioa.com/2022/06/encode-ipv6-into-utf8/"/>
        <content type="text/html" src="https://blog.stdioa.com/2022/06/encode-ipv6-into-utf8/"><![CDATA[<p>又搞了一些骚操作：把一个 IPv6 地址压缩成一个短字符串。</p>]]></content>
        <author>
            <name><![CDATA[Stdio’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://miaotony.xyz/2022/05/31/CTF_2022CISCN_preliminary/</id>
        <title><![CDATA[CTF | 2022 CISCN 初赛 WriteUp]]></title>
        <updated>2022-06-03T12:02:42+08:00</updated>
        <link href="https://miaotony.xyz/2022/05/31/CTF_2022CISCN_preliminary/"/>
        <content type="text/html" src="https://miaotony.xyz/2022/05/31/CTF_2022CISCN_preliminary/"><![CDATA[又是一年一度的国赛，今年知识问答和场景实操加起来持续10h，比去年轻松了不少，这篇来记录一下初赛的writeup。]]></content>
        <author>
            <name><![CDATA[MiaoTony]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.vvzero.com/2022/05/25/freebsd-vs-linux-which-open-source-os-is-superior/</id>
        <title><![CDATA[FreeBSD vs Linux：哪个开源操作系统更强大]]></title>
        <updated>2022-05-31T12:58:15+08:00</updated>
        <link href="https://blog.vvzero.com/2022/05/25/freebsd-vs-linux-which-open-source-os-is-superior/"/>
        <content type="text/html" src="https://blog.vvzero.com/2022/05/25/freebsd-vs-linux-which-open-source-os-is-superior/"><![CDATA[<blockquote><p>本文是“攻玉计划”的一部分，翻译自 <a href="https://www.ateamsystems.com/tech-blog/freebsd-vs-linux-which-open-source-os-is-superior/">https://www.ateamsystems.com/tech-blog/freebsd-vs-linux-which-open-source-os-is-superior/</a></p></blockquote><p>FreeBSD 和 Linux，哪一个更强大？这个问题没那么简单。它们各有春秋，不能一概而论。</p><p>来自我们 A-Team Systems 的专家们有数十年这两个系统的使用经验，所以，我们将详细阐述这两个系统的优势和劣势，供你选择最适合的系统。</p><h2 id="FreeBSD-vs-Linux：功能对比"><a href="#FreeBSD-vs-Linux：功能对比" class="headerlink" title="FreeBSD vs Linux：功能对比"></a>FreeBSD vs Linux：功能对比</h2><p>让我们比较一下这两个 Unix 系统的关键几个方面：</p><h3 id="操作系统完整性"><a href="#操作系统完整性" class="headerlink" title="操作系统完整性"></a>操作系统完整性</h3><p>在这一点上，<a href="https://www.ateamsystems.com/tech-blog/intro-to-freebsd-learn-what-it-is-and-how-it-works/">FreeBSD</a> 更有优势。<br>这是因为 Linux 实际上并不是一个完整的操作系统，而只是一个内核。这是一个很常见的误解，因为很多用户经常把 Linux 看成是一个完整的操作系统。<br>各个 Linux 发行版通常会将必需的软件和库文件打包进系统，这些软件和库文件大多来自 GNU 项目，所以自由软件基金会才将 Linux 称作“GNU/Linux”。</p><p>以下是一些流行的 Linux 发行版：</p><ul><li>Ubuntu</li><li>CentOS</li><li>Fedora</li><li>Arch Linux</li><li>Linux Mint</li><li>Debian</li></ul><h3 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h3><p>关于价格，二者不分胜负。因为作为开源软件，FreeBSD 和 Linux 自然都是免费的。</p><blockquote><p>译者按：在译者看来，开源并不一定意味着免费，很多开源许可证并不允许商用。当然，Linux 和 FreeBSD 是允许免费商用的。</p></blockquote><p>你可能需要为某些额外功能付费，比如服务支持、硬件等。</p><p>任何人都可以免费使用、修改、分发、查阅 Linux 及 FreeBSD 的源代码。但是，任何对 Linux 所作的修改都必须公开源码。<br>而 FreeBSD 并不需要公开，因此，需要在产品中使用相关源码的公司，在这一点上可能更倾向于使用 FreeBSD。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>FreeBSD 比 Linux 略微更安全一点。FreeBSD 项目的核心支柱之一就是安全性，并且预先安装了顶级的安全功能，所以在这一点上，毫无疑问它更有优势。</p><p>但这也并不意味着 Linux 不安全。Linux 是高度可配置的，因此可以实现你想要的任何安全特性。但是从操作系统整体角度来看，FreeBSD 的安全性更高。</p><h3 id="硬件与架构支持"><a href="#硬件与架构支持" class="headerlink" title="硬件与架构支持"></a>硬件与架构支持</h3><p>如果比较硬件与架构支持度的话，Linux 绝对是占优势的。Linux 可以在许多不同的平台上运行，但是 FreeBSD 不行。所以，如果你很在乎兼容性和跨平台性，请选择 Linux。</p><p>但这也是一把双刃剑，为了能在大量不同的平台上运行，Linux 必须牺牲一部分性能以换取兼容性。而另一方面，FreeBSD 无需牺牲性能，因为它只需要在有限数量的平台上运行即可。</p><p>由于 Linux 是一个主流的系统，而 FreeBSD 不是，所以设备制造商更倾向于制造兼容 Linux 的软硬件。举个例子，如果你需要经常更新显卡驱动，Linux 会比 FreeBSD 更快获取相关更新支持。</p><p>FreeBSD 对硬件支持的短板大多集中在外设和显卡这种桌面级应用方面。但 FreeBSD 的目标场景是服务器应用，所以这并没有多大影响。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>Linux 和 FreeBSD 都相当稳定可靠。但如果必须得比个高下的话，FreeBSD 会更稳定一点。这又回到了一个事实：FreeBSD 更有组织性。Linux 的稳定性可能会被用户使用的额外组件而拖累。而与此同时，FreeBSD 是一个完整的操作系统，所以它的默认配置更加可靠。总而言之，二者都不缺乏稳定性。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>虽然业界没有确凿的证据证明 FreeBSD 比 Linux 的性能更优，但是大多数用过二者的用户都说 FreeBSD 在这方面更强一点。这同样归咎于 Linux 的高兼容性。FreeBSD 更精简，无需对环境做额外的判断，因此通常来说它的性能更好。</p><p>FreeBSD 的延迟比 Linux 更低。这里延迟指的是系统时钟中断发生后，到处理器开始运行代码的这段时间。但是大多数应用在 Linux 上跑得更快。</p><h3 id="许可证"><a href="#许可证" class="headerlink" title="许可证"></a>许可证</h3><p>FreeBSD 使用了它自己的 BSD 许可证。该许可证允许用户免费使用该操作系统，并随意修改源码。如果愿意的话，用户也可以发布修改后的源码，或者直接闭源，BSD 许可证允许他们这么做。</p><p>Linux 使用的是 GNU GPL 许可证（GNU通用公共许可协议）。用户可在遵循该许可证限制的情况下随意修改源码。主要区别是，如果你对 Linux 源码作了修改，那么法律意义上你<strong>必须</strong>公开你的代码。</p><blockquote><p>译者按：译者认为这是片面的，如果你修改代码并仅供自己研究使用，那么不需要公开代码。你只需要把源码公开给用户即可。</p></blockquote><p>这个许可证既有好处也有坏处，最大的劣势就是，用户不能用 Linux 开发闭源的系统。而优势是，所有用户都可互相贡献代码，推动整个项目前进。这也是 Linux 能有这么大社区的原因。</p><p>大多数用户无需关心本节的区别，因为大多数人根本不会修改源码。但如果你想使用一个开源的系统来开发闭源的系统，请选择 FreeBSD 而不是 Linux。</p><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>从用户角度，大多数人可能认为 Linux 默认的 BASH 比 FreeBSD 的 tcsh 更强大，因为 tcsh 太落伍了。BASH 非常灵活，用户几乎可以在任何 Unix 兼容的系统上做任何事。但这也并不意味着 tcsh 一无是处，tcsh 只是学习路线更陡峭而已。当然，在 FreeBSD 上安装 BASH 也很简单。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>这一方面，二者也是平手。Linux 和 FreeBSD 都采用了非常高效的文件系统。</p><p>FreeBSD 默认使用 ZFS（泽字节文件系统），这绝对是长期存储数据的最佳文件系统之一。它内置了一个磁盘卷管理器，因此允许用户在同一个存储池上创建多个文件系统。因此在发生物理故障、操作失误或者数据损坏的情况下，仍能保证数据一定的可靠性。</p><p>ext4 是大多数 Linux 发行版的默认文件系统。它不如 ZFS 那么灵活，但相当可靠。</p><h3 id="制造商支持"><a href="#制造商支持" class="headerlink" title="制造商支持"></a>制造商支持</h3><p>这一轮 Linux 获胜。IBM、戴尔和惠普的服务器都直接支持运行 Linux。FreeBSD 也能在这些服务器上运行，并且有 A-Team Systems 团队可提供支持。你可以查阅 FreeBSD 的 <a href="https://www.freebsd.org/commercial/hardware/">硬件制造商</a> 以了解当前所支持的硬件。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>当考虑更新时，你需要关注两方面：更新的便捷度以及更新发布是否及时。</p><p>在便捷度方面，FreeBSD 更胜一筹。用户可以依其意愿选择更新某些组件，比如，你可以只更新某些核心组件，比如内核、源码等，或者只更新它们的子组件。当然也可以全部更新，操作非常简单。</p><p>而对于更新的及时度，Linux 表现得更好。开源公司通常有很强的动力去更新，因此，只要有需求，更新很快就能发布。FreeBSD 可能需要花更长的时间去开发、发布更新，但事实上，Linux 和 FreeBSD 经常可以同时获取相关更新，因为他们使用了同样的上游项目。</p><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>在 FreeBSD 上安装软件包很简单。FreeBSD Ports 项目包含了将近 40000 个软件源，用户或管理员可以方便快捷地安装它们。每个软件源都有针对用户实际系统的相关补丁，以确保软件能在特定平台上正常运行。</p><p>而不同 Linux 发行版的包管理工具就参差不齐了，有些非常棒，有些就很一般。以下是一些做得比较好的包管理工具：</p><ul><li>DPKG - Debian</li><li>RPM - Red Hat</li><li>Pacman Package Manager</li><li>Pkgsrc</li><li>Portage</li></ul><h3 id="开发维护人员"><a href="#开发维护人员" class="headerlink" title="开发维护人员"></a>开发维护人员</h3><p>FreeBSD 核心团队有 9 名成员，并在世界范围内有大约 500 名代码贡献者。这个团队负责调试、开发并优化主线代码仓库。大多数贡献者都是不求回报的志愿者，核心团队成员由所有活跃的贡献者每两年一次投票选出。</p><p>而 Linux 内核由 Linus Torvals 先生管理维护，他也是 Linux 的缔造者。Linus 先生对 Linux 的新功能拥有最终决定权。</p><h2 id="FreeBSD-与-Linux-到底如何不同？"><a href="#FreeBSD-与-Linux-到底如何不同？" class="headerlink" title="FreeBSD 与 Linux 到底如何不同？"></a>FreeBSD 与 Linux 到底如何不同？</h2><p>FreeBSD 是一个完整的操作系统，拥有内核、驱动、文档以及各种工具。Linux 只有内核以及部分驱动，并且依赖第三方系统软件才能运行。FreeBSD 的源码使用 BSD 许可证，而 Linux 使用 GPL 许可证。</p><p>Linux 广泛支持各种硬件，而 FreeBSD 支持的硬件非常有限。Linux 也是当前市场上最流行的开源操作系统，所以不缺各种支持。FreeBSD 也有非常忠实的用户群，但远不能与 Linux 的用户群相提并论。</p><h2 id="FreeBSD-比-Linux-更安全吗？"><a href="#FreeBSD-比-Linux-更安全吗？" class="headerlink" title="FreeBSD 比 Linux 更安全吗？"></a>FreeBSD 比 Linux 更安全吗？</h2><p>FreeBSD 的安全问题通常比 Linux 更少，但是差距并不大。Linux 的用户比 FreeBSD 更多，所以也会发现更多的漏洞。由于 FreeBSD 提供了完整的操作系统，所以其默认配置非常安全。</p><p>Linux 系统的安全性取决于用户的配置。由于其高度的可定制化，Linux 用户可以让他们的系统变得几乎牢不可破。</p><h2 id="FreeBSD-可以运行-Linux-的程序吗？"><a href="#FreeBSD-可以运行-Linux-的程序吗？" class="headerlink" title="FreeBSD 可以运行 Linux 的程序吗？"></a>FreeBSD 可以运行 Linux 的程序吗？</h2><p>FreeBSD 提供了与 Linux 的 <a href="https://docs.freebsd.org/en/books/handbook/linuxemu/">二进制兼容性</a>。这允许用户在 FreeBSD 系统上安装并运行 Linux 的二进制程序。FreeBSD 上默认没有安装 Linux 的相关库文件，但可以从 FreeBSD Ports 上安装，或者手动安装。</p><h2 id="为什么-Linux-比-FreeBSD-更流行？"><a href="#为什么-Linux-比-FreeBSD-更流行？" class="headerlink" title="为什么 Linux 比 FreeBSD 更流行？"></a>为什么 Linux 比 FreeBSD 更流行？</h2><p>这其中有多个原因。一方面，FreeBSD 缺乏硬件支持，这就限制了用户使用它的场景。</p><p>另一个原因是 FreeBSD 缺乏商业支持。有如 Red Hat 这样的大公司能确保 Linux 及时获取更新支持，但对于 FreeBSD 而言这是不可能的。</p><p>最后，Linux 拥有数量众多的软件，允许其发挥最大的灵活性和可用性。FreeBSD 提供了一些预编译的软件包，但仍无法与 Linux 相比。</p><h2 id="FreeBSD-和-Linux-哪个用起来更简单？"><a href="#FreeBSD-和-Linux-哪个用起来更简单？" class="headerlink" title="FreeBSD 和 Linux 哪个用起来更简单？"></a>FreeBSD 和 Linux 哪个用起来更简单？</h2><p>FreeBSD 和 Linux 都需要一定的学习成本。但是，FreeBSD 相对而言更易学习使用，因为它没有那么多学习选项，例如发行版、包管理工具等等。</p><p>大多数开发者认为，比起 FreeBSD，Linux 太混乱了。对于同一个任务有无数种实现方案，并且不同的用户对应该如何选择方案有不同（且强烈）的意见。Linux 社区是一个快节奏的社区，经常经历变化。因此，很多用户更喜欢 FreeBSD 社区的一致性和条理性。</p><h2 id="哪个更快？"><a href="#哪个更快？" class="headerlink" title="哪个更快？"></a>哪个更快？</h2><p>总的来说，FreeBSD 通常比 Linux 更快。这主要是因为它是一个完整的系统。此外，FreeBSD 的延迟比 Linux 低，也就意味着它能更快处理输入。有如网飞、苹果和思科之类的公司会采用 FreeBSD 以获取这种处理速度优势。</p><p>Linux 也能获得类似的速度，但是，这取决于你的配置。还值得注意的是，大多数应用程序在 Linux 上运行得更快。因此大多数超级计算机会使用 Linux 而不是 FreeBSD。</p><h2 id="FreeBSD-vs-Linux：哪一个最适合你？"><a href="#FreeBSD-vs-Linux：哪一个最适合你？" class="headerlink" title="FreeBSD vs Linux：哪一个最适合你？"></a>FreeBSD vs Linux：哪一个最适合你？</h2><p>FreeBSD 和 Linux 都可作为开源用户的选择。最主要的区别就是，FreeBSD 更完整，更标准化，而 Linux 只提供了内核及驱动，需要第三方软件支持。</p><p>如果想要尽可能少地配置系统，FreeBSD 是更好的选择。但是，Linux 提供了更多的自定义选项，对于想要定制系统的人是个更好的选择。另外，如果你有硬件平台限制的话，Linux 的支持性可能更好点。</p><p>如果你喜欢紧跟技术潮流，Linux 的新技术、新特性和更新速度肯定会让你满意。如果稳定性、性能和安全性对你来说更重要，FreeBSD 也许更适合你。</p>]]></content>
        <author>
            <name><![CDATA[VVBLOG]]></name>
        </author>
    </entry>
    
    <entry>
        <id>http://blog.qrzbing.cn/post/2022-ciscn22-baby_tree/</id>
        <title><![CDATA[CISCN 2022 baby_tree]]></title>
        <updated>2022-05-31T10:44:56+08:00</updated>
        <link href="http://blog.qrzbing.cn/post/2022-ciscn22-baby_tree/"/>
        <content type="text/html" src="http://blog.qrzbing.cn/post/2022-ciscn22-baby_tree/"><![CDATA[<p>#reverse #swift #ast</p>
<p>一道基础的 swift AST 题目。</p>]]></content>
        <author>
            <name><![CDATA[QRZ’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.zwlin.io/post/hhkb/</id>
        <title><![CDATA[HHKB and Key bindings]]></title>
        <updated>2022-05-27T01:48:34+08:00</updated>
        <link href="https://blog.zwlin.io/post/hhkb/"/>
        <content type="text/html" src="https://blog.zwlin.io/post/hhkb/"><![CDATA[<h2 id="hhkb">HHKB</h2>
<p>自 2021 年 4 月中购入<code>HHKB</code> ，到目前为止已经使用了一年多，期间除了偶尔用用笔记本自带的键盘外，没碰过别的键盘，总的来说，我对这把键盘很满意。对我来说，键盘的手感这种类玄学说法在我这里不生效，HHKB对我来说就是一个完全够用的小个头键盘，比较合理的键位配置，舒服的移动距离，才是我喜欢它的原因。而我的快捷键配置也是随着我对<code>HHKB</code>的熟悉慢慢变化的，前半年我用的是有刻的键帽，后半年我开始尝试了无刻，然后就真香了。无刻虽然开始时比较困难，但是一旦熟悉，就只有好处了。</p>
<h3 id="无刻的好处">无刻的好处</h3>
<ul>
<li>可以让注意力集中，不会因为低头看键盘找键而分心（因为键盘上也没东西）</li>
<li>可以迫使自己对键盘进行记忆，我相信大部分人对于字母可以盲打，但是对于部分符号，就比较困难。无刻可以帮助你记忆这些快捷键的位置，因为没有眼睛的帮助，你就没有退路，必须靠肌肉记忆。这也算刻意练习的一种吧。</li>
<li>可以更好的自定义你的键盘，当你把一些键映射成别的键之后，键盘上印刷的功能和实际的功能并不相同，有时会突然会造成眼睛和肌肉记忆的冲突，而无刻就没有这种问题，一切键映射都存在于你的肌肉记忆中。</li>
<li>配合你自己的各种键映射，可以想怎么舒服怎么来（但是也加大了别人使用你电脑，和你使用别人电脑的难度</li>
</ul>
<h2 id="键映射">键映射</h2>
<p>首先我会把系统的快捷键全部取消，因为那些功能我用不到，用到时可以再设置，这样你绑定自己的快捷键时就不用担心会不会冲突了。因此，系统的快捷键我只保留了一个切换输入法，其他的全部取消。</p>
<p>然后使用 <a href="https://karabiner-elements.pqrs.org/">karabiner-elements</a> 进行简单的键映射:</p>
<table>
<thead>
<tr>
<th>键（组合键）</th>
<th>功能（映射）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Right Command</td>
<td>单独按还是 Command，当和别的键「KEY」一起按时，映射成 Control + Option + Comand + 「KEY」</td>
</tr>
<tr>
<td>Right Option</td>
<td>映射成Comma，也就是逗号键，用作我vim的第二个Leader（第一个Leader是空格）</td>
</tr>
<tr>
<td>Left Control</td>
<td>单独按是切换输入法，当和别的键「KEY」一起按时，映射成 Control + 「KEY」</td>
</tr>
<tr>
<td>Tab + hjkl</td>
<td>映射成方向键</td>
</tr>
</tbody>
</table>
<p><code>Right Command</code> 和 <code>Right Option</code> 在我个人的体验中，原本的功能我几乎用不到，都用的是左边的，与其让其闲置，不如将其映射成别的键，其中 Right Command 映射成 <code>Control + Option + Comand</code>，可以作为我个人的一个super prefix键，以保证不会和任何软件或者系统的快捷键冲突。</p>
<p>上述功能的达成，需要用到 <code>Karabiner</code> 的 <code>Complex Modifications</code> 功能，网上教程很多，也可以使用别人分享出来的方案，我这里就不多讲述了。</p>
<p>这里多提一句，因为HHKB的<code>Control</code>是放在传统键盘<code>Caps Lock</code>的位置的，所以mac自带的<code>Caps Lock</code>如果被映射成了<code>Control</code>，也是可以用这个方案来保留 <strong>Caps Lock</strong> 切换输入法的功能的。下面放上我完成这个功能的<code>Karabiner</code>配置:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"> <span class="nt">&#34;title&#34;</span><span class="p">:</span> <span class="s2">&#34;swith input with ctrl&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"> <span class="nt">&#34;rules&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"> <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;短按 ctrl 切换输入法&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"> <span class="nt">&#34;manipulators&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"> <span class="nt">&#34;from&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"> <span class="nt">&#34;key_code&#34;</span><span class="p">:</span> <span class="s2">&#34;left_control&#34;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"> <span class="p">},</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"> <span class="nt">&#34;to&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"> <span class="nt">&#34;key_code&#34;</span><span class="p">:</span> <span class="s2">&#34;left_control&#34;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"> <span class="p">],</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"> <span class="nt">&#34;to_if_alone&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"> <span class="p">{</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"> <span class="nt">&#34;key_code&#34;</span><span class="p">:</span> <span class="s2">&#34;spacebar&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"> <span class="nt">&#34;modifiers&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"> <span class="s2">&#34;left_option&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"> <span class="s2">&#34;left_command&#34;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"> <span class="p">]</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"> <span class="p">],</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"> <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;basic&#34;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"> <span class="p">]</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl"> <span class="p">]</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>PS</strong>: 我这里并不是把短按<code>Control</code>变成<code>Caps Lock</code>，而是变成了 <code>Command + Option + Space</code>。这是因为我不喜欢<code>Caps Lock</code>的功能，所以为了避免按成<code>Caps Lock</code>，单独映射到了一个组合键（这个组合键是我在系统里配置的切换输入法的组合键，也可以变成别的，但是还是不建议变成Caps Lock，容易按错） 。</p>
<h2 id="超级键">超级键</h2>
<p>有了这个超级键<code>Control + Option + Comand</code>之后，你就可以用这个Super Prefix来配置自己的快捷键，例如使用Thor，Ray Cast，HammerSpoon等软件，映射自己的快捷键。</p>
<table>
<thead>
<tr>
<th>组合键 （Super Prefix 用 SP 指代）</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>SP + ` (反单引号，HHKB最右上角）</td>
<td>切换到终端（iterm2）</td>
</tr>
<tr>
<td>SP + d</td>
<td>使用dash搜索 （用raycast完成）</td>
</tr>
<tr>
<td>SP + v</td>
<td>从剪贴板历史粘贴（用raycast完成）</td>
</tr>
<tr>
<td>SP + 1</td>
<td>打开 Chrome</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>]]></content>
        <author>
            <name><![CDATA[Zwlin’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.zwlin.io/post/2022-nvim/</id>
        <title><![CDATA[2022年的 neovim 配置方案]]></title>
        <updated>2022-05-17T13:50:17+08:00</updated>
        <link href="https://blog.zwlin.io/post/2022-nvim/"/>
        <content type="text/html" src="https://blog.zwlin.io/post/2022-nvim/"><![CDATA[<p>在前不久，我把我的<code>nvim</code>配置从<code>vimscript</code>全部迁移到了<code>lua</code>。故在此记录一下我的<code>neovim</code>配置方案。</p>
<h2 id="大致目录结构">大致目录结构</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1"># ~/.config/nvim</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">.
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">├── init.lua
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">├── lua
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">│   ├── basic.lua
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">│   ├── colorscheme.lua
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">│   ├── keybindings.lua
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">│   ├── lsp
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">│   │   ├── go.lua
</span></span><span class="line"><span class="ln">10</span><span class="cl">│   │   ├── haskell.lua
</span></span><span class="line"><span class="ln">11</span><span class="cl">│   │   ├── lua.lua
</span></span><span class="line"><span class="ln">12</span><span class="cl">│   │   ├── null-ls.lua
</span></span><span class="line"><span class="ln">13</span><span class="cl">│   │   ├── nvim-cmp.lua
</span></span><span class="line"><span class="ln">14</span><span class="cl">│   │   ├── python.lua
</span></span><span class="line"><span class="ln">15</span><span class="cl">│   │   ├── setup.lua
</span></span><span class="line"><span class="ln">16</span><span class="cl">│   │   └── ultisnips.lua
</span></span><span class="line"><span class="ln">17</span><span class="cl">│   ├── plugin-config
</span></span><span class="line"><span class="ln">18</span><span class="cl">│   │   ├── bufferline.lua
</span></span><span class="line"><span class="ln">19</span><span class="cl">│   │   ├── dashboard.lua
</span></span><span class="line"><span class="ln">20</span><span class="cl">│   │   ├── indent-blankline.lua
</span></span><span class="line"><span class="ln">21</span><span class="cl">│   │   ├── mundo.lua
</span></span><span class="line"><span class="ln">22</span><span class="cl">│   │   ├── nvim-tree.lua
</span></span><span class="line"><span class="ln">23</span><span class="cl">│   │   ├── transparent.lua
</span></span><span class="line"><span class="ln">24</span><span class="cl">│   │   ├── treesitter.lua
</span></span><span class="line"><span class="ln">25</span><span class="cl">│   │   └── vista.lua
</span></span><span class="line"><span class="ln">26</span><span class="cl">│   └── plugins.lua
</span></span><span class="line"><span class="ln">27</span><span class="cl">├── python-nvim
</span></span><span class="line"><span class="ln">28</span><span class="cl">└── README.md
</span></span></code></pre></div><ul>
<li>
<p><code>init.lua</code> 作为配置的入口</p>
</li>
<li>
<p><code>lua</code> 文件夹是所有配置存放的地方</p>
<ul>
<li>
<p><code>basic.lua</code> 基础配置</p>
</li>
<li>
<p><code>colorscheme.lua</code> 主题相关</p>
</li>
<li>
<p><code>keybindings.lua</code> 快捷键设置</p>
</li>
<li>
<p><code>plugins.lua</code> 插件相关</p>
</li>
<li>
<p><code>lsp</code> 存放所有和LSP相关的配置</p>
</li>
<li>
<p><code>plugin-config </code>存放每个插件的非默认设置</p>
</li>
</ul>
</li>
<li>
<p><code>python-nvim</code>文件夹是给<code>nvim</code>专门配置的<code>python</code>解释器目录</p>
</li>
</ul>
<h2 id="插件">插件</h2>
<p>我用的插件不是很多，这次变更是一次重大变化，几乎全部插件都改用了使用lua编写的，插件管理器用的是大家的主流选择 <a href="https://github.com/wbthomason/packer.nvim">Packer</a> 。</p>
<p>简要说明下一些非常有意思的插件：</p>
<ul>
<li>
<p><a href="https://github.com/jose-elias-alvarez/null-ls.nvim">null-ls</a> 一个非常有创意的LSP,其官方介绍是:</p>
<blockquote>
<p>Use Neovim as a language server to inject LSP diagnostics, code actions, and more via Lua.</p>
</blockquote>
</li>
<li>
<p><a href="https://github.com/nvim-treesitter/nvim-treesitter">nvim-treesitter</a> 现代化的代码高亮，基于syntax tree的语法高亮，而且功能不止语法高亮，可以用来配置折叠等等。</p>
</li>
<li>
<p><a href="https://github.com/neovim/nvim-lspconfig">nvim-lspconfig</a> neovim官方出品的lsp集成插件。</p>
</li>
<li>
<p><a href="https://github.com/williamboman/nvim-lsp-installer">nvim-lsp-installer</a> 帮助自动化的安装和管理 lsp server。</p>
</li>
<li>
<p><a href="https://github.com/hrsh7th/nvim-cmp">nvim-cmp</a> 新一代代码补全引擎。</p>
</li>
</ul>
<h2 id="lsp与代码补全">LSP与代码补全</h2>
<p><code>lsp</code>和代码补全的配置估计是我折腾<code>neovim</code>插件的最复杂的地方，不过在<code>neovim</code>官方出品了<code>lsp</code>的集成插件以及有了非常强大<code>nvim-cmp</code>的之后，在我的更新配置体验中，没有特别复杂的部分，根据文档即可完成配置。</p>
<p>LSP的各种设置都放在了lsp文件夹中，入口文件是setup.lua,没有什么特别的配置，有兴趣的直接可以参考我的<a href="https://github.com/Zwlin98/nvim">nvim配置</a>。</p>
<p>我的<code>nvim</code>配置放在了 <a href="https://github.com/Zwlin98/nvim">github</a>, 应该会随着我的使用更新，不保证会和写下此文时一致。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="https://learnxinyminutes.com/docs/lua/">lua简单教程</a></p>
</li>
<li>
<p><a href="https://github.com/glepnir/nvim-lua-guide-zh">在 neovim 中使用 Lua</a></p>
</li>
<li>
<p><a href="https://github.com/nshen/learn-neovim-lua">Neovim 配置实战</a></p>
</li>
</ul>]]></content>
        <author>
            <name><![CDATA[Zwlin’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.zwlin.io/about/</id>
        <title><![CDATA[About]]></title>
        <updated>2022-05-10T01:41:51+08:00</updated>
        <link href="https://blog.zwlin.io/about/"/>
        <content type="text/html" src="https://blog.zwlin.io/about/"><![CDATA[<h2 id="heading">👏</h2>
<p>这是我的博客，主要记录我学习与生活过程中的一些记录与思考，以及我的一些作品，内容虽然可能有些简单，但是你要是感兴趣，订阅 <a href="https://blog.zwlin.io/index.xml">RSS</a> 关注我，我会非常开心！😊</p>
<h3 id="关于我">关于我</h3>
<p>我是 Zwlin，98年出生，目前计科研究生在读，研究偏向软件工程，主要关注<strong>配置文件与云原生</strong>。本科开始学习编程，打过三年<code>ICPC</code>。</p>
<p>我热爱开源，喜欢探索各种新技术，捣鼓各种电子产品。</p>
<h3 id="关于语言">关于语言</h3>
<p>在本科竞赛时期一直用<code>C++</code>写代码，在退役之后就基本不怎么用了，比较喜欢没有太多历史包袱的新语言，像Go，Rust(还没来的及学)。</p>
<ul>
<li><code>Go</code> 是我最常用的语言，我喜欢她的简洁，也讨厌她的简洁。她对于并发的抽象很像学校里学习到的，CSP也很好理解，用Go写并发真的很快乐。</li>
<li><code>Haskell</code> 也是一门非常优雅的语言，我对于函数式编程的认识，来自于SICP这本书中的<code>Scheme</code>,之后就逐渐喜欢上了函数式的一些特性与思想进而学习了<code>Haskell</code>。<code>Haskell</code>的强类型也和<code>Go</code>有异曲同工之感，<code>Haskell</code>的类型约束给我一种强烈的信心，通过类型检查的代码基本就是写对了。</li>
<li><code>Python</code> <em>Life is short, you need Python!</em> 在我写一些小脚本的时候，或者验证一些的想法时，往往就会打开<code>vim</code>或者<code>jupyter</code>，<code>Python</code>会很快的告诉我答案，<code>Python</code>也非常适合用来做原型语言，在有了原型之后，再用别的语言完善。</li>
</ul>
<h3 id="找到我">找到我</h3>
<p>欢迎和我交流任何有关技术的话题! 你可以通过以下方式找到我:</p>
<ul>
<li>Email: <a href="mailto:blog@zwlin.mozmail.com">blog@zwlin.mozmail.com</a></li>
<li>GitHub: <a href="https://github.com/Zwlin98">@Zwlin98</a></li>
<li>Telegram: <a href="https://t.me/zwlin98">@zwlin98</a></li>
<li>Telegram Channel: <a href="https://t.me/Zwlin_channel">Zwlin&rsquo;s Channel</a></li>
</ul>]]></content>
        <author>
            <name><![CDATA[Zwlin’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.vvzero.com/2022/05/06/How-to-apply-color-in-Markdown/</id>
        <title><![CDATA[如何在 Markdown 中修改字体颜色]]></title>
        <updated>2022-05-08T04:01:10+08:00</updated>
        <link href="https://blog.vvzero.com/2022/05/06/How-to-apply-color-in-Markdown/"/>
        <content type="text/html" src="https://blog.vvzero.com/2022/05/06/How-to-apply-color-in-Markdown/"><![CDATA[<blockquote><p>本文是“攻玉计划”的一部分，翻译自 <a href="https://stackoverflow.com/questions/35465557/how-to-apply-color-in-markdown">https://stackoverflow.com/questions/35465557/how-to-apply-color-in-markdown</a></p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我想用 Markdown 记录文字信息，但我搜了一圈 Google，发现 Markdown 不支持修改字体颜色。而且 StackOverflow 和 GitHub 的 Markdown 编辑模式也不支持指定文字颜色。</p><p>有什么办法可以在 Markdown 里指定文字颜色吗？</p><h2 id="最佳答案"><a href="#最佳答案" class="headerlink" title="最佳答案"></a>最佳答案</h2><p><strong>太长不看系列：</strong></p><p>Markdown 自身并不支持色彩配置，但你可以在 Markdown 中添加 HTML 代码，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:blue&quot;</span>&gt;</span>这是**蓝色**的文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>以下是长回答：</strong></p><p>根据官方的 <a href="http://daringfireball.net/projects/markdown/syntax#html">语法规则</a>：</p><blockquote><p>Markdown 只有一个用途，就是作为编写网页的一种语法格式。<br>Markdown 不能取代 HTML，甚至不能实现 HTML 的大部分功能。它的语法很简单，只能覆盖很小一部分的 HTML 标签。Markdown 并不是为了让你更方便地插入 HTML 标签。我的观点是，HTML 标签已经很方便了，而 Markdown 是为了让人更容易读、写、改。HTML 是用于发布的格式，而 Markdown 是给人写的格式。因此，<strong>Markdown的语法格式只用来处理可以用纯文本表达的信息。</strong><br>对于任何 Markdown 未实现的功能，直接插入 HTML 代码即可。</p></blockquote><p>由于 Markdown 并不是用来发布的格式，修改字体的颜色已经超出了 Markdown 的处理范围。但你仍可以插入裸的 HTML 代码（因为 HTML 是发布级的格式），例如以下 Markdown 文本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包含 <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:blue&quot;</span>&gt;</span>*蓝色* 文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的 Markdown 语句。</span><br></pre></td></tr></table></figure><p>将会转换为以下 HTML 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>包含 <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:blue&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>蓝色<span class="tag">&lt;/<span class="name">em</span>&gt;</span> 文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的 Markdown 语句。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前，StackOverflow （也许 GitHub 也是）会把 HTML 代码原原本本地显示出来（因为安全性考虑），因此你无法在这些地方实现文字颜色的功能，但你可以在 Markdown 的任何标准实现中使用。</p><p>另一种解决方案是，直接使用 <a href="http://maruku.rubyforge.org/proposal.html#attribute_lists">Markuru</a> 的非标准属性表。此标准后续被 <a href="https://pythonhosted.org/Markdown/extensions/attr_list.html">其它</a> <a href="https://pythonhosted.org/Markdown/extensions/attr_list.html">一些人</a>（可能还有其他类似理念的方案，比如 <a href="http://pandoc.org/MANUAL.html#divs-and-spans">pandoc 中的 div 和 span 参数</a>）继承开发。如果用了这种方案，你就可以为一段文字或者行内元素配置一个类，然后用 CSS 给这个类定义色彩属性。但显然，你必须使用支持这些非标准方案的编辑工具，并且这样写出来的文档也没法移植到其他系统上。</p><h2 id="其他回答-1"><a href="#其他回答-1" class="headerlink" title="其他回答 1"></a>其他回答 1</h2><p>如果你不想嵌入 HTML，只想用纯净的 Markdown 语句，可以尝试添加 emoji 以便强调指定语句。比如：⚠️警告⚠️，🔴重要❗🔴 或者 🔥新功能🔥。</p><h2 id="其他回答-2"><a href="#其他回答-2" class="headerlink" title="其他回答 2"></a>其他回答 2</h2><p>尽管 Markdown 不支持文字颜色属性，但你可以用 CSS 重定义一些格式标签，以便用它们来修改文字颜色。当然，你可以选择是否保留这些格式标签的原有属性。</p><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 重置标签属性</span><br><span class="line">s &#123; <span class="attribute">text-decoration</span>: none; &#125; // 删除线</span><br><span class="line"><span class="selector-tag">em</span> &#123; <span class="attribute">font-style</span>: normal; <span class="attribute">font-weight</span>: bold; &#125; // 斜体</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 增加颜色属性</span><br><span class="line">s &#123; <span class="attribute">color</span>: green &#125;</span><br><span class="line"><span class="selector-tag">em</span> &#123; <span class="attribute">color</span>: blue &#125;</span><br></pre></td></tr></table></figure><p>参见 <a href="https://stackoverflow.com/questions/25535836/how-to-restyle-em-tag-to-be-bold-instead-of-italic">如何使 em 标签标记粗体而不是斜体</a>。</p><p>然后，在 Markdown 文本中这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~~这是绿色~~</span><br><span class="line">_这是蓝色_</span><br></pre></td></tr></table></figure><h2 id="其他回答-3"><a href="#其他回答-3" class="headerlink" title="其他回答 3"></a>其他回答 3</h2><p>可以换个思路，你可以用各种颜色的 Unicode 字符以满足相关需求，比如 🔴，U+1F534（大红圈）。</p><p>举个例子，在我 GitHub 里的硬件项目中，我会用以下的字符以注明接线的颜色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">🔴 红色: +5V</span><br><span class="line">🟠 橙色: +3.3V</span><br><span class="line">⚫ 黑色: GND</span><br><span class="line">⚪ 白色: GND (拉低)</span><br><span class="line">🟣 紫色: I2C 信号线</span><br><span class="line">🟢 绿色: 时钟信号</span><br><span class="line">🟡 黄色: WS2812 信号</span><br><span class="line">🔵 蓝色: 电阻桥（模拟）输入</span><br></pre></td></tr></table></figure><p>这也许能帮到你，你可以直接复制粘贴上述字符到你的文档中，或者直接在网上搜例如“Unicode 紫色方块”之类。当然，它们也叫做 emoji。</p>]]></content>
        <author>
            <name><![CDATA[VVBLOG]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.vvzero.com/2022/05/05/esp8266-pinout-reference-gpios/</id>
        <title><![CDATA[如何在 ESP8266 上选用合适的引脚]]></title>
        <updated>2022-05-05T12:16:34+08:00</updated>
        <link href="https://blog.vvzero.com/2022/05/05/esp8266-pinout-reference-gpios/"/>
        <content type="text/html" src="https://blog.vvzero.com/2022/05/05/esp8266-pinout-reference-gpios/"><![CDATA[<blockquote><p>本文是“攻玉计划”的一部分，翻译自 <a href="https://randomnerdtutorials.com/esp8266-pinout-reference-gpios/">https://randomnerdtutorials.com/esp8266-pinout-reference-gpios/</a></p></blockquote><p>本文旨在介绍 ESP8266 的引脚定义、引脚功能及如何使用它们。</p><p><img src="https://img.vvzero.com/blog/esp8266-pinout-reference-gpios/1.png"></p><p>ESP-12E 模块拥有 17 个 GPIO 引脚。但在各个开发板上，ESP8266 芯片的 GPIO 引脚并不一定全部引出，而且某些引脚不建议使用，某些引脚有非常特殊的功能。</p><p>本文将指导你如何正确使用 ESP8266 的各个 GPIO，避免用错引脚而浪费时间。</p><h2 id="ESP12-E-模块引脚定义"><a href="#ESP12-E-模块引脚定义" class="headerlink" title="ESP12-E 模块引脚定义"></a>ESP12-E 模块引脚定义</h2><p>下图阐述了 ESP-12E 模块的引脚定义。当你的项目使用裸 ESP-12E/F 模块的时候，可以参考此图。</p><p><img src="https://img.vvzero.com/blog/esp8266-pinout-reference-gpios/2.png"></p><blockquote><p>🔵注意：某些开发板可能不能使用全部的引脚，但相同的引脚在不同的开发板上，功能肯定是一样的。</p></blockquote><p>当前市场上有很多不同的 ESP8266 模块/开发板，它们的形状、大小、可用 GPIO 数目各不相同。但最常用的是 ESP-01(S)、ESP-12E/F、NodeMCU 开发板以及 Wemos D1 Mini 开发板。你可以自己搜索这些开发板模块的区别。</p><h2 id="ESP-01-S-引脚定义"><a href="#ESP-01-S-引脚定义" class="headerlink" title="ESP-01(S) 引脚定义"></a>ESP-01(S) 引脚定义</h2><p>如果你在用 ESP-01(S) 的板子，可以参考下图的 GPIO 引脚定义。</p><p><img src="https://img.vvzero.com/blog/esp8266-pinout-reference-gpios/3.png"></p><h2 id="ESP-12E-NodeMCU-开发板"><a href="#ESP-12E-NodeMCU-开发板" class="headerlink" title="ESP-12E NodeMCU 开发板"></a>ESP-12E NodeMCU 开发板</h2><p>ESP-12E NodeMCU 开发板的引脚定义如下图所示。</p><p><img src="https://img.vvzero.com/blog/esp8266-pinout-reference-gpios/4.png"></p><h2 id="Wemos-D1-Mini-开发板"><a href="#Wemos-D1-Mini-开发板" class="headerlink" title="Wemos D1 Mini 开发板"></a>Wemos D1 Mini 开发板</h2><p>Wemos D1 Mini 开发板的引脚定义如下图所示。</p><p><img src="https://img.vvzero.com/blog/esp8266-pinout-reference-gpios/5.png"></p><h2 id="ESP8266-的外设"><a href="#ESP8266-的外设" class="headerlink" title="ESP8266 的外设"></a>ESP8266 的外设</h2><p>ESP8266 的外设包括：</p><ul><li>17 个 GPIO</li><li>SPI</li><li>I2C（软件实现）</li><li>I2S（支持 DMA）</li><li>UART</li><li>10 位 ADC</li></ul><h2 id="推荐使用的引脚"><a href="#推荐使用的引脚" class="headerlink" title="推荐使用的引脚"></a>推荐使用的引脚</h2><p>需要注意的一点是，ESP8266 开发板上丝印的引脚号，并不是芯片真正的 GPIO 编号。比如，D0 是 GPIO16，D1 是 GPIO5。</p><p>下表说明了 ESP8266 开发板上丝印的引脚号与实际 GPIO 编号的对应关系，并提醒你哪些引脚在使用时需要注意。</p><p>绿色标记的引脚可以随意使用；黄色标记的引脚可以使用，但需要注意它们在芯片启动时的影响，可能带来意外的问题。红色标记的引脚不建议用作输入或输出功能。</p><table><thead><tr><th>丝印标签</th><th>GPIO</th><th>可作为输入</th><th>可作为输出</th><th>备注</th></tr></thead><tbody><tr><td>D0</td><td>GPIO16</td><td>不可用于中断</td><td>不可用于 PWM 或 I2C</td><td>🟠启动时为高电平<br>用于从深度睡眠中唤醒</td></tr><tr><td>D1</td><td>GPIO5</td><td>🟢是</td><td>🟢是</td><td>通常用作 <strong>SCL</strong> (I2C)</td></tr><tr><td>D2</td><td>GPIO4</td><td>🟢是</td><td>🟢是</td><td>通常用作 <strong>SDA</strong> (I2C)</td></tr><tr><td>D3</td><td>GPIO0</td><td>已被上拉</td><td>🟢是</td><td>与 FLASH 按键连接，如果拉低则会启动失败</td></tr><tr><td>D4</td><td>GPIO2</td><td>已被上拉</td><td>🟢是</td><td>🟠启动时为高电平<br>连接板载 LED，如果拉低则会启动失败</td></tr><tr><td>D5</td><td>GPIO14</td><td>🟢是</td><td>🟢是</td><td><strong>SPI</strong> (SCLK)</td></tr><tr><td>D6</td><td>GPIO12</td><td>🟢是</td><td>🟢是</td><td><strong>SPI</strong> (MISO)</td></tr><tr><td>D7</td><td>GPIO13</td><td>🟢是</td><td>🟢是</td><td><strong>SPI</strong> (MOSI)</td></tr><tr><td>D8</td><td>GPIO15</td><td>已被下拉至 GND</td><td>🟡是</td><td><strong>SPI</strong> (CS)<br>如果拉高则会启动失败</td></tr><tr><td>RX</td><td>GPIO3</td><td>🟡是</td><td>🔴RX 引脚</td><td>🟠启动时为高电平</td></tr><tr><td>TX</td><td>GPIO1</td><td>🔴TX 引脚</td><td>🟡是</td><td>🟠启动时为高电平<br>启动时的调试输出引脚，如果拉低会启动失败</td></tr><tr><td>A0</td><td>ADC0</td><td>🟢模拟输入</td><td>🔴禁用</td><td></td></tr></tbody></table><p>接下来的篇幅将更详细地介绍 ESP8266 GPIO 引脚的功能。</p><h3 id="连接-FLASH-芯片的引脚"><a href="#连接-FLASH-芯片的引脚" class="headerlink" title="连接 FLASH 芯片的引脚"></a>连接 FLASH 芯片的引脚</h3><p>GPIO6 到 GPIO11 通常用于连接 FLASH 芯片，所以，不推荐使用这几个引脚。</p><h3 id="启动过程中用到的引脚"><a href="#启动过程中用到的引脚" class="headerlink" title="启动过程中用到的引脚"></a>启动过程中用到的引脚</h3><p>如果某些引脚被拉高或者拉低，ESP8266 可能会启动失败。下表是部分引脚在启动时的状态：</p><ul><li><strong>GPIO16</strong>：启动时为高电平</li><li><strong>GPIO0</strong>：如果被拉低，则启动失败</li><li><strong>GPIO2</strong>：启动时为高电平，如果被拉低，则启动失败</li><li><strong>GPIO15</strong>：如果被拉高，则启动失败</li><li><strong>GPIO3</strong>：启动时为高电平</li><li><strong>GPIO1</strong>：启动时为高电平，如果被拉低，则启动失败</li><li><strong>GPIO10</strong>：启动时为高电平</li><li><strong>GPIO9</strong>：启动时为高电平</li></ul><h3 id="启动时为高电平的引脚"><a href="#启动时为高电平的引脚" class="headerlink" title="启动时为高电平的引脚"></a>启动时为高电平的引脚</h3><p>以下引脚在启动时会输出 3.3V 的高电平。如果你在这些引脚上接了继电器之类的外设，可能会带来一些问题：</p><ul><li>GPIO16</li><li>GPIO3</li><li>GPIO1</li><li>GPIO10</li><li>GPIO9</li></ul><p>此外，其他引脚（除了 GPIO5 和 GPIO4），在启动时会输出低电平信号，同样可能带来问题。你可以阅读 <a href="https://rabbithole.wwwdotorg.org/2017/03/28/esp8266-gpio.html">此文章</a> 以详细了解各个 GPIO 在启动时的状态。</p><blockquote><p>🟢如果需要控制继电器或功率管，GPIO4 和 GPIO5 是最安全的引脚。</p></blockquote><h3 id="模拟输入引脚"><a href="#模拟输入引脚" class="headerlink" title="模拟输入引脚"></a>模拟输入引脚</h3><p>ESP8266 只有一个引脚支持模拟输入，此引脚叫 ADC0，丝印上常标记为 A0。</p><p>如果使用 ESP8266 裸芯片（ESP-12E/F）的话，此引脚的电压输入范围为 0-1V。如果使用了 NodeMCU 之类的开发板，那么电压输入范围就是 0-3.3V，因为开发板上已经集成了分压器。</p><h3 id="板载-LED"><a href="#板载-LED" class="headerlink" title="板载 LED"></a>板载 LED</h3><p>大多数 ESP8266 模块均有一个内置的 LED，通常连在 GPIO2 上。LED 亮灭的逻辑是反向的，GPIO2 为高电平时，LED 熄灭；GPIO2 低电平时，LED 亮起。</p><p><img src="https://img.vvzero.com/blog/esp8266-pinout-reference-gpios/6.png"></p><h3 id="复位引脚"><a href="#复位引脚" class="headerlink" title="复位引脚"></a>复位引脚</h3><p>当 RST 引脚被拉低时，ESP8266 将被复位。按开发板上的 RESET 按键同理。</p><p><img src="https://img.vvzero.com/blog/esp8266-pinout-reference-gpios/7.png"></p><h3 id="GPIO0"><a href="#GPIO0" class="headerlink" title="GPIO0"></a>GPIO0</h3><p>当 GPIO0 被拉低时，复位 ESP8266，芯片将进入 bootloader 模式。按开发板上的 FLASH/BOOT 按钮同理。</p><p><img src="https://img.vvzero.com/blog/esp8266-pinout-reference-gpios/8.png"></p><h3 id="GPIO16"><a href="#GPIO16" class="headerlink" title="GPIO16"></a>GPIO16</h3><p>GPIO16 可被用于从深度睡眠中唤醒 ESP8266。要实现此功能，需要将 GPIO16 连接在 RST 引脚上。关于如何实现深度睡眠，请搜索并参考 Arduino 官网上的相关案例。</p><h3 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h3><p>ESP8266 没有硬件 I2C 引脚，但可以用软件模拟，所以你可以使用任意引脚实现 I2C。通常我们会使用以下引脚：</p><ul><li><strong>GPIO5</strong>：SCL</li><li><strong>GPIO4</strong>：SDA</li></ul><h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>ESP8266 上的 SPI 引脚如下：</p><ul><li><strong>GPIO12</strong>：MISO</li><li><strong>GPIO13</strong>：MOSI</li><li><strong>GPIO14</strong>：SCLK</li><li><strong>GPIO15</strong>：CS</li></ul><h3 id="PWM-引脚"><a href="#PWM-引脚" class="headerlink" title="PWM 引脚"></a>PWM 引脚</h3><p>我们可以在 ESP8266 的所有引脚（GPIO0 至 GPIO15）上软件实现 PWM 功能。ESP8266 上的 PWM 有 10 位精度。关于如何实现 PWM 功能，请搜索并参考 Arduino 官网上的相关案例。</p><h3 id="中断引脚"><a href="#中断引脚" class="headerlink" title="中断引脚"></a>中断引脚</h3><p>ESP8266 的所有 GPIO 引脚均支持中断，除了 GPIO16。相关案例请搜索并参考 Arduino 官网上的相关案例。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望本文能解决你对 ESP8266 GPIO 的相关疑惑，祝好！</p>]]></content>
        <author>
            <name><![CDATA[VVBLOG]]></name>
        </author>
    </entry>
    
    <entry>
        <id>http://blog.qrzbing.cn/post/2022-rustlings/</id>
        <title><![CDATA[Rustlings 实验]]></title>
        <updated>2022-05-01T07:33:22+08:00</updated>
        <link href="http://blog.qrzbing.cn/post/2022-rustlings/"/>
        <content type="text/html" src="http://blog.qrzbing.cn/post/2022-rustlings/"><![CDATA[<p><a href="https://github.com/rust-lang/rustlings">rustlings</a> : Rust 小练习</p>]]></content>
        <author>
            <name><![CDATA[QRZ’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://miaotony.xyz/2022/03/20/EE_LicheeRV_1_getting_started/</id>
        <title><![CDATA[EE | Sipeed 荔枝派 LicheeRV | 1 开箱及上手入门]]></title>
        <updated>2022-04-27T09:35:10+08:00</updated>
        <link href="https://miaotony.xyz/2022/03/20/EE_LicheeRV_1_getting_started/"/>
        <content type="text/html" src="https://miaotony.xyz/2022/03/20/EE_LicheeRV_1_getting_started/"><![CDATA[有新玩具了！最近整了个Sipeed 荔枝派 LicheeRV Dock 全志D1开发板，这篇博客就来记录一下开箱和上手的一些折腾过程。]]></content>
        <author>
            <name><![CDATA[MiaoTony]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://miaotony.xyz/2022/04/26/CTF_2022T-Star/</id>
        <title><![CDATA[CTF | 2022 未知之境 腾讯网络安全T-Star高校挑战赛 WriteUp]]></title>
        <updated>2022-04-27T09:29:49+08:00</updated>
        <link href="https://miaotony.xyz/2022/04/26/CTF_2022T-Star/"/>
        <content type="text/html" src="https://miaotony.xyz/2022/04/26/CTF_2022T-Star/"><![CDATA[前几天AK了个腾讯的T-Star高校挑战赛，题目比较偏向Misc和Web，这里记录一下解题过程。]]></content>
        <author>
            <name><![CDATA[MiaoTony]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.suruifu.com/posts/694</id>
        <title><![CDATA[过去的再也回不来]]></title>
        <updated>2022-04-23T14:03:00+08:00</updated>
        <link href="https://www.suruifu.com/posts/694"/>
        <content type="text/html" src="https://www.suruifu.com/posts/694"><![CDATA[<p>过去的，就过去了，再也回不来的。珍惜现在，珍爱生活。</p>]]></content>
        <author>
            <name><![CDATA[苏瑞辅的个人网站]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.vvzero.com/2022/04/08/diy-to-combine-sukangma-and-xingchengma/</id>
        <title><![CDATA[如何 DIY 一个苏康码与行程码“双码合一”的健康码 APP]]></title>
        <updated>2022-04-08T13:00:02+08:00</updated>
        <link href="https://blog.vvzero.com/2022/04/08/diy-to-combine-sukangma-and-xingchengma/"/>
        <content type="text/html" src="https://blog.vvzero.com/2022/04/08/diy-to-combine-sukangma-and-xingchengma/"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>众所周知的背景：</p><ol><li>苏康码打开很慢，在支付宝中如果没有快捷键，需要以下步骤：点击打开支付宝 -&gt; 点击健康码 -&gt; 点击立即查看，如果设置了长按图标打开健康码，也得至少两步；其他 APP 比如“苏周到”，可以实现长按快捷键后一步访问，但是其中存在三个步骤：APP 启动 -&gt; 健康码小程序启动 -&gt; 加载网页，这种不可理喻的框架，在某些低端机上冷启动，可能需要长达数十秒的时间；</li><li>行程卡打开也很慢，在微信小程序中打开，不知道为什么每次都让我确认一下“同意并授权运营商查询”，严重影响效率；</li><li>很多地方两个码都要查，于是慢*2，话说我也不知道为什么有关部门不把这两个码合二为一……</li></ol><p>所以干脆 DIY 一个。</p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>我想做出这样的效果：打开 APP 后，直接显示苏康码，滑动屏幕可切换到行程码，不需要任何多余的点击动作。</p><h3 id="技术栈选择"><a href="#技术栈选择" class="headerlink" title="技术栈选择"></a>技术栈选择</h3><p>我没有任何 APP 开发经验，所以相当于新手。因为最近用 C# 和 .NET 框架比较多，<a href="https://v2ex.com/t/844404">经 V2EX 网友提醒</a>，我选择了 Xamarin 框架。据说如果新手想快速尝试跨平台 APP 开发，用 flutter 比较好，但是……whatever，支持一下微软，及其宇宙第一 IDE。</p><h3 id="获取苏康码直链"><a href="#获取苏康码直链" class="headerlink" title="获取苏康码直链"></a>获取苏康码直链</h3><p>既然苏康码本质上是网页，而且我在朋友圈了解到，可以获取到直链而且是不需要认证的，只要 token 对就行了，那就简单了。</p><p>于是我决定使用 <a href="https://www.telerik.com/fiddler/fiddler-classic">Fiddler</a> 抓包，大致步骤就是：配好 Fiddler 的监听端口，然后保证电脑和手机在同一个局域网内，手机在 WiFi 设置里配置好 Fiddler 的代理。</p><p><img src="https://img.vvzero.com/blog/diy-to-combine-sukangma-and-xingchengma/1.png"></p><p>测试的 APP 是苏周到，不出所料，苏康码链接是 HTTPS 的，想解密只能在手机上安装一个证书然后中间人了。</p><p><img src="https://img.vvzero.com/blog/diy-to-combine-sukangma-and-xingchengma/2.png"></p><p>导出 Fiddler 的证书并复制到手机上，MIUI 安装证书的步骤也很简单，记得在抓完包之后删除这个证书就好。</p><p><img src="https://img.vvzero.com/blog/diy-to-combine-sukangma-and-xingchengma/3.png"></p><p>然后就可以解密 HTTPS 流量。理论上，对于现在的 Android 版本，APP 可以选择不信任用户安装的证书，但还好，苏康码并没有采取这样的机制。</p><p>解析出来的苏康码的直链很简单，就是 <a href="https://jsstm.jszwfw.gov.cn/jkmIndex.html?token=xxxxxxxxxxxxxxxx&amp;uuid=xxxxxxxxxxxxxxx">https://jsstm.jszwfw.gov.cn/jkmIndex.html?token=xxxxxxxxxxxxxxxx&amp;uuid=xxxxxxxxxxxxxxx</a> 这样的格式，直接访问就可以看到自己的苏康码界面。</p><h3 id="获取行程码直链"><a href="#获取行程码直链" class="headerlink" title="获取行程码直链"></a>获取行程码直链</h3><p>行程码直链更简单，直接就可以搜到： <a href="https://xc.caict.ac.cn/">https://xc.caict.ac.cn/</a> 。有趣的是，行程码居然是用 Vue 框架做的，如果只是普通的 HTML 表单页面的话，我也许会做一个自动发验证码查询的功能。</p><h3 id="APP-开发"><a href="#APP-开发" class="headerlink" title="APP 开发"></a>APP 开发</h3><p>安装移动端开发相关 SDK 后，启动宇宙最强 IDE，新建一个空项目叫 <code>ShuangShuangMa</code> （随便起一个名字，双双码），然后面向 Google 编程……基本上只要查一下怎么使用 WebView 以及如何实现滑动切换页面就好了。</p><p>代码非常简单，xaml 页面如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">CarouselPage</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xamarin.com/schemas/2014/forms&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:x</span>=<span class="string">&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">x:Class</span>=<span class="string">&quot;ShuangShuangMa.MainPage&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ContentPage</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">StackLayout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">WebView</span> <span class="attr">x:Name</span>=<span class="string">&quot;WebView_SuKangMa&quot;</span> <span class="attr">VerticalOptions</span>=<span class="string">&quot;FillAndExpand&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Text</span>=<span class="string">&quot;点击刷新&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;50,10&quot;</span> <span class="attr">Clicked</span>=<span class="string">&quot;Button_RefreshSuKangMa_Clicked&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">StackLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ContentPage</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ContentPage</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">StackLayout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">WebView</span> <span class="attr">x:Name</span>=<span class="string">&quot;WebView_XingChengMa&quot;</span> <span class="attr">VerticalOptions</span>=<span class="string">&quot;FillAndExpand&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">StackLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ContentPage</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">CarouselPage</span>&gt;</span></span><br></pre></td></tr></table></figure><p>C# 逻辑如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Xamarin.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ShuangShuangMa</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainPage</span> : <span class="title">CarouselPage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainPage</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            WebView_SuKangMa.Source = <span class="string">&quot;https://jsstm.jszwfw.gov.cn/jkmIndex.html?token=xxxxxx&amp;uuid=xxxxxx&quot;</span>;</span><br><span class="line">            WebView_XingChengMa.Source = <span class="string">&quot;https://xc.caict.ac.cn/&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button_RefreshSuKangMa_Clicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            WebView_SuKangMa.Reload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>部分解释：</p><ol><li>添加刷新按钮是因为，WebView 在后台不会运行，而苏康码上的时间又是在前端运算的，所以防止再次打开应用后，苏康码的时间不对；</li><li>行程码网页在重新加载后就必须重新认证手机号，而 Android 应用在触发返回按钮后，会关闭所有的 WebView，所以需要在 <code>MainActivity.cs</code> 中添加以下代码以便把返回按钮当 Home 键用：</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnBackPressed</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MoveTaskToBack(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，应用安装后得关闭电池优化、锁在后台，毕竟被清理掉之后又得重新认证行程码。</p><p>至此，APP 完成。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>效果见下面的视频：</p><video src='https://img.vvzero.com/blog/diy-to-combine-sukangma-and-xingchengma/4.mp4 ' type='video/mp4' controls='controls' width='320px'></video><p>话说，本来想着 Xamarin 是跨平台的，准备给玲玲的 iPhone 也整一个的，但无奈意识到自己没有 Mac，作罢。</p>]]></content>
        <author>
            <name><![CDATA[VVBLOG]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.triplez.cn/posts/mastering-git-cherry-pick/</id>
        <title><![CDATA[Mastering Git Cherry-pick]]></title>
        <updated>2022-04-07T16:33:11+08:00</updated>
        <link href="https://blog.triplez.cn/posts/mastering-git-cherry-pick/"/>
        <content type="text/html" src="https://blog.triplez.cn/posts/mastering-git-cherry-pick/"><![CDATA[<p>本文希望教你如何成为一个 <code>git cherry-pick</code> 的 “master”！通过使用 <code>git cherry-pick</code> 来轻松地维护多个分支版本，再也不会让 multi-version maintaining  成为你心头上的那把令你屡次痛心的剑了！</p>
<p>本文所有内容都会基于以下（精心构造的）示例，该例子涵盖了大部分工程上容易出现的 Git log pattern（如有其他 corner-case ，欢迎<a href="mailto:me@triplez.cn">联系我</a>，一起努力让该文变得对大家更有帮助）。</p>
<p>贯穿本文的示例场景，这是该示例基于时间序的 Git 提交历史。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git --no-pager log --oneline --graph --date-order
</span></span><span class="line"><span class="cl">* f2c1619 <span class="o">(</span>HEAD -&gt; red<span class="o">)</span> R6
</span></span><span class="line"><span class="cl">*   e6899ea R5 merge branch <span class="s1">&#39;blue&#39;</span> into <span class="s1">&#39;red&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span><span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>* <span class="se">\ </span>  0979d45 R4 merge branch <span class="s1">&#39;green&#39;</span> into <span class="s1">&#39;red&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span><span class="se">\ \
</span></span></span><span class="line"><span class="cl"><span class="se"></span><span class="p">|</span> <span class="p">|</span> * 186da41 <span class="o">(</span>blue<span class="o">)</span> B3
</span></span><span class="line"><span class="cl"><span class="p">|</span> * <span class="p">|</span> c950910 <span class="o">(</span>green<span class="o">)</span> G3
</span></span><span class="line"><span class="cl">* <span class="p">|</span> <span class="p">|</span> 17e2629 R3
</span></span><span class="line"><span class="cl"><span class="p">|</span> <span class="p">|</span> * 69edfc9 B2
</span></span><span class="line"><span class="cl"><span class="p">|</span> * <span class="p">|</span> 059425a G2
</span></span><span class="line"><span class="cl"><span class="p">|</span> * <span class="p">|</span> 05719c8 G1
</span></span><span class="line"><span class="cl"><span class="p">|</span> <span class="p">|</span> * ebb218d B1
</span></span><span class="line"><span class="cl"><span class="p">|</span> <span class="p">|</span>/
</span></span><span class="line"><span class="cl">* / 8c6595b R2
</span></span><span class="line"><span class="cl"><span class="p">|</span>/
</span></span><span class="line"><span class="cl">* 6581ff8 R1
</span></span><span class="line"><span class="cl">* 2787f8f <span class="o">(</span>master<span class="o">)</span> init commit
</span></span></code></pre></div><details>
<summary><mark>快速创建该示例。</mark></summary>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mkdir cherry-pick<span class="p">;</span> <span class="nb">cd</span> cherry-pick/
</span></span><span class="line"><span class="cl">git init
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;init&#34;</span> &gt;&gt; init<span class="p">;</span> git add -A<span class="p">;</span> git commit -m <span class="s2">&#34;init commit&#34;</span><span class="p">;</span> sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl">git checkout -b red
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;red&#34;</span> &gt;&gt; red<span class="p">;</span> git add -A<span class="p">;</span> git commit -m <span class="s2">&#34;R1&#34;</span><span class="p">;</span> sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl">git branch green
</span></span><span class="line"><span class="cl">git branch blue
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;red&#34;</span> &gt;&gt; red<span class="p">;</span> git add -A<span class="p">;</span> git commit -m <span class="s2">&#34;R2&#34;</span><span class="p">;</span> sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl">git checkout blue
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;blue&#34;</span> &gt;&gt; blue<span class="p">;</span> git add -A<span class="p">;</span> git commit -m <span class="s2">&#34;B1&#34;</span><span class="p">;</span> sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl">git checkout green
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;green&#34;</span> &gt;&gt; green<span class="p">;</span> git add -A<span class="p">;</span> git commit -m <span class="s2">&#34;G1&#34;</span><span class="p">;</span> sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;green&#34;</span> &gt;&gt; green<span class="p">;</span> git add -A<span class="p">;</span> git commit -m <span class="s2">&#34;G2&#34;</span><span class="p">;</span> sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl">git checkout blue
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;blue&#34;</span> &gt;&gt; blue<span class="p">;</span> git add -A<span class="p">;</span> git commit -m <span class="s2">&#34;B2&#34;</span><span class="p">;</span> sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl">git checkout red
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;red&#34;</span> &gt;&gt; red<span class="p">;</span> git add -A<span class="p">;</span> git commit -m <span class="s2">&#34;R3&#34;</span><span class="p">;</span> sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl">git checkout green
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;green&#34;</span> &gt;&gt; green<span class="p">;</span> git add -A<span class="p">;</span> git commit -m <span class="s2">&#34;G3&#34;</span><span class="p">;</span> sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl">git checkout blue
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;blue&#34;</span> &gt;&gt; blue<span class="p">;</span> git add -A<span class="p">;</span> git commit -m <span class="s2">&#34;B3&#34;</span><span class="p">;</span> sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl">git checkout red
</span></span><span class="line"><span class="cl">git merge green -m <span class="s2">&#34;R4 merge branch &#39;green&#39; into &#39;red&#39;&#34;</span><span class="p">;</span> sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl">git merge blue -m <span class="s2">&#34;R5 merge branch &#39;blue&#39; into &#39;red&#39;&#34;</span><span class="p">;</span> sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;red&#34;</span> &gt;&gt; red<span class="p">;</span> git add -A<span class="p">;</span> git commit -m <span class="s2">&#34;R6&#34;</span><span class="p">;</span> sleep <span class="m">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">git --no-pager log --oneline --graph --date-order
</span></span></code></pre></div></details>
<br/>
<p>当前 Git 提交历史示意图如下。</p>
<figure class="align-center ">
    <img loading="lazy" src="https://blog.triplez.cn/img/mastering-git-cherry-pick/git-cherry-pick-overall.jpg#center"
         alt="提交记录示意图"/> <figcaption>
            提交记录示意图
        </figcaption>
</figure>

<p>Git cherry-pick 的命令的基本原理是根据用户所选择的提交，根据提交中的差异信息（diff）将这些提交移植至用户目标版本中。如将 hotfix 应用至其他 LTS 版本中是该功能的一个典型应用。</p>
<p><code>git cherry-pick</code> 的大致用法为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git cherry-pick <span class="o">[</span>options<span class="o">]</span> &lt;commit&gt;...
</span></span></code></pre></div><p>此处的 <code>&lt;commit&gt;...</code> 即为用户希望移植的提交（集合），这是本文讨论的要点。</p>
<p><code>&lt;commit&gt;</code> 可以为单一提交（commit），也可以为一个版本区间（revision range）。若为 revision range，则该命令会将该 revision range 中的所有 commit 都解析出来，最终成为一连串的单一 commit <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。<code>cherry-pick</code> 可以同时接受多个 <code>&lt;commit&gt;</code> ，此时表现类似于 <code>git rev-list</code> 中的 <code>--no-walk</code> 行为<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。</p>
<p>那我们依次来讨论 <code>&lt;commit&gt;...</code> 为单一 commit 以及 revision range 的情况。</p>
<h2 id="single-commit">Single commit</h2>
<h3 id="normal-commit">Normal commit</h3>
<p>回到上文的例子，如果仅需要将 <code>G2</code> 选取出来，我们可以这样操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 回到 master 新建一条分支用于测试</span>
</span></span><span class="line"><span class="cl">$ git checkout master
</span></span><span class="line"><span class="cl">$ git checkout -b cp-single-normal-commit
</span></span><span class="line"><span class="cl"><span class="c1"># G2 的提交 SHA 值为 059425a</span>
</span></span><span class="line"><span class="cl">$ git cherry-pick 059425a
</span></span></code></pre></div><p>此时会出现合并冲突（merge conflict），输出如下所示。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">CONFLICT (modify/delete): green deleted in HEAD and modified in 059425a (G2). Version 059425a (G2) of green left in tree.
</span></span><span class="line"><span class="cl">error: could not apply 059425a... G2
</span></span><span class="line"><span class="cl">hint: after resolving the conflicts, mark the corrected paths
</span></span><span class="line"><span class="cl">hint: with &#39;git add &lt;paths&gt;&#39; or &#39;git rm &lt;paths&gt;&#39;
</span></span><span class="line"><span class="cl">hint: and commit the result with &#39;git commit&#39;
</span></span></code></pre></div><p>这段内容告知我们这些信息：<code>green</code> 文件在当前（暂存）版本 <code>HEAD</code> 中并不存在，但在选取的 <code>G2</code> 提交中存在。如果需要该文件，则使用 <code>git add</code> 将其提交至暂存区，若希望保留当前暂存版本的状态，即删除该文件，则使用 <code>git rm</code> 将 <code>green</code> 文件舍弃。</p>
<p>我们希望在选取 G2 之后能够保留 <code>green</code> 文件，故采取如下操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 将 green 提交至暂存区</span>
</span></span><span class="line"><span class="cl">$ git add green
</span></span><span class="line"><span class="cl"><span class="c1"># 已修复所有合并冲突，继续进行 cherry-pick</span>
</span></span><span class="line"><span class="cl">$ git cherry-pick --continue
</span></span></code></pre></div><p>此时 cherry-pick 操作已经完成，如果继续执行 <code>git cherry-pick --continue</code> ，则此时会显示 <code>error: no cherry-pick or revert in progress</code> ，即当前没有进行任何 cherry-pick 任务。</p>
<p>查看一下当前的提交记录，则会发现 <code>G2</code> 已经在我们当前的分支 <code>cp-single-normal-commit</code> 上了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git --no-pager log --oneline --graph --date-order
</span></span><span class="line"><span class="cl">* <span class="m">0457362</span> <span class="o">(</span>HEAD -&gt; cp-single-normal-commit<span class="o">)</span> G2
</span></span><span class="line"><span class="cl">* 2787f8f <span class="o">(</span>master<span class="o">)</span> init commit
</span></span></code></pre></div><h3 id="merge-commit">Merge commit</h3>
<p>那如果我们想选取一个 merge commit 呢，比如将 <code>R4</code> 选取出来。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 回到 master 新建一条分支用于测试</span>
</span></span><span class="line"><span class="cl">$ git checkout master
</span></span><span class="line"><span class="cl">$ git checkout -b cp-single-merge-commit
</span></span><span class="line"><span class="cl"><span class="c1"># R4 的提交 SHA 值为 0979d45</span>
</span></span><span class="line"><span class="cl">$ git cherry-pick 0979d45
</span></span></code></pre></div><p>当执行完这条 <code>cherry-pick</code> 命令之后，你会得到以下输出。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">error: commit 0979d45f1b46f72730188c5c01b3f2c7f41b18e6 is a merge but no -m option was given.
</span></span><span class="line"><span class="cl">fatal: cherry-pick failed
</span></span></code></pre></div><p>默认情况下，<code>cherry-pick</code> 不处理 merge commit 并直接报错。因为在 merge commit 中，会有多个 parent 信息，但此时 Git 并不知道该使用哪个 parent 作为 mainline。在错误信息中，也同时提示了我们，如果要选取 merge commit ，则需要使用 <code>-m</code> （亦为 <code>--mainline</code>）选项来指定哪个 parent 是主线<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>。</p>
<p>通过 <code>git show</code> 命令可以获得 merge commit 的多个 parent，且从 1 开始编号。由于该例中我们需要选取的 mainline parent 是 <code>R3(17e2629)</code> ，因此在 <code>cherry-pick</code> 中选择的是 <code>-m 1</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git --no-pager show 0979d45
</span></span><span class="line"><span class="cl">commit 0979d45f1b46f72730188c5c01b3f2c7f41b18e6
</span></span><span class="line"><span class="cl">Merge: 17e2629 c950910
</span></span><span class="line"><span class="cl">Author: Triple-Z &lt;me@triplez.cn&gt;
</span></span><span class="line"><span class="cl">Date:   Thu Mar <span class="m">31</span> 01:29:31 <span class="m">2022</span> +0800
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    R4 merge branch <span class="s1">&#39;green&#39;</span> into <span class="s1">&#39;red&#39;</span>
</span></span></code></pre></div><p>让我们再来试一次。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git cherry-pick -m <span class="m">1</span> 0979d45
</span></span></code></pre></div><p><code>cherry-pick</code> 圆满完成！此时再看一下当前的提交记录，则发现在 <code>cp-single-merge-commit</code> 分支上产生了一个新的 <code>R4</code> 提交。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git --no-pager log --oneline --graph --date-order
</span></span><span class="line"><span class="cl">* 987aba7 <span class="o">(</span>HEAD -&gt; cp-single-merge-commit<span class="o">)</span> R4 merge branch <span class="s1">&#39;green&#39;</span> into <span class="s1">&#39;red&#39;</span>
</span></span><span class="line"><span class="cl">* 2787f8f <span class="o">(</span>master<span class="o">)</span> init commit
</span></span></code></pre></div><p>现在我们再来讲讲刚刚的 <code>-m 1</code> 发生了什么。如果现在去看 <code>cp-single-merge-commit</code> 这个测试分支上的文件，则会发现有 <code>green</code> ，而没有 <code>red</code> 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ ls -lh
</span></span><span class="line"><span class="cl">total <span class="m">16</span>
</span></span><span class="line"><span class="cl">-rw-r--r--  <span class="m">1</span> triplez  staff    18B  <span class="m">4</span>  <span class="m">7</span> 19:06 green
</span></span><span class="line"><span class="cl">-rw-r--r--  <span class="m">1</span> triplez  staff     5B  <span class="m">3</span> <span class="m">31</span> 01:29 init
</span></span></code></pre></div><p>这是因为我们在选取 merge commit 时，使用的是 mainline 1 ，即 <code>red</code> 分支。因此 <code>cherry-pick</code> 事实是以 <code>red</code> 为基础，寻找 mainline 2 <code>green</code> 分支与 <code>red</code> 的差异，选取的就是 <code>green</code> 分支上所做的修改了。</p>
<h2 id="revision-range">Revision range</h2>
<p>Git 中可用多种方法来表示 revision （版本，或修订快照）<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>，这里我们主要讨论 revision range（版本区间）<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>。</p>
<p>对于 revision range，有以下六种表示法：</p>
<ol>
<li>
<p><code>^&lt;rev&gt;</code> ：（脱字符-表示法）表示<strong>排除</strong> <code>&lt;rev&gt;</code> 以及它<u>所有可到达</u>的父辈 commit。</p>
</li>
<li>
<p><code>&lt;r1&gt;..&lt;r2&gt;</code>（两点-范围表示法）：等同于 <code>^r1 r2</code> ，即 <strong>包含</strong> <code>&lt;r2&gt;</code> 以及其可到达的父辈 commit ，并<strong>排除</strong> <code>&lt;r1&gt;</code> 以及其可到达的父辈 commit。</p>
<blockquote>
<p>如果需要包括 <code>&lt;r1&gt;</code>，可使用这种写法：<code>&lt;r1&gt;^..&lt;r2&gt;</code> 。</p>
</blockquote>
</li>
<li>
<p><code>&lt;r1&gt;...&lt;r2&gt;</code> （三点-对称差分表示法）：<strong>包含</strong>所有 <code>&lt;r1&gt;</code> <u>或</u> <code>&lt;r2&gt;</code> 及其可到达的父辈 commit，并<strong>排除</strong> <code>&lt;r1&gt;</code> <u>和</u> <code>&lt;r2&gt;</code> 两者可到达的<u>共同</u>父辈 commit。</p>
</li>
<li>
<p><code>&lt;rev&gt;^@</code> ：<strong>包含</strong> <code>&lt;rev&gt;</code> 的所有父辈，但<strong>排除</strong> <code>&lt;rev&gt;</code> 本身。</p>
</li>
<li>
<p><code>&lt;rev&gt;^!</code> ：<strong>包含</strong> <code>&lt;rev&gt;</code> 本身，但<strong>排除</strong> <code>&lt;rev&gt;</code> 所有父辈。即表示单个 <code>&lt;rev&gt;</code> commit。</p>
<blockquote>
<p>注意： <code>&lt;rev&gt;</code> （表示 <code>&lt;rev&gt;</code> 及其所有父辈）在 revision range 的语境中不同于 <code>&lt;rev&gt;^!</code> 。仅有指定 <code>--no-walk</code> 参数时，两者才可以认为是相同的（都仅表示 <code>&lt;rev&gt;</code> 本身）。</p>
</blockquote>
</li>
<li>
<p><code>&lt;rev&gt;^-[&lt;n&gt;]</code> ：<strong>包含</strong> <code>&lt;rev&gt;</code> 及其所有父辈，但<strong>排除</strong> <code>&lt;rev&gt;</code> 的第 <code>&lt;n&gt;</code> 个 parent 及其可到达的所有父辈。 <code>&lt;n&gt;</code> 的缺省值为 1。</p>
</li>
</ol>
<p>看起来很复杂，我们来用文中的场景来举两个范围表示法的例子。</p>
<p>首先，考虑 <code>&lt;r1&gt;</code> 和 <code>&lt;r2&gt;</code> 都在同一分支上的情况，如 <code>G1 (05719c8)</code> 和 <code>G3 (c950910)</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 回到 master 新建一条分支用于测试</span>
</span></span><span class="line"><span class="cl">$ git checkout master
</span></span><span class="line"><span class="cl">$ git checkout -b cp-range-same-branch
</span></span><span class="line"><span class="cl"><span class="c1"># G1 的提交 SHA 值为 05719c8，G3 的 SHA 值为 c950910</span>
</span></span><span class="line"><span class="cl">$ git cherry-pick 05719c8^..c950910
</span></span></code></pre></div><p><code>05719c8(G1)^..c950910(G3)</code> 的含义应当是：</p>
<ul>
<li><strong>包含</strong> <code>G3</code> 及其所有父辈。</li>
<li>并<strong>排除</strong> <code>G1</code> 的所有父辈（不排除 <code>G1</code>）。</li>
</ul>
<p>因此结果应当是选出从 <code>G1</code> 到 <code>G3</code> 的所有提交，示意图如下，黄色为被包含的节点，灰色则代表被排除的节点。</p>
<figure class="align-center ">
    <img loading="lazy" src="https://blog.triplez.cn/img/mastering-git-cherry-pick/git-cherry-pick-g1-g3.jpg#center"
         alt="git cheery-pick G1^..G3"/> <figcaption>
            git cheery-pick G1^..G3
        </figcaption>
</figure>

<p>让我们再看看当前的提交记录。Bingo！ <code>G1</code> ，<code>G2</code> ，<code>G3</code> 这三个提交已经被选取出来了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git --no-pager log --oneline --graph --date-order
</span></span><span class="line"><span class="cl">* 32eac39 <span class="o">(</span>HEAD -&gt; cp-range-same-branch<span class="o">)</span> G3
</span></span><span class="line"><span class="cl">* d3b1130 G2
</span></span><span class="line"><span class="cl">* c82c4c7 G1
</span></span><span class="line"><span class="cl">* 2787f8f <span class="o">(</span>master<span class="o">)</span> init commit
</span></span></code></pre></div><p>那 <code>&lt;r1&gt;</code> 和 <code>&lt;r2&gt;</code> 在不同分支上，是什么情况呢？</p>
<p>我们以 <code>G1 (05719c8)</code> 和 <code>B2 (69edfc9)</code> 作为用例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 回到 master 新建一条分支用于测试</span>
</span></span><span class="line"><span class="cl">$ git checkout master
</span></span><span class="line"><span class="cl">$ git checkout -b cp-range-diff-branch
</span></span><span class="line"><span class="cl"><span class="c1"># G1 的提交 SHA 值为 05719c8，B2 的 SHA 值为 69edfc9</span>
</span></span><span class="line"><span class="cl">$ git cherry-pick 05719c8^..69edfc9
</span></span></code></pre></div><p><code>05719c8(G1)^..69edfc9(B2)</code> 的含义应当是：</p>
<ul>
<li><strong>包含</strong> <code>B2</code> 及其所有父辈。</li>
<li>并<strong>排除</strong> <code>G1</code> 的所有父辈（不排除 <code>G1</code>）。</li>
</ul>
<p>由于 <code>B2</code> 及其所有父辈中，并不包括 <code>G1</code>。因此我们可以将 <code>G1^..B2</code> 理解为包含 <code>B2</code> 及其所有父辈，且排除 <code>B2</code> 和 <code>G1</code> 的共同父辈后的结果。自然就只剩下 <code>B1</code> 和 <code>B2</code> 两个 commit 了。示意图如下，黄色为被包含的节点，灰色则代表被排除的节点。</p>
<figure class="align-center ">
    <img loading="lazy" src="https://blog.triplez.cn/img/mastering-git-cherry-pick/git-cherry-pick-g1-b2.jpg#center"
         alt="git cherry-pick G1^..B2"/> <figcaption>
            git cherry-pick G1^..B2
        </figcaption>
</figure>

<p>让我们再看看当前的提交记录，确实是只选择了 <code>B1</code> 和 <code>B2</code> 两个提交。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git --no-pager log --oneline --graph --date-order
</span></span><span class="line"><span class="cl">* e63f214 <span class="o">(</span>HEAD -&gt; cp-range-diff-branch<span class="o">)</span> B2
</span></span><span class="line"><span class="cl">* aed6717 B1
</span></span><span class="line"><span class="cl">* 2787f8f <span class="o">(</span>master<span class="o">)</span> init commit
</span></span></code></pre></div><h2 id="rerere">Rerere</h2>
<p>Rerere 是“重用已记录的冲突解决方案（reuse recorded resolution）”，它是一种简化冲突解决的方法<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup> <sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup>。</p>
<p>如果你经常进行大量的 merge, rebase 或 cherry-pick，或在维护一个长期不同于主干的分支<sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup>，那么非常建议开启 <code>rerere</code> 功能。</p>
<p>开启 <code>rerere</code> 非常简单，仅需要进行一次全局配置即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git config --global rerere.enabled <span class="nb">true</span>
</span></span></code></pre></div><blockquote>
<p>在本地仓库中直接创建 <code>.git/rr-cache</code> 文件夹，也可以为该仓库开启 <code>rerere</code>。</p>
</blockquote>
<h2 id="whats-next">What&rsquo;s next</h2>
<p>在笔者撰写该文的过程中，也看到了 Microsoft 的 Raymond Chen 写的 <a href="https://devblogs.microsoft.com/oldnewthing/20180323-01/?p=98325">Stop cherry-picking, start merging 系列文章</a>，他在其中提及了许多工程实践中 cherry-pick 可能导致的 pitfall。接下来的时间里，笔者将会逐一阅读该系列文章，并根据文中案例去分析 cherry-pick 是否能够在常用软件开发工作流给我们带来足够的收益，以及，是否应该 stop cherry-picking, start merging。</p>
<p>只有在深入了解工具后，我们才能更好地运用工具，真正实现效率提升。</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>git-cherry-pick &lt;commit&gt;&hellip; <br/><a href="https://git-scm.com/docs/git-cherry-pick#Documentation/git-cherry-pick.txt-ltcommitgt82308203">https://git-scm.com/docs/git-cherry-pick#Documentation/git-cherry-pick.txt-ltcommitgt82308203</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>git-rev-list &ndash;no-walk<br/><a href="https://git-scm.com/docs/git-rev-list#Documentation/git-rev-list.txt---no-walksortedunsorted">https://git-scm.com/docs/git-rev-list#Documentation/git-rev-list.txt---no-walksortedunsorted</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>git-cherry-pick -m, &ndash;mainline<br/><a href="https://git-scm.com/docs/git-cherry-pick#Documentation/git-cherry-pick.txt--mltparent-numbergt">https://git-scm.com/docs/git-cherry-pick#Documentation/git-cherry-pick.txt--mltparent-numbergt</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>gitrevisions: Specifying Revisions<br/><a href="https://git-scm.com/docs/gitrevisions/#_specifying_revisions">https://git-scm.com/docs/gitrevisions/#_specifying_revisions</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p>gitrevisions: Specifying Ranges<br/><a href="https://git-scm.com/docs/gitrevisions/#_specifying_ranges">https://git-scm.com/docs/gitrevisions/#_specifying_ranges</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p>Pro Git (zh): Git 工具 - Rerere<br/><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-Rerere#ef_rerere">https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-Rerere#ef_rerere</a>&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7">
<p>Pro Git (en): Git Tools - Rerere<br/><a href="https://git-scm.com/book/en/v2/Git-Tools-Rerere">https://git-scm.com/book/en/v2/Git-Tools-Rerere</a>&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8">
<p>Pro Git (zh): 分布式 Git - 维护项目 - Rerere<br/><a href="https://git-scm.com/book/zh/v2/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E7%BB%B4%E6%8A%A4%E9%A1%B9%E7%9B%AE#_rerere">https://git-scm.com/book/zh/v2/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E7%BB%B4%E6%8A%A4%E9%A1%B9%E7%9B%AE#_rerere</a>&#160;<a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>]]></content>
        <author>
            <name><![CDATA[TripleZ’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.suruifu.com/posts/690</id>
        <title><![CDATA[我很高兴能够经历现在的困难]]></title>
        <updated>2022-04-07T15:13:28+08:00</updated>
        <link href="https://www.suruifu.com/posts/690"/>
        <content type="text/html" src="https://www.suruifu.com/posts/690"><![CDATA[<p>我现在的生活并不轻松，我在经历一些困难。</p>
<p>我很高兴，我面对困难的时候并不是无能为力，而能冷静应对；我很高兴，我能够沉下心来，把握整体工作方向。</p>
<p>我要逐步提升自己解决问题的水平、资源调度的水平；我希望我能逐步迎接更大的困难、更艰难的处境、更棘手的情况。</p>
<p>我希望可以永远处于困难之中！</p>]]></content>
        <author>
            <name><![CDATA[苏瑞辅的个人网站]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.triplez.cn/posts/systemd-binary-service-dynamic-linking/</id>
        <title><![CDATA[通过 systemd 服务配置链接动态库]]></title>
        <updated>2022-03-31T12:31:19+08:00</updated>
        <link href="https://blog.triplez.cn/posts/systemd-binary-service-dynamic-linking/"/>
        <content type="text/html" src="https://blog.triplez.cn/posts/systemd-binary-service-dynamic-linking/"><![CDATA[<h2 id="序">序</h2>
<p>在设置动态链接的方法中，<code>rpath</code> 有其自身的问题<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> ， <code>ld.so.conf</code> 为 OS 全局配置，可能会因为单一服务的动态库版本而影响到其他服务，不是一个优雅的方法。</p>
<p>那如何才能不借助 <code>rpath</code> 和 <code>ld.so.conf</code> ，即能使目标服务找到对应的动态链接库，又能不影响其他服务呢？</p>
<h2 id="ld_library_path">LD_LIBRARY_PATH</h2>
<p>对于动态链接库的路径配置而言，除了 <code>rpath</code> 和 <code>ld.so.conf</code> ，还有 <code>LD_LIBRARY_PATH</code>。只要在二进制启动的环境中设置 ``LD_LIBRARY_PATH<code>变量，则</code>glibc` 会将该变量中的路径配置作为动态链接库的查找路径之一，使得二进制可执行文件能够正常链接到其依赖的动态链接库。</p>
<p><code>LD_LIBRARY_PATH</code> 会在当前 shell session 中“全局”生效，不过，由于笔者服务采用 systemd 来管理其生命周期，按照上述思路，应该只需要在服务启动前，将 <code>LD_LIBRARY_PATH</code> 注入启动环境即可，这样还能够借助 systemd 来实现一定程度的环境“隔离”。systemd 服务配置中的 <code>Environment</code> 字段是用于描述启动环境的环境变量的，我们先在这里加入 <code>LD_LIBRARY_PATH</code> （如下），重新加载 systemd 配置并重启服务，观察效果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl"> [Unit]
</span></span><span class="line"><span class="cl"> Description=Nginx
</span></span><span class="line"><span class="cl"> After=syslog.target network.target remote-fs.target nss-lookup.target
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> [Service]
</span></span><span class="line"><span class="cl"> User=triplez
</span></span><span class="line"><span class="cl"> Group=triplez
</span></span><span class="line"><span class="cl"> Type=forking
</span></span><span class="line"><span class="cl"><span class="gi">+Environment=&#34;LD_LIBRARY_PATH=/your/path/to/openssl/lib:/your/path/to/jemalloc/lib:/your/path/to/luajit/lib&#34;
</span></span></span><span class="line"><span class="cl"><span class="gi"></span> PIDFile=/run/nginx/nginx.pid
</span></span><span class="line"><span class="cl"> RuntimeDirectory=nginx
</span></span><span class="line"><span class="cl"> RuntimeDirectoryMode=0755
</span></span><span class="line"><span class="cl"> ExecStartPre=/your/path/to/nginx -t
</span></span><span class="line"><span class="cl"> ExecStart=/your/path/to/nginx
</span></span><span class="line"><span class="cl"> ExecReload=/bin/kill -s HUP $MAINPID
</span></span><span class="line"><span class="cl"> ExecStop=/bin/kill -s QUIT $MAINPID
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> PrivateTmp=true
</span></span><span class="line"><span class="cl"> Restart=always
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> [Install]
</span></span><span class="line"><span class="cl"> WantedBy=multi-user.target
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ sudo systemctl daemon-reload
</span></span><span class="line"><span class="cl">$ sudo systemctl restart nginx.service
</span></span></code></pre></div><p>事实上，对于大多数服务，只需要加入环境变量即可解决问题。但很不幸的是，由于我们的服务需要监听 1024 及以下端口（如 80、443），笔者对二进制可执行文件进行了 <code>setcap</code> 操作，赋予其监听低位端口的能力。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ sudo getcap /your/path/to/nginx
</span></span><span class="line"><span class="cl">/your/path/to/nginx <span class="o">=</span> cap_net_bind_service+ep
</span></span></code></pre></div><h2 id="capability">Capability</h2>
<p>由于该文件含有 capability，<code>glibc</code> 会将 <code>LD_LIBRARY_PATH</code> 忽略<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>，导致服务还是无法正确链接到动态库上。</p>
<p>了解原因之后，接下来要做的事情也很清晰了：一是先将二进制可执行文件上的 capability 移除（<code>chown</code> 就可以将其移除， <code>setcap -ep</code> 亦可），二是利用 systemd 的服务配置来实现配置 capability （如下）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl"> [Unit]
</span></span><span class="line"><span class="cl"> Description=Nginx
</span></span><span class="line"><span class="cl"> After=syslog.target network.target remote-fs.target nss-lookup.target
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> [Service]
</span></span><span class="line"><span class="cl"> User=triplez
</span></span><span class="line"><span class="cl"> Group=triplez
</span></span><span class="line"><span class="cl"> Type=forking
</span></span><span class="line"><span class="cl"> Environment=&#34;LD_LIBRARY_PATH=/your/path/to/openssl/lib:/your/path/to/jemalloc/lib:/your/path/to/luajit/lib&#34;
</span></span><span class="line"><span class="cl"> PIDFile=/run/nginx/nginx.pid
</span></span><span class="line"><span class="cl"> RuntimeDirectory=nginx
</span></span><span class="line"><span class="cl"> RuntimeDirectoryMode=0755
</span></span><span class="line"><span class="cl"> ExecStartPre=/your/path/to/nginx -t
</span></span><span class="line"><span class="cl"> ExecStart=/your/path/to/nginx
</span></span><span class="line"><span class="cl"> ExecReload=/bin/kill -s HUP $MAINPID
</span></span><span class="line"><span class="cl"> ExecStop=/bin/kill -s QUIT $MAINPID
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gi">+CapabilityBoundingSet=CAP_NET_BIND_SERVICE
</span></span></span><span class="line"><span class="cl"><span class="gi">+AmbientCapabilities=CAP_NET_BIND_SERVICE
</span></span></span><span class="line"><span class="cl"><span class="gi"></span> PrivateTmp=true
</span></span><span class="line"><span class="cl"> Restart=always
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> [Install]
</span></span><span class="line"><span class="cl"> WantedBy=multi-user.target
</span></span></code></pre></div><p>再次重新加载 systemd 配置并重启服务，问题完美解决。</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>RpathIssue<br/><a href="https://wiki.debian.org/RpathIssue">https://wiki.debian.org/RpathIssue</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Use of file capabilities disables LD_LIBRARY_PATH - Red Hat Bugzilla<br/><a href="https://bugzilla.redhat.com/show_bug.cgi?id=448594">https://bugzilla.redhat.com/show_bug.cgi?id=448594</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>shared libraries - Linux capabilities (setcap) seems to disable LD_LIBRARY_PATH - Stack Overflow<br/><a href="https://stackoverflow.com/questions/9843178/linux-capabilities-setcap-seems-to-disable-ld-library-path">https://stackoverflow.com/questions/9843178/linux-capabilities-setcap-seems-to-disable-ld-library-path</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>]]></content>
        <author>
            <name><![CDATA[TripleZ’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://miaotony.xyz/2022/03/25/CTF_2022HFCTF/</id>
        <title><![CDATA[CTF | 2022 数字中国创新大赛虎符网络安全赛道 初赛 WriteUp]]></title>
        <updated>2022-03-27T21:49:20+08:00</updated>
        <link href="https://miaotony.xyz/2022/03/25/CTF_2022HFCTF/"/>
        <content type="text/html" src="https://miaotony.xyz/2022/03/25/CTF_2022HFCTF/"><![CDATA[上周末打了下虎符CTF，感觉题目总体而言难度挺大，也就Misc方向相对来说简单一点了，于是来玩了玩。]]></content>
        <author>
            <name><![CDATA[MiaoTony]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://miaotony.xyz/2022/03/13/Pentest_2022_1337UPLIVECTF/</id>
        <title><![CDATA[Pentest | 2022 1337UP LIVE CTF Workthrough]]></title>
        <updated>2022-03-14T19:39:42+08:00</updated>
        <link href="https://miaotony.xyz/2022/03/13/Pentest_2022_1337UPLIVECTF/"/>
        <content type="text/html" src="https://miaotony.xyz/2022/03/13/Pentest_2022_1337UPLIVECTF/"><![CDATA[这周末看了看2022 1337UP LIVE CTF国际赛中的一道偏渗透的题目，这里来记录一下解题过程。]]></content>
        <author>
            <name><![CDATA[MiaoTony]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.vvzero.com/2022/03/08/arm-cortex-a9-interrupt-with-fpu/</id>
        <title><![CDATA[我两周就写了三行代码 - ARM Cortex A9 中断与浮点数运算、FPU 问题]]></title>
        <updated>2022-03-08T14:16:45+08:00</updated>
        <link href="https://blog.vvzero.com/2022/03/08/arm-cortex-a9-interrupt-with-fpu/"/>
        <content type="text/html" src="https://blog.vvzero.com/2022/03/08/arm-cortex-a9-interrupt-with-fpu/"><![CDATA[<h2 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h2><p>公司产品采用了 Xilinx Zynq 7z010 芯片，用于运动控制以及网络通讯。两周前，测试过程中发现网络通信会小概率出错，TCP 收到的数据 CRC 校验失败，无法稳定复现。</p><p>设备平台概述：</p><ol><li>CPU: Cortex-A9 双核</li><li>RAM: 1GB DDR3</li><li>操作系统: FreeRTOS</li><li>网络协议栈: lwip211</li></ol><h2 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h2><h3 id="怀疑应用层数据处理问题"><a href="#怀疑应用层数据处理问题" class="headerlink" title="怀疑应用层数据处理问题"></a>怀疑应用层数据处理问题</h3><p>TCP 是二进制数据流，每个包的长度不固定，应用层也许会写错。于是我修改了应用层的处理方案，手动构造了定长的数据包，虽然会导致 TCP 流量大幅上涨，但是逻辑看起来更清晰。</p><p>然而，修改后，似乎由于流量变大了，原来小概率出现的错误，现在大概率会出现！这也给 Debug 带来了有利的一面。</p><h3 id="怀疑网络通讯链路电磁干扰问题"><a href="#怀疑网络通讯链路电磁干扰问题" class="headerlink" title="怀疑网络通讯链路电磁干扰问题"></a>怀疑网络通讯链路电磁干扰问题</h3><p>但是这个怀疑方向很快就被否定了，因为我用了 TCP 协议，理论上只可能超时，不可能出错。</p><h3 id="怀疑-lwip-接口调用问题"><a href="#怀疑-lwip-接口调用问题" class="headerlink" title="怀疑 lwip 接口调用问题"></a>怀疑 lwip 接口调用问题</h3><p>lwip 有多个 TCP API，之前用的 Socket API，我尝试换成了 RAW API，但是问题依旧。</p><p>在调试的过程中，我尝试在网络链路的每一层数据打印出来，惊奇地发现，在数据链路层，数据是正确的！然而 lwip 的代码冗杂且数 MB 数据中才会出现几个错误位，于是我暂时没有考虑一层层分析代码。</p><h3 id="怀疑与其他线程之间存在干扰，或者存在数组越界访问"><a href="#怀疑与其他线程之间存在干扰，或者存在数组越界访问" class="headerlink" title="怀疑与其他线程之间存在干扰，或者存在数组越界访问"></a>怀疑与其他线程之间存在干扰，或者存在数组越界访问</h3><p>这样 Debug 就很简单了。我关闭了所有其他的线程，不出所料，Bug 消失了。</p><p>一点点放开线程，发现是一个<strong>运动控制的硬中断</strong>造成的 Bug。</p><p>然后再“二分法”排除代码，结果排除到最后，仅仅是一行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b, c 也为 long long</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a = (<span class="keyword">long</span> <span class="keyword">long</span>)((<span class="keyword">double</span>)b * (<span class="keyword">double</span>)c);</span><br></pre></td></tr></table></figure><p>这让我大跌眼镜，因为实验证明，把这句话删了，TCP 通讯就正常了。</p><h3 id="怀疑是浮点运算的问题"><a href="#怀疑是浮点运算的问题" class="headerlink" title="怀疑是浮点运算的问题"></a>怀疑是浮点运算的问题</h3><p>更加让我迷惑的是，把上述语句改下，同样也没问题了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a = b * c;</span><br></pre></td></tr></table></figure><p>进一步定位：我在另一个线程中添加了浮点运算，并把这个有影响的中断关闭，TCP 通讯同样出问题了。</p><p>就此，几乎可以确定是浮点数运算造成的问题了。</p><h3 id="问题小结"><a href="#问题小结" class="headerlink" title="问题小结"></a>问题小结</h3><p>一句话描述问题：在中断或某个线程中进行浮点数操作，会导致另一个 TCP 通讯线程数据出错。</p><p>说实话，我当时也没法理解其中的联系。</p><p>只不过我们用的芯片自带双精度 FPU（浮点运算单元），也许是 FPU 的问题？</p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="查找资料"><a href="#查找资料" class="headerlink" title="查找资料"></a>查找资料</h3><p>关键词 <code>lwip tcp receive wrong data</code>，<code>zynq float process corrupt memory</code> 等关键词，都没有找到有价值的解决方案。</p><h3 id="求助-Xilinx-技术支持"><a href="#求助-Xilinx-技术支持" class="headerlink" title="求助 Xilinx 技术支持"></a>求助 Xilinx 技术支持</h3><p>果然用微信联系的技术支持不靠谱，上午说帮忙复现，下午就没信了。</p><h3 id="求助朋友圈资深开发者"><a href="#求助朋友圈资深开发者" class="headerlink" title="求助朋友圈资深开发者"></a>求助朋友圈资深开发者</h3><p>只可惜他们都是互联网界的大佬，只有我在嵌入式开发领域摸爬滚打，他山之玉难以攻石。</p><h3 id="求助-V2EX-网友"><a href="#求助-V2EX-网友" class="headerlink" title="求助 V2EX 网友"></a>求助 V2EX 网友</h3><p>发了帖子 <a href="https://v2ex.com/t/838643">在这里</a>。</p><p>V 站网友给了非常有价值的线索：</p><ol><li>网友 A 称他们使用同样的平台出现过类似的问题。他们的解决方案是，进行浮点数操作之前，关闭所有的中断；</li><li>网友 B 分析可能 <code>正在计算浮点数的时候，刚好发生了 systick 线程切换，但是线程切换过程中，没有保存 /恢复浮点寄存器</code>；</li><li>网友 C 更是找到了相关文章：<blockquote><p>“Some GCC libraries optimise memory copy and memory set (and possibly other) functions by making use of the wide floating point registers. Therefore, by default, any task that uses functions such as memcpy(), memcmp() or memset(), or uses a FreeRTOS API function such as xQueueSend() which itself uses memcpy(), will inadvertently corrupt the floating point registers.”</p></blockquote></li></ol><p>真可谓一针见血，<strong>TCP 协议栈中大量使用了 memcpy，而 memcpy 又使用了 FPU 的寄存器，极有可能在 TCP 处理数据的过程中，另一个中断来了，进行了浮点运算并修改了 FPU 的寄存器，以致 TCP 数据出错。</strong></p><p>同样根据网友的指点，看了这篇文章 <a href="https://www.freertos.org/Using-FreeRTOS-on-Cortex-A-Embedded-Processors.html">Using FreeRTOS on ARM Cortex-A9 Embedded Processors</a>，原来 FreeRTOS 自身已经考虑了 FPU 与上下文切换相关的问题，只是要我们将 <code>configUSE_TASK_FPU_SUPPORT</code> 这个宏定义为 2 即可。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>花了些时间进行 FPU 寄存器相关的搜索，依照 <a href="https://stackoverflow.com/questions/38667425/how-to-push-and-pop-floating-point-registers-to-the-stack-on-armv7-32-bit">这篇文章</a> ，对 FPU 的寄存器做了相关处理，总结起来就三行代码：</p><h3 id="第一行代码"><a href="#第一行代码" class="headerlink" title="第一行代码"></a>第一行代码</h3><p>在中断响应函数开头添加以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm(<span class="string">&quot;VPUSH &#123;d0-d15&#125;&quot;</span>); <span class="comment">// FPU 寄存器入栈</span></span><br></pre></td></tr></table></figure><h3 id="第二行代码"><a href="#第二行代码" class="headerlink" title="第二行代码"></a>第二行代码</h3><p>在中断响应函数末尾添加以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm(<span class="string">&quot;VPOP &#123;d0-d15&#125;&quot;</span>); <span class="comment">// FPU 寄存器出栈</span></span><br></pre></td></tr></table></figure><h3 id="第三行代码"><a href="#第三行代码" class="headerlink" title="第三行代码"></a>第三行代码</h3><p>FreeRTOS 启用 FPU 支持相关宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> configUSE_TASK_FPU_SUPPORT 2</span></span><br></pre></td></tr></table></figure><p>至此，问题解决。</p>]]></content>
        <author>
            <name><![CDATA[VVBLOG]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.zeddyu.info/2022/02/21/2022-02-21-PracticalTimingTimeless/</id>
        <title><![CDATA[Writeup for A More Secure Pastebin - Practical Timeless Timing in Browser]]></title>
        <updated>2022-02-21T10:09:57+08:00</updated>
        <link href="https://blog.zeddyu.info/2022/02/21/2022-02-21-PracticalTimingTimeless/"/>
        <content type="text/html" src="https://blog.zeddyu.info/2022/02/21/2022-02-21-PracticalTimingTimeless/"><![CDATA[<p>本次 TQLCTF 我主要负责了 A More Secure Pastebin 的出题工作，通过该种攻击可以在一定网络波动内探测极小时间（1ms甚至更小）差异内的信息泄漏，以下是本题的出题 writeup 以及一些出题过程记录。</p>]]></content>
        <author>
            <name><![CDATA[Zedd’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.logicjake.xyz/2021/12/01/%E7%AE%97%E6%B3%95%E7%A7%8B%E6%8B%9B%E4%B8%8A%E5%B2%B8%E5%8E%86%E7%A8%8B%E2%80%94%E5%A4%87%E6%88%98%E5%AE%9E%E4%B9%A0%E7%A7%8B%E6%8B%9B/</id>
        <title><![CDATA[推荐算法上岸历程—备战实习秋招]]></title>
        <updated>2022-01-29T09:31:17+08:00</updated>
        <link href="https://www.logicjake.xyz/2021/12/01/%E7%AE%97%E6%B3%95%E7%A7%8B%E6%8B%9B%E4%B8%8A%E5%B2%B8%E5%8E%86%E7%A8%8B%E2%80%94%E5%A4%87%E6%88%98%E5%AE%9E%E4%B9%A0%E7%A7%8B%E6%8B%9B/"/>
        <content type="text/html" src="https://www.logicjake.xyz/2021/12/01/%E7%AE%97%E6%B3%95%E7%A7%8B%E6%8B%9B%E4%B8%8A%E5%B2%B8%E5%8E%86%E7%A8%8B%E2%80%94%E5%A4%87%E6%88%98%E5%AE%9E%E4%B9%A0%E7%A7%8B%E6%8B%9B/"><![CDATA[<p>秋招正式结束，记录一下从备战到秋招的整个过程和一些体会。具体公司的面经已经单独发过，所以这里着重介绍准备的过程和心得体会。</p><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>211本硕，计算机科班，没有顶会顶刊，找实习和秋招的时候只有一篇水会和一篇在投SCI期刊。研究方向是动态网络表示，属于数据挖掘，在推荐算法里有落地场景。研一和研二上半学期基本完成了学院毕业要求，也和老师谈好了实习的事情，整个过程大致分为4个时间段：</p><ul><li>2019.7 ~ 2020.9 打比赛</li><li>2020.9 ~ 2021.3 刷题，夯实机器学习、深度学习基础，整理以往竞赛</li><li>2021.3 ~ 2021.5 实习面试，刷题，夯实机器学习、深度学习基础</li><li>2021.6 ~ 2021.9 实习，秋招面试</li></ul><p>个人主要优势在竞赛经历，当然不是ACM那种大佬竞赛，这里指数据挖掘竞赛。实习+秋招所有大厂的推荐算法都面了一遍，秋招上岸广告推荐算法。</p><h1 id="备战"><a href="#备战" class="headerlink" title="备战"></a>备战</h1><p>确定读研后就明确工作要走数据挖掘（后面在竞赛中慢慢了解到推荐算法这个方向，并以此为目标）方向，当时了解到算法岗位3大敲门砖：实习，项目和论文。考虑到自己和研究组的水平，发顶会顶刊基本不太可能，所以努力的方向集中在实习和项目上。学生没资源，搞项目也很难，所以这里项目特指数据挖掘竞赛。</p><h2 id="竞赛"><a href="#竞赛" class="headerlink" title="竞赛"></a>竞赛</h2><p>竞赛是一个周期比较长的过程，所以准备的比较早，也没啥打基础的过程，以赛带练，边学边打。第一个比赛是大四暑假参加的，预测学生考试成绩，赛题很简单但却很经典，基本上囊括了数据挖掘竞赛需要掌握的所有东西。做竞赛的经验就是多去找之前竞赛的开源方案或者代码，学习他们是怎么做特征工程的，怎么构建流程的，甚至是一些场景下面的trick。这方面的资料其实挺多，有很多赛圈大佬愿意在赛后开源代码或者开文章介绍方案细节，愿意去找，愿意去学，愿意去实现，进步会很快。另外就是竞赛中组队的事情，很多人喜欢在群里找人带，但其实很少有前排愿意这样做，一方面大家都喜欢强强联合，所以一般会找和自己成绩差不多的人或者和熟悉的人组队，一方面前期大家都是单干的，后期组队融合上分。所以竞赛小白更重要的是自己先变强，尽可能把分数刷高点，后期组队更进一步，赛后多学习前排代码和方案，刚开始成绩不理想不可怕，一次完整的竞赛经历对自己的帮助是巨大的，后面会越来越好。</p><p>最开始打的比赛基本都是表格数据，纯数据挖掘，这一段时期主要是锻炼特征工程（python，pandas）和熟悉树模型（xgboost，lightgbm，catboost梭哈）。推荐相关的竞赛比较少，完整的推荐流程包括召回，（粗排），精排。大部分和推荐相关的竞赛都集中在精排部分，也是就点击率预估（ctr）竞赛，比如我参加过的图灵联邦视频点击预测大赛（2019）和一点资讯技术编程大赛CTR赛道（2021）。但近些年的趋势，纯ctr的竞赛也不多，前些年的腾讯广告算法大赛很多是ctr相关的，现在慢慢转向多任务多模态了，这其实也是业界关注的问题风向。如果想蹲这方面的竞赛，可以多关注华为的DIGIX全球校园AI算法精英大赛和腾讯广告算法大赛，每年都有推荐算法方面的赛题，如果能获奖，面试的时候作为项目来讲加分不少。我参加的包含完整推荐流程的就两个：KDD Cup Debias 竞赛（2020）和天池新闻推荐竞赛（2020，入门赛，没奖金，竞争小）。KDD Cup Debias 方案流程包含了召回和排序，所以业务相关性非常强，而且比赛规格高（KDD和阿里合办的），如果能获奖牌子也比较硬。在实习面试和秋招面试的时候，KDD Cup Debias竞赛被问的最多，基本上每个面试官都要问一次，导致后面要说的词都背的滚瓜烂熟了，实习的时候mentor也说没有这个经历你简历过不了。也有一些比赛使用深度学习去做，比如2020腾讯广告算法大赛和Kaggle的Answer Correctness Prediction。</p><p>纵观来说，竞赛对自己的帮助是很大的，夯实基础（python，pandas，深度学习，机器学习），了解业务流程（推荐算法相关），丰富简历。但最开始也说过竞赛是一个周期比较长的过程，每个竞赛基本都会持续2-3个月，而且短时间内不一定有好的竞赛（平台大，赛题方向好）出现，所以如果想在这方面有所收益，需要投入的时间不少，而且现在狼多肉少，想进前排也越来越难了。如果想走这条路，平时多关注各大平台的赛题，比如kaggle，天池，华为DIGIX校园赛和腾讯广告算法大赛等等，我自己做了个聚合网站，用爬虫抓取比赛信息，感兴趣可以看看<a href="https://www.logicjake.xyz/MLCompetitionHub">MLCompetitionHub</a>。</p><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><p>现在找工作做题是必不可少的，所以刷题也很重要，我个人主要在LeetCode上完成。我刷题的经验比较简单粗暴，按照编号刷，median的题为主，常见的hard题为辅，中间穿插一些专题专攻，多做几遍《剑指offer》和《程序员面试金典》（这两本书不要买，LeetCode都有），遇到不会的题收藏起来，空闲时间拿出来再过一遍。作为一个菜鸡，我觉得就是多刷多记，勤能补拙，刷的多见得也多，基本上能覆盖面试官问的题目，大部分面试官都是出的原题。我从2020年8月份开始大批量刷题，LeetCode有个进度管理功能，我开了两个进度，总共做了近800道题，当然这中间有重复的。此外就是持之以恒，保持做题的状态，我基本上一天的安排，做5道新题，复习10道收藏的当时不会做的题。中后期注重做高频题目，推荐<a href="https://codetop.cc/" target="_blank" rel="noopener">codetop</a>，可以分公司分部门分岗位查看高频题。</p><div style="margin: auto"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.logicjake.xyz/leetcode%E8%BF%9B%E5%BA%A6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></div><div style="margin: auto"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.logicjake.xyz/leetcode%E8%BF%9B%E5%BA%A62.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></div><div style="margin: auto"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.logicjake.xyz/leetcode%E8%BF%9B%E5%BA%A63.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></div><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>基础包括机器学习，深度学习和业务相关。主要学习途径就是看书，结合别人的面经抓抓重点。</p><p>机器学习我看的《统计学习方法》和周志华的西瓜书。周志华大佬的西瓜书讲的很细致，数学的东西比较多，看的时候感觉不是太适合我，所以主要还是以《统计学习方法》为主。《统计学习方法》内容比较全面，不需要全过，结合自己的面试经验来看，掌握常见的机器学习模型就好：线性回归，逻辑回归，SVM，朴素贝叶斯，决策树，集成学习，K近邻。需要知道以上模型的原理和优缺点，会手推（尤其是逻辑回归的求梯度）。lightgbm和xgboost也很重要，经常被问原理和优缺点，这里推荐几篇文章：<a href="https://zhuanlan.zhihu.com/p/78293497" target="_blank" rel="noopener">LightGBM算法梳理</a>和<a href="https://zhuanlan.zhihu.com/p/142413825" target="_blank" rel="noopener">机器学习 | XGBoost详解</a>。此外推荐《百面机器学习》，有常见面试点的总结和讲解。</p><p>大四看吴恩达的课入门深度学习，面试备战主要看《百面深度学习》，然后自己总结了一些点：RNN，CNN（没被问过），Dropout，激活函数，正则化，优化器，Transformer。Word2Vec也被问的比较多，暂且也把他归到深度学习这块，主要了解negative sampling，hierarchical softmax，CBOW和Skip-gram区别。深度学习比较频繁的考察点有：</p><ul><li>如何解决过拟合</li><li>梯度爆炸和梯度消失</li><li>BN原理</li><li>Dropout原理</li><li>常见的优化器和他们的优缺点</li><li>Transformer结构</li><li>self-attention原理</li><li>自己搞深度学习的有啥心得和体会（各讲各话了）</li></ul><p>业务相关就看个人了，看你的岗位方向。我主要看的是推荐算法相关的，推荐《深度学习推荐系统》，包含了推荐系统的各大模型和其他问题，适合入门和了解初步的推荐系统体系。除了这本书之外，也可以多关注业界发展，比如大厂发的论文或者业界大佬发的文章，追踪一下热点，比如冷启动问题，长序列建模，多任务模型。尽可能丰富自己对推荐系统的了解，让面试官看到你身上的亮点，会有面试官让你谈谈你对推荐系统的认识或者最近看的论文。</p><h1 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h1><p>实习有利有弊，好处在于实习转正相对比较容易，有个保底，也可以提前了解组内业务和环境；坏处就是会和秋招冲突，耽误面试。今年因为疫情，面试都是线上，所以对我来说实习的好处还是远远大于坏处的。还有一点建议，如果有高追求的话，不要实习转正就躺平，哪怕你非常想待在实习的组，因为你all in之后有可能被压价，而且不能预料业务会不会发生变动。</p><p>实习面试的时候建议先从小公司面起，积累经验，形成自己的自我介绍和项目介绍模板，另外也可以看看公司注重哪些点，查漏补缺。具体的面经就不在这里展开了，可以查看<a href="https://www.logicjake.xyz/2021/03/23/2021%E6%8E%A8%E5%B9%BF%E6%90%9C%E6%9A%91%E5%81%87%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/">算法暑假实习面经</a>或者进我的牛客主页看。小公司的实习消息和投递可以关注牛客的<a href="https://nowpick.nowcoder.com/w/intern/center" target="_blank" rel="noopener">实习广场</a>，大公司的实习投递时间基本上参考往年就可以了，都有自己的投递系统。我个人的时间安排如下，基本上过完年回来就开始高强度面试，3月份最为忙碌。面试内容基本围绕做的比赛展开，介绍方案，由方案引出一些细节。</p><ul><li>2021.2 阿里各部门开始宣传收简历，支持提前面试</li><li>2021.2 ~ 2021.3 面试了一些小公司</li><li>2021.3.1 阿里系统正式开放</li><li>2021.3月初 字节，阿里，快手，腾讯，百度开始面试</li><li>2021.4月初 美团开始面试 </li><li>2021.5月初 拼多多开始面试 </li></ul><h1 id="秋招"><a href="#秋招" class="headerlink" title="秋招"></a>秋招</h1><p>秋招我是一边实习一遍准备的，6月底去实习后刷题就不多了，面试时间也尽量安排在晚上或者早上，甚至周末。大部分公司都是会提前约面试时间，和面试官沟通就好。各个公司校招开始可以关注牛客的<a href="https://www.nowcoder.com/school/schedule?firstScroll=true" target="_blank" rel="noopener">校招日历</a>，比较全面。秋招时间不是太充裕，要保证实习工作的完成，所以基本都投的大厂。实习在北京，后面正式工作想去上海，所以后面放弃了不在上海的大厂。上海腾讯算法岗太少，我在BOSS上勾搭了好几个腾讯的招聘人员都没啥进展，系统里也没上海的捞。秋招面经可以看<a href="https://www.logicjake.xyz/2021/07/03/2021%E6%8E%A8%E5%B9%BF%E6%90%9C%E7%AE%97%E6%B3%95%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/">算法秋招面经</a>，也不展开了。</p>]]></content>
        <author>
            <name><![CDATA[LogicJake’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.logicjake.xyz/2021/10/08/connectx%E5%AE%9E%E8%B7%B5/</id>
        <title><![CDATA[Connect X 实践]]></title>
        <updated>2022-01-29T09:31:17+08:00</updated>
        <link href="https://www.logicjake.xyz/2021/10/08/connectx%E5%AE%9E%E8%B7%B5/"/>
        <content type="text/html" src="https://www.logicjake.xyz/2021/10/08/connectx%E5%AE%9E%E8%B7%B5/"><![CDATA[<p>游戏目标为在你的对手之前，在游戏板上水平、垂直或对角地放置连续4个跳棋。轮到你时，把你的一个跳棋“投”到棋盘一列中，棋子会掉落在这一列最底部的空位置。</p><h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><p>随机选取尚有空位置的一列进行投放。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_agent</span><span class="params">(obs, config)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">    <span class="keyword">return</span> choice([c <span class="keyword">for</span> c <span class="keyword">in</span> range(config.columns) <span class="keyword">if</span> obs.board[c] == <span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="minimax"><a href="#minimax" class="headerlink" title="minimax"></a>minimax</h3><p>适用于零和博弈场景，每次操作即搜索选择对自己有利的情况，如果我们令甲胜的局面值为1，乙胜的局面值为-1，而和局的值为0。当轮到甲走时，甲定会选择子节点值最大的走法；而轮到乙时，乙则会选择子节点值最小的走法。所以对于中间节点的值有如下计算方法：如果该节点所对应的局面轮到甲走棋，则该节点的值是其所有子节点中值最大的一个的值。而如果该节点所对应的局面轮到乙走棋，则该节点的值是其所有子节点中值最小的一个的值，这就是minimax的搜索思想。minimax算法本质还是穷尽，解空间大的时候不适用。此时可以约束game tree的深度，另外不一定需要知道终局分数，也能对当前棋面做出大致评估。在下面的代码中，棋面的评估仅被分为输、赢、平3种状态。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.logicjake.xyz/minmax反向.png" alt="minmax反向" title="">                </div>                <div class="image-caption">minmax反向</div>            </figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimax_agent</span><span class="params">(obs, config)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> math <span class="keyword">import</span> inf <span class="keyword">as</span> infinity</span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">    <span class="comment"># 电脑</span></span><br><span class="line">    COMP = <span class="number">2</span></span><br><span class="line">    <span class="comment"># 玩家</span></span><br><span class="line">    HUMAN = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    columns = config.columns</span><br><span class="line">    rows = config.rows</span><br><span class="line">    <span class="comment"># 因为是提前一个落子检查，所以只需要满足inarow - 1个连续</span></span><br><span class="line">    inarow = config.inarow - <span class="number">1</span></span><br><span class="line">    size = rows * columns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_win</span><span class="params">(board, player, column)</span>:</span></span><br><span class="line">        <span class="comment"># 找到当前列的落子位置</span></span><br><span class="line">        row = max([r <span class="keyword">for</span> r <span class="keyword">in</span> range(rows) <span class="keyword">if</span> board[column + (r * columns)] == <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(offset_row, offset_column)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, inarow + <span class="number">1</span>):</span><br><span class="line">                r = row + offset_row * i</span><br><span class="line">                c = column + offset_column * i</span><br><span class="line">                <span class="comment"># 停止条件</span></span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    r &lt; <span class="number">0</span></span><br><span class="line">                    <span class="keyword">or</span> r &gt;= rows</span><br><span class="line">                    <span class="keyword">or</span> c &lt; <span class="number">0</span></span><br><span class="line">                    <span class="keyword">or</span> c &gt;= columns</span><br><span class="line">                    <span class="keyword">or</span> board[c + (r * columns)] != player</span><br><span class="line">                ):</span><br><span class="line">                    <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> inarow</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            count(<span class="number">1</span>, <span class="number">0</span>) &gt;= inarow  <span class="comment"># 垂直方向，向下搜</span></span><br><span class="line">            <span class="keyword">or</span> (count(<span class="number">0</span>, <span class="number">1</span>) + count(<span class="number">0</span>, <span class="number">-1</span>)) &gt;= inarow  <span class="comment"># 水平方向，左右两边搜</span></span><br><span class="line">            <span class="keyword">or</span> (count(<span class="number">-1</span>, <span class="number">-1</span>) + count(<span class="number">1</span>, <span class="number">1</span>)) &gt;= inarow  <span class="comment"># 主对角线方向</span></span><br><span class="line">            <span class="keyword">or</span> (count(<span class="number">-1</span>, <span class="number">1</span>) + count(<span class="number">1</span>, <span class="number">-1</span>)) &gt;= inarow  <span class="comment"># 次对角线方向</span></span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(board, column, player)</span>:</span></span><br><span class="line">        row = max([r <span class="keyword">for</span> r <span class="keyword">in</span> range(rows) <span class="keyword">if</span> board[column + (r * columns)] == <span class="number">0</span>])</span><br><span class="line">        board[column + (row * columns)] = player</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimax</span><span class="params">(board, player, depth)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> player == HUMAN:</span><br><span class="line">            best_score = -infinity</span><br><span class="line">            best_column = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            best_score = infinity</span><br><span class="line">            best_column = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归终止条件1 深度达到设定值</span></span><br><span class="line">        <span class="keyword">if</span> depth == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>, <span class="literal">None</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归终止条件2 一方获胜</span></span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> range(columns):</span><br><span class="line">            <span class="comment"># 遍历可选列，检查是否可以获胜</span></span><br><span class="line">            <span class="keyword">if</span> board[column] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> is_win(board, player, column):</span><br><span class="line">                    <span class="comment">## 玩家获胜</span></span><br><span class="line">                    <span class="keyword">if</span> player == HUMAN:</span><br><span class="line">                        <span class="keyword">return</span> [<span class="number">1</span>, column]</span><br><span class="line">                    <span class="comment">## 电脑获胜</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> [<span class="number">-1</span>, column]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> range(columns):</span><br><span class="line">            <span class="keyword">if</span> board[column] == <span class="number">0</span>:</span><br><span class="line">                next_board = board[:]</span><br><span class="line">                play(next_board, column, player)</span><br><span class="line">                <span class="comment"># 向后看，计算分数</span></span><br><span class="line">                score, _ = minimax(next_board, player % <span class="number">2</span> + <span class="number">1</span>, depth - <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> player == HUMAN:</span><br><span class="line">                    <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">                        best_score = score</span><br><span class="line">                        best_column = column</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> score &lt; best_score:</span><br><span class="line">                        best_score = score</span><br><span class="line">                        best_column = column</span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">return</span> [best_score, best_column]</span><br><span class="line">    </span><br><span class="line">    max_depth = <span class="number">4</span></span><br><span class="line">    _, column = minimax(obs.board[:], HUMAN, max_depth)</span><br><span class="line">    <span class="comment"># 兜底策略，如果minimax没找到解，则使用random算法</span></span><br><span class="line">    <span class="keyword">if</span> column == <span class="literal">None</span>:</span><br><span class="line">        column = choice([c <span class="keyword">for</span> c <span class="keyword">in</span> range(columns) <span class="keyword">if</span> obs.board[c] == <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> column</span><br></pre></td></tr></table></figure><p>[1] <a href="https://www.bilibili.co7m/video/BV1Eb411a7Vb" target="_blank" rel="noopener">https://www.bilibili.co7m/video/BV1Eb411a7Vb</a><br>[2] <a href="https://github.com/Cledersonbc/tic-tac-toe-minimax" target="_blank" rel="noopener">https://github.com/Cledersonbc/tic-tac-toe-minimax</a>  </p><h3 id="negamax"><a href="#negamax" class="headerlink" title="negamax"></a>negamax</h3><p>negamax是minimax的改进版，在效果上没有改进，仅仅进行了视角的统一。在minimax算法中，我们和对手之间是对立的视角，所以一个是最大化，一个是最小化。但是在negamax进行了视角的统一，大家追求的都是最大化。因此就有两个改进点，第一个就是当有一方胜利是，可以不加角色区分都返回1；第二个就在于对子节点的score进行选择时，统一最大化返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">negamax_agent</span><span class="params">(obs, config)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> math <span class="keyword">import</span> inf <span class="keyword">as</span> infinity</span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">    <span class="comment"># 电脑</span></span><br><span class="line">    COMP = <span class="number">2</span></span><br><span class="line">    <span class="comment"># 玩家</span></span><br><span class="line">    HUMAN = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    columns = config.columns</span><br><span class="line">    rows = config.rows</span><br><span class="line">    <span class="comment"># 因为是提前一个落子检查，所以只需要满足inarow - 1个连续</span></span><br><span class="line">    inarow = config.inarow - <span class="number">1</span></span><br><span class="line">    size = rows * columns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_win</span><span class="params">(board, player, column)</span>:</span></span><br><span class="line">        <span class="comment"># 找到当前列的落子位置</span></span><br><span class="line">        row = max([r <span class="keyword">for</span> r <span class="keyword">in</span> range(rows) <span class="keyword">if</span> board[column + (r * columns)] == <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(offset_row, offset_column)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, inarow + <span class="number">1</span>):</span><br><span class="line">                r = row + offset_row * i</span><br><span class="line">                c = column + offset_column * i</span><br><span class="line">                <span class="comment"># 停止条件</span></span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    r &lt; <span class="number">0</span></span><br><span class="line">                    <span class="keyword">or</span> r &gt;= rows</span><br><span class="line">                    <span class="keyword">or</span> c &lt; <span class="number">0</span></span><br><span class="line">                    <span class="keyword">or</span> c &gt;= columns</span><br><span class="line">                    <span class="keyword">or</span> board[c + (r * columns)] != player</span><br><span class="line">                ):</span><br><span class="line">                    <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> inarow</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            count(<span class="number">1</span>, <span class="number">0</span>) &gt;= inarow  <span class="comment"># 垂直方向，向下搜</span></span><br><span class="line">            <span class="keyword">or</span> (count(<span class="number">0</span>, <span class="number">1</span>) + count(<span class="number">0</span>, <span class="number">-1</span>)) &gt;= inarow  <span class="comment"># 水平方向，左右两边搜</span></span><br><span class="line">            <span class="keyword">or</span> (count(<span class="number">-1</span>, <span class="number">-1</span>) + count(<span class="number">1</span>, <span class="number">1</span>)) &gt;= inarow  <span class="comment"># 主对角线方向</span></span><br><span class="line">            <span class="keyword">or</span> (count(<span class="number">-1</span>, <span class="number">1</span>) + count(<span class="number">1</span>, <span class="number">-1</span>)) &gt;= inarow  <span class="comment"># 次对角线方向</span></span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(board, column, player)</span>:</span></span><br><span class="line">        row = max([r <span class="keyword">for</span> r <span class="keyword">in</span> range(rows) <span class="keyword">if</span> board[column + (r * columns)] == <span class="number">0</span>])</span><br><span class="line">        board[column + (row * columns)] = player</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">negamax</span><span class="params">(board, player, depth)</span>:</span></span><br><span class="line">        <span class="comment"># 递归终止条件1 深度达到设定值</span></span><br><span class="line">        <span class="keyword">if</span> depth == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>, <span class="literal">None</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归终止条件2 一方获胜</span></span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> range(columns):</span><br><span class="line">            <span class="comment"># 遍历可选列，检查是否可以获胜</span></span><br><span class="line">            <span class="keyword">if</span> board[column] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> is_win(board, player, column):</span><br><span class="line">                    <span class="keyword">return</span> [<span class="number">1</span>, column]</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        best_score = -infinity</span><br><span class="line">        best_column = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> range(columns):</span><br><span class="line">            <span class="keyword">if</span> board[column] == <span class="number">0</span>:</span><br><span class="line">                next_board = board[:]</span><br><span class="line">                play(next_board, column, player)</span><br><span class="line">                <span class="comment"># 向后看，计算分数</span></span><br><span class="line">                score, _ = negamax(next_board, player % <span class="number">2</span> + <span class="number">1</span>, depth - <span class="number">1</span>)</span><br><span class="line">                score = -score</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">                    best_score = score</span><br><span class="line">                    best_column = column</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [best_score, best_column]</span><br><span class="line">    </span><br><span class="line">    max_depth = <span class="number">4</span></span><br><span class="line">    _, column = negamax(obs.board[:], HUMAN, max_depth)</span><br><span class="line">    <span class="comment"># 兜底策略，如果minimax没找到解，则使用random算法</span></span><br><span class="line">    <span class="keyword">if</span> column == <span class="literal">None</span>:</span><br><span class="line">        column = choice([c <span class="keyword">for</span> c <span class="keyword">in</span> range(columns) <span class="keyword">if</span> obs.board[c] == <span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> column</span><br></pre></td></tr></table></figure>]]></content>
        <author>
            <name><![CDATA[LogicJake’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.logicjake.xyz/2021/09/20/%E4%B8%80%E7%82%B9%E8%B5%84%E8%AE%AF%E6%8A%80%E6%9C%AF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9BCTR%E8%B5%9B%E9%81%93-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</id>
        <title><![CDATA[一点资讯技术编程大赛CTR赛道-赛后总结]]></title>
        <updated>2022-01-29T09:31:17+08:00</updated>
        <link href="https://www.logicjake.xyz/2021/09/20/%E4%B8%80%E7%82%B9%E8%B5%84%E8%AE%AF%E6%8A%80%E6%9C%AF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9BCTR%E8%B5%9B%E9%81%93-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"/>
        <content type="text/html" src="https://www.logicjake.xyz/2021/09/20/%E4%B8%80%E7%82%B9%E8%B5%84%E8%AE%AF%E6%8A%80%E6%9C%AF%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9BCTR%E8%B5%9B%E9%81%93-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"><![CDATA[<p>最终成绩：第一<br>比赛地址：<a href="https://tech.yidianzixun.com/competition/" target="_blank" rel="noopener">https://tech.yidianzixun.com/competition/</a><br>源码：<a href="https://github.com/LogicJake/yidianzixun-ctr-top1" target="_blank" rel="noopener">https://github.com/LogicJake/yidianzixun-ctr-top1</a> </p><p>典型的点击率预估问题，但是数据量非常大，总共有189766959条训练集，但只有5w条测试集。所以这题采用NN能取得比较好的效果，但由于训练集和测试集分布不一致的问题，有效抽取特征是一个难点。</p><a id="more"></a><h1 id="赛题背景"><a href="#赛题背景" class="headerlink" title="赛题背景"></a>赛题背景</h1><p>点击率（Click-Through Rate，简称CTR）预估是推荐算法的重要模块，通常用于在用户请求推荐系统时对内容进行排序，其结果直接影响产品的核心指标和用户的消费体验。在真实环境里，用户对某条内容是否产生点击行为的原因非常复杂，既包含内容本身的信息呈现和优质程度，又包含用户的基础属性（性别、年龄等）和个体偏好，甚至与当前所处的网络环境、地理位置也息息相关。如何抽取出这些复杂的诱因并对其进行建模学习，精准预估出海量用户对不同内容的点击概率，一直是推荐算法的一个重要研究方向。</p><h1 id="赛题内容"><a href="#赛题内容" class="headerlink" title="赛题内容"></a>赛题内容</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>本次大赛提供抽样用户过去一段时间内在一点资讯APP上的真实曝光和点击记录，以及所涉及用户和文章的基础属性，参赛者需要基于这些数据进行分析和建模。同时，大赛提供这批用户之后一段时间的曝光文章列表，参赛者最终提交给系统每个用户在之后曝光文章上的点击概率预估值（0-1之间的浮点数）。系统根据点击概率预估值和用户真实点击情况的差异，来评估预估任务的准确程度。 本次大赛提供的数据将隐去能代表用户身份的所有信息，对部分必要的敏感信息也进行了加密处理。</p><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><p>大赛采用AUC值评估CTR预估任务的精准度，只考虑预测结果的相对顺序，消除指标分数对于阈值的依赖性。</p><h1 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h1><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>特征工程只有两组，基于用户历史记录统计和基于全局统计。用户历史统计主要针对预测目标click和强相关的duration（消费时长）展开。这两个特征和预测目标强相关，所以基于历史信息统计，避免标签泄漏。全局信息下可以计算各组count，反应热度。</p><p>这个赛题有个明显的特点就是测试集和训练集分布不一致，训练集中每天的数据以百万记，但测试集当天的数据只有5w，明显测试集经过了采样，所以很多抽取的特征（譬如很有用的时间特征）都无法取得线上收益。第二名队伍“莲”基于上述问题，根据测试集的规模对训练集进行了分组，在组内进行特征抽取，从而做到抽取的特征分布一致，化腐朽为神奇，线上稳定上分。</p><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p>主体结构为deepfm，fm做显式二阶交叉，deep做高阶交叉。在做数据分析的时候，有些特征不同特征值的后验ctr相差较大，针对每个离散特征计算特征值对应的ctr的方差，以此来衡量后验ctr的分布差异。可以发现provice，device和city对应的特征值后验ctr分布差异明显。虽说基于对深度学习的假设，NN是可以自动学习这种分布，但是受限于数据不充分，NN无法充分学习到这种差异。因此我们将先验知识强加给NN，在现有的网络结构中显式加入“个性化学习组件”，类比FM结构让网络显式做二阶交叉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> tqdm([c <span class="keyword">for</span> c <span class="keyword">in</span> train.columns <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'userid'</span>, <span class="string">'docid'</span>, <span class="string">'click'</span>]]):</span><br><span class="line">    s = train.groupby([col])[<span class="string">'click'</span>].mean()</span><br><span class="line">    print(col, s.std(), s.max(), s.min())</span><br></pre></td></tr></table></figure><table><thead><tr><th>特征</th><th>ctr方差</th></tr></thead><tbody><tr><td>province</td><td>0.130</td></tr><tr><td>device</td><td>0.119</td></tr><tr><td>city</td><td>0.110</td></tr><tr><td>os</td><td>0.031</td></tr><tr><td>age</td><td>0.025</td></tr><tr><td>gender</td><td>0.032</td></tr><tr><td>category1st</td><td>0.036</td></tr><tr><td>category2st</td><td>0.053</td></tr></tbody></table><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.logicjake.xyz/ydzz_model.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如上图所示，原始DNN的每层输入值乘上一个同维度的 scale 向量，该scale向量由一个独立的小网络得到，该小网络最后一层的激活函数是sigmoid，且✖️2，从而保证scale向量的值既能做到提升也能做到打压，拟合不同特征值巨大的分布差异。</p><p>前面做特征的时候也说到，click和duration是强相关的，duration是click之后的延伸，有点类似click和convert的关系。所以自然想到使用多任务模型结构，将duration信息迁移到click主任务。但实际尝试share bottom和mmoe均对click主任务无提升，其他队伍也尝试过ESMM。从一点资讯的实操结果看，多任务模型结构对click无提升，甚至还有损，在实际场景中使用多任务往往是出于推荐场景下的多指标综合提升。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，比赛的数据很不错，充足的数据量给了NN很大的舞台，当然树模型也能做的很好。赛题主办方线下组织也很用心，在比赛之余看到了公司的文化和对员工的关怀。</p>]]></content>
        <author>
            <name><![CDATA[LogicJake’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.logicjake.xyz/2021/07/03/2021%E6%8E%A8%E5%B9%BF%E6%90%9C%E7%AE%97%E6%B3%95%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/</id>
        <title><![CDATA[2021推广搜算法秋招面经]]></title>
        <updated>2022-01-29T09:31:17+08:00</updated>
        <link href="https://www.logicjake.xyz/2021/07/03/2021%E6%8E%A8%E5%B9%BF%E6%90%9C%E7%AE%97%E6%B3%95%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
        <content type="text/html" src="https://www.logicjake.xyz/2021/07/03/2021%E6%8E%A8%E5%B9%BF%E6%90%9C%E7%AE%97%E6%B3%95%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"><![CDATA[<h1 id="360-推荐算法"><a href="#360-推荐算法" class="headerlink" title="360-推荐算法"></a>360-推荐算法</h1><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>算法题：1. 非递归的二叉树中序遍历；2.  指定概率列表，写一个随机采样算法</p><ol><li>介绍竞赛</li><li>召回的多样性</li><li>数据规模</li><li>ANN使用的什么工具</li><li>点击率预估为什么选择 lgb</li><li>排序为什么不使用基于 pair wise 的模型</li><li>了解 LambdaMart 算法吗</li><li>lightgbm 相较于 xgboost 的优势</li><li>了解的其他点击率预估算法</li><li>对特征交叉方面的个人理解</li><li>wide &amp; deep 模型 wide 部分和 deep 部分分别侧重学习什么信息</li><li>deepfm 一定优于 wide &amp; deep 吗</li><li>如何解决稀疏问题（回答的 hash embedding，不知道对不对）</li><li>在模型侧如何打压热门商品</li></ol><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><ol><li>介绍比赛背景</li><li>怎么分工的，你负责的部分</li><li>为什么使用 w2v，有试过其他 embedding 工具吗</li><li>w2v 的参数怎么调节的</li><li>w2v 的 min_count 设置的多大，从什么方面考虑的</li><li>介绍 NN 的结构</li><li>怎么调参的</li><li>了解哪些正则化方法（layernorm，batchnom）</li><li>上面两者有什么区别</li><li>有没有遇到过梯度消失，梯度爆炸，怎么解决的</li><li>多任务模型结构了解吗</li><li>知道哪些点击率预估模型</li><li>点击率预估任务中负样本过多怎么办</li><li>下采样后，训练样本和线上 server 样本分布不一样怎么办（纠偏公式）</li><li>冷启动该怎么做</li><li>开放题：现在做一个搜索系统，你会考虑哪些东西，各方面都行</li><li>未来的职业规划</li></ol><h1 id="百度-推荐算法"><a href="#百度-推荐算法" class="headerlink" title="百度-推荐算法"></a>百度-推荐算法</h1><h2 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h2><p>算法题：leetcode 34</p><ol><li>研究方向</li><li>学习的课程</li><li>推荐流程中哪一步最重要</li><li>怎么办精排做的更准</li><li>特征挖掘比较核心的技术</li><li>特征挖掘方面，深度学习比机器学习的优点</li><li>深度学习有能力做特征交叉，那哪些部分还需要我们人工去做</li><li>如何解决新特征没有embedding的问题</li><li>面对一个新的深度模型，如何去分析（参数，结构）</li><li>介绍比赛</li><li>比赛分工</li><li>word2vec 向量作为embedding层初始化能提升多少效率</li><li>word2vec 工作原理</li><li>负采样的原理是什么</li><li>二分类的损失函数</li><li>多分类的损失函数</li><li>sofamax公式是啥</li><li>用的什么优化算法，为什么</li><li>你的模型和别人相比有什么优点</li><li>模型集成是模型越多越好吗</li><li>模型的差异体现在哪里</li><li>如何判断新加的特征是否有效</li><li>MapReduce的原理知道吗</li></ol><h2 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h2><p>算法题：leetcode 1047</p><ol><li>介绍比赛</li><li>比赛分工</li><li>itemcf如何改进的</li><li>手写itemcf伪代码</li><li>工业上召回怎么做的（双塔）</li><li>为什么物品的embedding离线生成，用户的embedding是在线计算，能反过来吗</li><li>如果只有用户历史点击序列，怎么生成用户和物品的embedding</li><li>word2vec和bert有什么区别</li><li>召回的样本标签怎么构造</li></ol><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>聊实习，聊项目，聊人生</p><h1 id="触宝-推荐算法"><a href="#触宝-推荐算法" class="headerlink" title="触宝-推荐算法"></a>触宝-推荐算法</h1><h2 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h2><p>算法题：Leetcode 15. 三数之和</p><ol><li>介绍竞赛</li><li>多路召回的介绍</li><li>为什么选择lgb做点击率预测</li><li>后处理打压的原因和做法</li><li>为什么用transformer对有序序列处理</li><li>transformer里残差连接的作用</li></ol><h2 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h2><ol><li>简述树的前序遍历，中序遍历，后序遍历</li><li>什么是排序算法的稳定性，哪些排序算法是稳定的</li><li>了解哪些传统的分类算法</li><li>FM了解吗</li><li>xgboost了解吗</li><li>梯度消失和梯度爆炸，解决方法</li><li>dropout和batchnorm可以放在一起用吗，顺序是怎么样的</li><li>数值特征放到神经网络之前需要做哪些处理</li><li>如何在端到端中进行自动分桶</li><li>如何保证用户向量和物品向量在一个向量空间</li><li>多任务学习了解吗</li><li>多任务loss怎么结合</li><li>联合训练和交替训练的区别</li><li>推荐的整体流程</li><li>召回有哪些做法</li><li>精排模型有哪些</li><li>推荐有哪些指标</li><li>auc的变种</li><li>推荐有哪些在线指标</li><li>介绍竞赛项目</li><li>如何评估NN的特征重要性</li><li>树模型的特征重要性怎么计算的</li><li>现在反思项目有哪些优化点</li><li>竞赛如何分工合作的</li></ol><h2 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h2><ol><li>介绍竞赛</li><li>如果有新的商品上架，优化摆放位置，如何建模，有什么约束</li><li>对触宝的了解</li><li>以后的打算</li></ol><h1 id="华为-消费者BG"><a href="#华为-消费者BG" class="headerlink" title="华为-消费者BG"></a>华为-消费者BG</h1><h2 id="一面（FX计划挂）"><a href="#一面（FX计划挂）" class="headerlink" title="一面（FX计划挂）"></a>一面（FX计划挂）</h2><p>算法题：Leetcode 200. 岛屿数量 Leetcode 397. 整数替换</p><ol><li>介绍比赛</li><li>介绍研究方向</li><li>介绍聚类kmeans，还知道哪些聚类方法</li><li>如何确定聚类数量</li><li>介绍KNN</li><li>TF-IDF 计算方法</li><li>余弦距离和欧氏距离区别</li><li>卷积神经网络的变种有哪些</li><li>深度学习克服过拟合的方法</li><li>dropout在循环神经网络需要注意什么</li></ol><h2 id="一面（正式批）"><a href="#一面（正式批）" class="headerlink" title="一面（正式批）"></a>一面（正式批）</h2><p>算法题：Leetcode 1143. 最长公共子序列</p><ol><li>说一下笔试题的思路</li><li>介绍竞赛</li><li>介绍实习</li></ol><h2 id="二面-3"><a href="#二面-3" class="headerlink" title="二面"></a>二面</h2><p>算法题：大数据找中位数</p><ol><li>介绍研究内容、研究背景、指标提升情况</li><li>任选一个竞赛讲一下</li><li>基于图片emb的召回和基于文本emb的召回哪个效果好，为什么</li></ol><h2 id="三面-2"><a href="#三面-2" class="headerlink" title="三面"></a>三面</h2><p>没问技术问题，忽略</p><h1 id="shein-推荐算法"><a href="#shein-推荐算法" class="headerlink" title="shein-推荐算法"></a>shein-推荐算法</h1><h2 id="一面（挂）"><a href="#一面（挂）" class="headerlink" title="一面（挂）"></a>一面（挂）</h2><p>算法题：leetcode 802. 找到最终的安全状态</p><ol><li>介绍比赛</li><li>ndcg计算方式</li><li>如果使用auc，而不用ndcg，会有什么问题</li><li>集成模型bagging和boosting的区别</li><li>bagging和boosting在偏差和方差上的区别</li><li>xgboost和gbdt的区别</li><li>xgboost的叶子生成方式</li><li>lightgbm在计算速度上做了哪些优化</li><li>模型打压热门有哪些做法</li><li>知道ee吗</li><li>skip-gram和cbow的区别</li><li>skip-gram和cbow哪一个预测速度快</li><li>skip-gram和cbow哪一个对稀疏词效果好</li><li>skip-gram 负采样和分层softmax的时间复杂度各是多少</li><li>multi-head的作用是什么</li><li>self-attention为什么要缩放</li></ol><h1 id="拼多多-推荐算法"><a href="#拼多多-推荐算法" class="headerlink" title="拼多多-推荐算法"></a>拼多多-推荐算法</h1><h2 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h2><p>算法题：Leetcode 82. 删除排序链表中的重复元素 II</p><ol><li>介绍简历上的竞赛</li><li>介绍ANN的召回</li><li>工业界中，排序使用召回的信息会有什么问题</li><li>工业界中，w2v向量做为Embedding层初始化会有什么问题</li><li>比赛分工</li></ol><h2 id="二面-4"><a href="#二面-4" class="headerlink" title="二面"></a>二面</h2><p>算法题：股票一次买入和卖出，求最佳收益和买入卖出点</p><ol><li>介绍竞赛</li><li>介绍研究方向</li><li>如果资源无限，去掉前置的召回阶段，直接进行全量的排序，模型的效果会有什么影响</li><li>深度学习在推荐方面的应用</li></ol><h2 id="三面-3"><a href="#三面-3" class="headerlink" title="三面"></a>三面</h2><ol><li>了解拼多多吗</li><li>为什么想做推荐</li><li>从哪些地方了解的相关知识</li><li>介绍推荐系统</li><li>双塔召回为什么离线索引物品embedding</li><li>概率题：北京一般有雾霾的概率是1/4，有三个同事都说今天有雾霾，但他们说真话的概率为3/4，问今天真的有雾霾的概率是多少。</li></ol><h1 id="哔哩哔哩-广告推荐算法"><a href="#哔哩哔哩-广告推荐算法" class="headerlink" title="哔哩哔哩-广告推荐算法"></a>哔哩哔哩-广告推荐算法</h1><h2 id="一面-4"><a href="#一面-4" class="headerlink" title="一面"></a>一面</h2><p>算法题：leetcode 518. 零钱兑换 II</p><ol><li>介绍多任务工作</li><li>介绍优化器算法，演化进程</li><li>LR有大量的特征交叉，如何做特征筛选</li><li>L1和L2正则化的区别</li><li>神经网络初始化方法</li><li>神经网络都初始化成相同的参数会有什么影响，如何缓解</li><li>粗排是怎么做</li></ol><h2 id="二面-5"><a href="#二面-5" class="headerlink" title="二面"></a>二面</h2><p>问实习，问未来打算</p><h1 id="阿里巴巴-淘特-推荐广告"><a href="#阿里巴巴-淘特-推荐广告" class="headerlink" title="阿里巴巴-淘特-推荐广告"></a>阿里巴巴-淘特-推荐广告</h1><h2 id="一面-5"><a href="#一面-5" class="headerlink" title="一面"></a>一面</h2><ol><li>介绍实习</li><li>端外的转换label怎么得到的</li><li>介绍竞赛</li></ol><h2 id="二面-6"><a href="#二面-6" class="headerlink" title="二面"></a>二面</h2><ol><li>介绍实习</li><li>阿里和字节算法的优缺点</li><li>介绍广告整体的请求背景</li><li>介绍现在推荐的热点，发展方向</li></ol><h1 id="美团-广告推荐算法"><a href="#美团-广告推荐算法" class="headerlink" title="美团-广告推荐算法"></a>美团-广告推荐算法</h1><h2 id="一面-6"><a href="#一面-6" class="headerlink" title="一面"></a>一面</h2><ol><li>介绍实习内容</li><li>多任务的 loss 怎么设计</li><li>有没有考虑辅助任务带偏主任务的情况</li><li>在线指标有哪些</li><li>广告主价值是什么</li><li>多任务更应该关注哪些在线指标</li><li>为什么要下掉ID类特征</li><li>ocpx里的 bid 出价指什么</li><li>过拟合的解决方式</li><li>dropout原理</li><li>广告系统的有哪些模块</li><li>混排流程</li><li>混排在排序侧做还是出价侧做</li><li>广告推荐各个模块用的 point wise，pair wise 还是 list wise（答案不唯一）</li><li>概率题：两个人抛硬币，抛到正面的人获胜，先手抛获胜的概率是多少</li><li>算法题：给定一串数列长度为n（无序），给定子序列长度为k（k&lt;=n）,求出长度为k的子序列，使其数字总和为最大值的所有情况。值域（-无穷，+无穷）,输出为序列元素的idx。数列[1,2,3] k=3 ，输出[0,1,2], k=2 输出[1,2]<br>[1,2,3,3] k=3 输出[1,2,3], k=1 输出[2], [3]</li></ol><h2 id="二面-7"><a href="#二面-7" class="headerlink" title="二面"></a>二面</h2><ol><li>浅拷贝和深拷贝的区别，python里的具体实现</li><li>c++栈和堆的区别</li><li>最大后验和最大似然的区别</li><li>xgboost、lightgbm、GBDT之间的区别</li><li>树的分裂增益是什么</li><li>介绍实习内容</li><li>介绍竞赛</li><li>职业规划</li><li>算法题：数字0和1的矩阵，判断矩阵中的1能否围成一个圈</li></ol><h2 id="三面-4"><a href="#三面-4" class="headerlink" title="三面"></a>三面</h2><ol><li>介绍实习</li><li>多任务中有没有辅助任务带偏主任务的情况</li><li>介绍竞赛</li><li>比赛分工</li><li>和前排方案的差距</li></ol><h1 id="爱奇艺-广告推荐算法"><a href="#爱奇艺-广告推荐算法" class="headerlink" title="爱奇艺-广告推荐算法"></a>爱奇艺-广告推荐算法</h1><h2 id="一面-7"><a href="#一面-7" class="headerlink" title="一面"></a>一面</h2><ol><li>介绍竞赛</li><li>xgboost、lightgbm、GBDT之间的区别</li><li>NN的优化调参思路</li><li>有没有试过BN，效果怎么样</li><li>算法题：Leetcode 5. 最长回文子串</li></ol><h2 id="二面-8"><a href="#二面-8" class="headerlink" title="二面"></a>二面</h2><ol><li>介绍竞赛</li><li>商品的属性 embedding 可以怎么得到</li><li>工业场景下召回的主流做法</li><li>协同过滤和双塔模型各有什么缺点</li><li>召回双塔最后加DNN做交叉，产生的计算复杂度会在哪些方面</li><li>如何解决冷门商品召回</li><li>介绍实习内容</li><li>算法题：Leetcode 142. 环形链表 II</li></ol><h2 id="三面-5"><a href="#三面-5" class="headerlink" title="三面"></a>三面</h2><ol><li>介绍实习</li><li>为什么要做多目标</li><li>业界中多目标怎么做的</li><li>熟悉什么编程语言</li><li>会用 tensorflow 吗</li><li>什么时候毕业</li><li>有哪些 offer</li></ol><h1 id="网易云音乐-推荐算法"><a href="#网易云音乐-推荐算法" class="headerlink" title="网易云音乐-推荐算法"></a>网易云音乐-推荐算法</h1><h2 id="一面-8"><a href="#一面-8" class="headerlink" title="一面"></a>一面</h2><ol><li>聊项目</li><li>如何改进 itemcf 的</li><li>session 截断怎么做的</li><li>ANN 的用户向量表示怎么得到的</li><li>特征工程怎么做的</li><li>算法题：字符串逆序并转换大小写：”Hello Word” 转换为 “wORLD hELLO”</li></ol><h2 id="二面-9"><a href="#二面-9" class="headerlink" title="二面"></a>二面</h2><ol><li>介绍实习</li><li>mmoe和esmm解决的问题是什么</li><li>上面两者的loss函数是什么</li><li>介绍精排模型结构</li><li>DIN和DIEN的区别</li><li>大规模稀疏特征优化器如何选择</li><li>如何缓解模型过拟合</li><li>L1正则和L2正则的区别</li><li>树的分裂方式</li><li>GBDT和随机森林的区别</li></ol><h1 id="快手-社区推荐算法"><a href="#快手-社区推荐算法" class="headerlink" title="快手-社区推荐算法"></a>快手-社区推荐算法</h1><h2 id="一面-9"><a href="#一面-9" class="headerlink" title="一面"></a>一面</h2><ol><li>介绍实习</li><li>精排模型结构</li><li>介绍竞赛</li><li>算法题：浮点数的三次方根</li></ol><h2 id="二面-10"><a href="#二面-10" class="headerlink" title="二面"></a>二面</h2><ol><li>知道哪些字符串匹配算法，介绍一下kmp</li><li>快排算法，是否是稳定的，如何改进成稳定的</li><li>两个骰子根据各自的高斯分布出随机值，随机选取一个骰子摇，得到一个随机数，求他是哪个骰子得到的</li><li>如何求目标函数的最小值</li><li>nn 怎么求导</li><li>rnn 怎么求导</li><li>过拟合的缓解方法</li><li>介绍实习内容</li></ol><h1 id="小红书-社区算法"><a href="#小红书-社区算法" class="headerlink" title="小红书-社区算法"></a>小红书-社区算法</h1><h2 id="一面-10"><a href="#一面-10" class="headerlink" title="一面"></a>一面</h2><p>算法题：leetcode 239. 滑动窗口最大值</p><ol><li>介绍研究内容</li><li>网络表示在工业界的应用现状</li><li>介绍竞赛里如何作的debias</li><li>竞赛过程中哪些地方提升明显</li><li>介绍以下transformer</li><li>如何学习机器学习的</li><li>业界推荐算法下的痛点和热点</li><li>介绍LR</li><li>LR的损失函数为什么是连乘</li><li>介绍AUC的含义</li><li>roc曲线的两个坐标轴分别是什么</li><li>测试集负样本不变，正样本变为一半，auc指标有什么变化</li></ol>]]></content>
        <author>
            <name><![CDATA[LogicJake’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.logicjake.xyz/2021/03/23/2021%E6%8E%A8%E5%B9%BF%E6%90%9C%E6%9A%91%E5%81%87%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</id>
        <title><![CDATA[2021推广搜算法暑假实习面经]]></title>
        <updated>2022-01-29T09:31:17+08:00</updated>
        <link href="https://www.logicjake.xyz/2021/03/23/2021%E6%8E%A8%E5%B9%BF%E6%90%9C%E6%9A%91%E5%81%87%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"/>
        <content type="text/html" src="https://www.logicjake.xyz/2021/03/23/2021%E6%8E%A8%E5%B9%BF%E6%90%9C%E6%9A%91%E5%81%87%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"><![CDATA[<p>过完年以来好像就一直在准备暑假实习的事情，投了不少简历，面试了（和待面试）很多公司，积累了不少面经。虽然面经都在牛客发过，但总信不过把自己的东西放在别人的网站上，这里纯当做个备份吧。</p><h1 id="卡牛科技"><a href="#卡牛科技" class="headerlink" title="卡牛科技"></a>卡牛科技</h1><p>面试流程非常快，基本一天一个流程。面试官和 HR 也很好，主要围绕项目做一些扩展。公司主要算法业务为广告推荐，最近新引入了电商，做商品推荐。实习生可以住公司统一安排的二人间公寓。</p><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ol><li>介绍比赛项目，前排用的什么方案</li><li>机器学习方法和深度学习方法的应用场景</li><li>为什么使用 lightgbm 模型，优缺点</li><li>简述 word2vec 的技巧</li><li>transformer在序列模型中大放异彩，你认为他和传统的rnn模型相比强在哪里？</li><li>工程实践问题，项目中类别分布不平衡怎么办，负样本多怎么办</li><li>如果使用了下采样破坏了真实分布，如何在上线之后将预测的概率拉回真实的分布</li></ol><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><ol><li>介绍比赛流程</li><li>对冷门商品的解决方法</li><li>如何保证召回的多样性</li><li>如何推荐新上架商品</li><li>模型推荐购买过的商品怎么处理</li><li>lightgbm 与 xgboost 区别</li><li>广告反欺诈中如果给 GPS 信息怎么处理</li></ol><h1 id="蚂蚁金服—支付宝—广告算法"><a href="#蚂蚁金服—支付宝—广告算法" class="headerlink" title="蚂蚁金服—支付宝—广告算法"></a>蚂蚁金服—支付宝—广告算法</h1><p>阿里好多部门在过完年之后就开始在各大群里发 jd，声势十分浩大。群里有人发了支付宝部门的 jd，说是有学长直推，而且方向和我很匹配，就去联系了一下学长，学长很 nice，帮我改简历，提了很多建议。阿里支持预先面，也是我第一次大厂面试，总共两轮技术面，本来有的交叉面被取消了。</p><h2 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h2><ol><li>映象比较深刻的比赛</li><li>在 kdd cup 竞赛中负责内容</li><li>介绍改进的itemcf</li><li>用户 embedding 和商品 embedding 不在一个特征空间，怎么计算相似性</li><li>有没有考虑把用户和商品的关系建为异构图</li><li>后处理如何打压热门商品</li><li>介绍 kdd cup 第一名的方案</li><li>介绍竞赛广告反欺诈的比赛</li></ol><h2 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h2><p>二面应该是个领导，约的会议室快到时间了，所以问的比较简单，了解了一下竞赛项目和到岗时间就没了。</p><h1 id="字节跳动—商业变现—广告算法"><a href="#字节跳动—商业变现—广告算法" class="headerlink" title="字节跳动—商业变现—广告算法"></a>字节跳动—商业变现—广告算法</h1><p>本来想把字节放在后面投的，所以只在系统里填了简历，没有投岗位，但 HR 加微信问我要不要试试他们部门，所以就阴差阳错开始了，总共三轮技术面。</p><h2 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h2><p>算法题：leetcode 排序矩阵查找，leetcode 102 二叉树的层序遍历</p><ol><li>介绍一个你认为做的最好的比赛</li><li>ANN用的什么工具，介绍一下原理</li><li>为什么选择Annoy</li><li>还知道其他ANN算法吗？介绍了一下局部敏感hash</li><li>做用户商品交互特征的时候，你知道业界是怎么做的？扯了一下DIN模型的和目标商品的attention做法</li><li>lightgbm和xgboost的区别</li><li>排序阶段你知道业界是怎么做的？说了一下点击率模型：deepfm，nfm，wide &amp; deep，dcn，deepcrossing</li><li>介绍一下word2vec</li><li>介绍一下transformer</li><li>bert的两种预训练方式</li><li>为什么要用mask？说了padding mask和sequence mask</li><li>为什么要sequence mask？防止信息穿越</li></ol><h2 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h2><p>算法题：求从左上角到右下角的最小开销。给定一个二维数组arr[i][j]，数组中每个点表示经过该点的开销，求从左上角为起点，右下角为终点的最小开销，在每个点时只能往右或者往下走，同时中途可能会有障碍，即有些点不能走，obs[i][j]=1时表示(i, j)不能走。dp和dp状态压缩。</p><ol><li>介绍一个比赛</li><li>ANN用的什么工具，介绍一下原理</li><li>如何提高冷门商品的推荐效果的</li><li>了不了解大数据框架</li><li>说一下你熟悉的linux命令</li><li>一个文件每行一个数字，用命令统计所有数的平均值和数字个数</li><li>逻辑回归损失函数和求导</li><li>介绍一下你了解的优化器和各自的优缺点</li><li>Adam和Adagrad的区别</li></ol><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>算法题：有一个长度为n的数组，求一个数k，k的取值区间为[1, n-1]，使得数组的前k个数和后n-k个数的方差和最小。要求化简方差公式，达到计算子序列方差的时间复杂度为O(n)。解出来后又要求空间复杂度为常数级别。</p><ol><li>写逻辑回归的logloss损失函数</li><li>逻辑回归损失函数可以用mse吗（从梯度角度）</li><li>逻辑回归建模，如果只有9个正样本，一个负样本，那么有一列特征，这个特征对于的权重是正还是负  </li><li>介绍认为做的最好的项目</li><li>项目中如何缓解曝光偏差的</li><li>Embedding ANN召回用的什么工具</li></ol><h1 id="快手-社区科学部-推荐算法"><a href="#快手-社区科学部-推荐算法" class="headerlink" title="快手-社区科学部-推荐算法"></a>快手-社区科学部-推荐算法</h1><p>快手是先统一面试，技术面结束后，HR 联系才知道具体的小组。快手的面试风格感觉和字节很像，先做两道算法题。一面先做题，第二题卡了好久才做完，所以剩下的时间不多，面试官也没多问，就简单了解了一下竞赛项目。二面也是先做题，基础问的不多，也问到了“逻辑回归损失函数可以用mse吗”，大部分时间都在和我讨论 kdd cup 的项目流程是否合理和为什么要这么做。快手总共两轮技术面，隔了大概两周才有 HR 沟通后续。</p><h1 id="腾讯-应用宝-推荐算法"><a href="#腾讯-应用宝-推荐算法" class="headerlink" title="腾讯-应用宝-推荐算法"></a>腾讯-应用宝-推荐算法</h1><p>投的腾讯微视，被应用宝捞了。</p><h2 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h2><ol><li>介绍一个最有把握的比赛</li><li>介绍比赛中itemcf具体做法</li><li>在itemcf中如何引入时间间隔信息和位置间隔信息</li><li>基于商品属性embedding的召回这么做的</li><li>Annoy的原理</li><li>基于w2v的ANN怎么做的</li><li>w2v的原理</li><li>w2v的loss函数</li><li>loss函数还有哪些</li><li>如何解决冷启动问题</li><li>如何评价召回的效果</li><li>如何把召回的信息引入到排序</li><li>GBDT，xgboost，lightgbm改进的过程</li><li>简单推导xgboost</li><li>构建一棵树分裂特征怎么选择</li><li>计算分裂增益的方法有哪些</li><li>LSTM的门机制</li><li>LSTM相较于RNN的优势</li><li>transformer的机制</li><li>推荐里面深度模型的了解</li><li>NN怎么达到泛化性</li><li>如何保证的稀疏性</li><li>L1正则为什么可以达到模型的稀疏性</li></ol><h2 id="二面-3"><a href="#二面-3" class="headerlink" title="二面"></a>二面</h2><ol><li>比赛分工</li><li>embedding存在之前没有出现过id怎么办</li><li>w2v的样本怎么构造</li><li>有没有过滤低频id</li><li>cbow 与 skip-gram 的区别和优缺点</li><li>多任务学习有哪些结构</li><li>多个召回怎么合并的</li><li>多个召回分数之间是可比的吗</li><li>各个召回的权重是怎么选取的</li><li>推荐系统里面是如何考虑冷门商品</li><li>新增一路召回，在排序阶段需要做什么改进</li><li>树模型对离散特征怎么处理的</li><li>树模型怎么决定一个叶子结点是否要分裂</li><li>xgboost正则化项和什么有关</li></ol><h2 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h2><p>做了三道算法题：leetcode 53.最大子序和，leetcode 75.颜色分类，leetcode 442.数组中重复的数据</p><h2 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h2><ol><li>介绍项目</li><li>算法题：剑指 Offer 60.n个骰子的点数</li></ol><h1 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h1><p>应该是百度的实习专场，三轮技术连着面。</p><h2 id="一面-4"><a href="#一面-4" class="headerlink" title="一面"></a>一面</h2><p>算法题：leetcode 70.爬楼梯</p><ol><li>介绍竞赛项目</li><li>竞赛数据规模</li><li>ANN中用户的embedding怎么得到的</li><li>w2v的召回具体怎么做的</li><li>ANN的工具用的啥</li><li>基于深度的召回怎么做的</li><li>排序阶段的特征有哪些</li><li>后打压怎么做的</li></ol><h2 id="二面-4"><a href="#二面-4" class="headerlink" title="二面"></a>二面</h2><p>算法题：假设现在有很多海岛，有些海岛之间有桥连接，你已知海岛连接情况。 ① 我现在想从到 A岛 去 B岛，问是否能通过陆路到达（过桥） ②如果可以，最少需要过几次桥 ③输出一条最短的路径 （P.S. 最好可以写一个非递归的形式）</p><ol><li>介绍竞赛</li><li>评估标准是啥</li><li>哪些特征比较有用</li><li>多路召回的分数为什么要相加</li><li>有没有分析 bad case</li><li>优化思路</li><li>讲一下推荐的方法</li><li>一个全连接层有多少参数</li><li>介绍 attention</li></ol><h2 id="三面（手百搜索部门）"><a href="#三面（手百搜索部门）" class="headerlink" title="三面（手百搜索部门）"></a>三面（手百搜索部门）</h2><ol><li>介绍研究方向</li><li>论文中 embedding 效果的评价方法和指标</li><li>为什么选择数据挖掘这个方向</li><li>对于实习的目标</li><li>反问部门业务和技术栈</li></ol><h1 id="美团-外卖-搜索算法"><a href="#美团-外卖-搜索算法" class="headerlink" title="美团-外卖-搜索算法"></a>美团-外卖-搜索算法</h1><h2 id="一面-5"><a href="#一面-5" class="headerlink" title="一面"></a>一面</h2><ol><li>介绍竞赛</li><li>工程挑战有哪些</li><li>介绍transformer</li><li>介绍self-attention</li><li>算法题：Leetcode 8. 字符串转换整数 (atoi)，考虑科学计数法</li></ol><h2 id="二面-5"><a href="#二面-5" class="headerlink" title="二面"></a>二面</h2><p>算法题：合并两个有序数组并去重</p><ol><li>介绍竞赛</li><li>如何提高冷门商品的推荐效果</li><li>为什么能缓解冷门商品的召回</li><li>怎么评价冷门商品的推荐效果</li><li>排序特征如何对冷门商品做倾向的</li><li>根据点击次数提权，整体效果会下降吗</li><li>如何平衡全量商品和冷门商品的指标</li><li>如何使用点击序列的</li><li>为什么使用lightgbm</li><li>lightgbm，xgboost的原理</li><li>如何训练embedding</li><li>概率题：有两个无限大且不透明的箱子，100个白球和100个黑球。100个白球和100个黑球可以任意放置在两个箱子里，求能摸到黑球的最大概率</li></ol><h1 id="拼多多-搜索广告算法"><a href="#拼多多-搜索广告算法" class="headerlink" title="拼多多-搜索广告算法"></a>拼多多-搜索广告算法</h1><h2 id="一面-6"><a href="#一面-6" class="headerlink" title="一面"></a>一面</h2><p>算法题：leetcode 687. 最长同值路径</p><ol><li>介绍竞赛</li><li>itemcf 的改进点</li><li>如何提高冷门商品的推荐效果</li><li>基于深度学习的召回怎么做的</li><li>现在来看，方案有哪些改进的点</li></ol><h2 id="二面-6"><a href="#二面-6" class="headerlink" title="二面"></a>二面</h2><p>算法题：leetcode 322. 零钱兑换</p><ol><li>介绍竞赛</li><li>对稀疏特征有没有做什么处理</li><li>介绍基于商品属性的向量召回</li><li>哪一种召回效果最好</li><li>itemcf 如何改进的</li><li>介绍学校研究方向</li></ol><h2 id="三面-2"><a href="#三面-2" class="headerlink" title="三面"></a>三面</h2><ol><li>介绍竞赛</li><li>数据规模</li><li>如何提高冷门商品的推荐效果</li><li>介绍比赛的指标</li><li>排序任务为什么要建模为二分类</li><li>为什么不直接排序而需要先召回</li><li>如何构造分类样本</li><li>有没有了解前排方案</li></ol>]]></content>
        <author>
            <name><![CDATA[LogicJake’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.triplez.cn/posts/chaosblade-specific-cpu-load/</id>
        <title><![CDATA[chaosblade 生成指定 CPU 利用率负载的原理]]></title>
        <updated>2022-01-26T14:21:45+08:00</updated>
        <link href="https://blog.triplez.cn/posts/chaosblade-specific-cpu-load/"/>
        <content type="text/html" src="https://blog.triplez.cn/posts/chaosblade-specific-cpu-load/"><![CDATA[<p>最近笔者在做的一个降级功能，与机器资源情况密切相关。然而在测试时发现控制 CPU 利用率来构造测试条件，并不是一个容易的事情。借助时间片的思想，笔者用一个非常简单的 shell 一定程度上解决了这个问题。但转念一想，对于混沌测试的软件，这应该是个必备能力。查找了一下 chaosblade 的相关资料，果然支持生成指定 CPU 利用率的负载。故读了读其这部分源码，看看它是怎么实现的。</p>
<p>使用 <code>chaosblade</code> 来构造指定 CPU 利用率的负载非常简单：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">blade create cpu load --cpu-percent <span class="m">80</span>
</span></span></code></pre></div><p>即能够生成使 CPU 利用率到达 80% 的负载。</p>
<p><code>burncpu</code> 的核心逻辑位于这里： <a href="https://github.com/chaosblade-io/chaosblade-exec-os/blob/318c52d83a851bc75012abc7d880d4f440f1f972/exec/bin/burncpu/burncpu.go#L140-L168">https://github.com/chaosblade-io/chaosblade-exec-os/blob/318c52d83a851bc75012abc7d880d4f440f1f972/exec/bin/burncpu/burncpu.go#L140-L168</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">burnCpu</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">cpuCount</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">totalCpuPercent</span> <span class="p">[]</span><span class="kt">float64</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">curProcess</span> <span class="o">*</span><span class="nx">process</span><span class="p">.</span><span class="nx">Process</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">curCpuPercent</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">totalCpuPercent</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cpu</span><span class="p">.</span><span class="nf">Percent</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>  <span class="c1">// 获取当前所有 CPU 一秒内平均利用率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">curProcess</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">process</span><span class="p">.</span><span class="nf">NewProcess</span><span class="p">(</span><span class="nb">int32</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nf">Getpid</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">curCpuPercent</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">curProcess</span><span class="p">.</span><span class="nf">CPUPercent</span><span class="p">()</span>  <span class="c1">// 获取当前进程的 CPU 利用率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">otherCpuPercent</span> <span class="o">:=</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">-</span> <span class="p">(</span><span class="nx">totalCpuPercent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">curCpuPercent</span><span class="p">))</span> <span class="o">/</span> <span class="mf">100.0</span>  <span class="c1">// 除去已有进程，可操作的 CPU 利用率。值的范围为 [0, 1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// timer 3s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">t</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">totalCpuPercent</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">cpu</span><span class="p">.</span><span class="nf">Percent</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">curCpuPercent</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">curProcess</span><span class="p">.</span><span class="nf">CPUPercent</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">otherCpuPercent</span> <span class="p">=</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">-</span> <span class="p">(</span><span class="nx">totalCpuPercent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">curCpuPercent</span><span class="p">))</span> <span class="o">/</span> <span class="mf">100.0</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>  <span class="c1">// 每 3s 更新一次 totalCpuPercent, curCpuPercent 和 otherCpuPercent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">climbTime</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>  <span class="c1">// 不需要爬坡时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">slopePercent</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">cpuPercent</span><span class="p">)</span>  <span class="c1">// 爬坡值与目标值一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// cpuCount 是由 runtime.NumCPU() 得来，获取的是当前 CPU 的逻辑核数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">cpuCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">busy</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">idle</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">all</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">10000000</span><span class="p">)</span>    <span class="c1">// 设定 10ms 为一个周期
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">dx</span> <span class="o">:=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ds</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">=</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">1000</span> <span class="p">{</span>  <span class="c1">// 死循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">startTime</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>  <span class="c1">// 每 1000 次进入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 这个赋值语句是整个 burncpu 的灵魂。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 我们最终希望获得的是 slopePercent% 的 CPU 利用率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 应该生成的 CPU 压力即为 (slopePercent - totalCpuPercent[0])%
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 理想条件下，我们只需对 (slopePercent - totalCpuPercent[0]) 个 0.1ms 时间片设置为 busy 状态即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 但由于系统中存在其他进程，burncpu 无法真正获得到 (slopePercent - totalCpuPercent[0]) 个 0.1ms 时间片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 因此需要按比例放大时间片的个数，而这个比例则是当时 burncpu 实际可用的 CPU 利用率
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 将这个赋值语句转换为如下方程，则更好理解了：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">//   slopePercent  = totalCpuPercent + dx * otherCpuPercent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">//       ^                 ^           ^                 ^
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 最终获得的CPU利用率 当前CPU利用率 一个周期内busy的时间片个数 burnCpu真正可操作的CPU比例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">dx</span> <span class="p">=</span> <span class="p">(</span><span class="nx">slopePercent</span> <span class="o">-</span> <span class="nx">totalCpuPercent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="nx">otherCpuPercent</span>
</span></span><span class="line"><span class="cl">					<span class="nx">busy</span> <span class="p">=</span> <span class="nx">busy</span> <span class="o">+</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">dx</span><span class="o">*</span><span class="mi">100000</span><span class="p">)</span>  <span class="c1">// 有 dx 个 0.1ms 需要为 busy 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="k">if</span> <span class="nx">busy</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="nx">busy</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">					<span class="nx">idle</span> <span class="p">=</span> <span class="nx">all</span> <span class="o">-</span> <span class="nx">busy</span>
</span></span><span class="line"><span class="cl">					<span class="k">if</span> <span class="nx">idle</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="nx">idle</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">					<span class="nx">ds</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">ParseDuration</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nx">idle</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;ns&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">for</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">()</span><span class="o">-</span><span class="nx">startTime</span> <span class="p">&lt;</span> <span class="nx">busy</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>  <span class="c1">// 阻塞 CPU，使 CPU 位于 busy 状态，直至设定的时间片结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">ds</span><span class="p">)</span> <span class="c1">// 空闲 CPU，使 CPU 处于 idle 状态，直至设定的时间片结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">runtime</span><span class="p">.</span><span class="nf">Gosched</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">select</span> <span class="p">{}</span>  <span class="c1">// 阻塞 burnCpu 函数，保活 goroutines
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div>]]></content>
        <author>
            <name><![CDATA[TripleZ’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.triplez.cn/posts/lexer-parser-toolchain/</id>
        <title><![CDATA[Lexer & Parser Toolchain]]></title>
        <updated>2022-01-25T13:29:19+08:00</updated>
        <link href="https://blog.triplez.cn/posts/lexer-parser-toolchain/"/>
        <content type="text/html" src="https://blog.triplez.cn/posts/lexer-parser-toolchain/"><![CDATA[<blockquote>
<p>推荐一个非常好的编译器工具链入门教程： <a href="https://pandolia.net/tinyc/index.html">https://pandolia.net/tinyc/index.html</a></p>
</blockquote>
<h2 id="lexer---flex">Lexer - flex</h2>
<p>flex 文件格式：</p>
<blockquote>
<p><a href="https://pandolia.net/tinyc/ch8_flex.html">https://pandolia.net/tinyc/ch8_flex.html</a></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">%{
</span></span><span class="line"><span class="cl">Declarations
</span></span><span class="line"><span class="cl">%}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Definitions
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">Rules
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">User subroutines
</span></span></code></pre></div><ul>
<li>
<p>Declarations：声明，会被原样复制入 <code>lex.yy.c</code> 。一般用于声明全局变量和函数。</p>
</li>
<li>
<p>Definitions：定义，可以定义正则表达式的名字，用于 Rules 中使用，通过名字直接使用预定义的正则表达式。</p>
</li>
<li>
<p>Rules：规则，每一行都是一条规则，由匹配模式 pattern （正则表达式）和事件 action （C 代码）组成。</p>
</li>
<li>
<p>User subroutines：用户定义过程，会被原样复制到 <code>lex.yy.c</code> 的最末尾。</p>
</li>
<li>
<p><code>yywrap()</code> 用于把多个输入文件打包成一个输入，当 <code>yylex</code> 将一个文件读入到结尾 EOF 时，会向 <code>yywrap</code> 询问是否继续。若需连续解析多个文件，需要在 yywrap 中打开文件，并返回 0。返回 1 则表示后面没有文件可以读取了，使得 <code>yylex</code> 函数结束。</p>
</li>
<li>
<p><code>yytext</code>：刚刚匹配到的字符串的值。</p>
</li>
<li>
<p><code>yyleng</code>：刚刚匹配到的字符串的长度。</p>
</li>
</ul>
<p>如一个简单的计算器实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">%{
</span></span><span class="line"><span class="cl">#include &#34;y.tab.h&#34;
</span></span><span class="line"><span class="cl">%}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">[0-9]+          { yylval = atoi(yytext); return T_NUM; }
</span></span><span class="line"><span class="cl">[-/+*()\n]      { return yytext[0]; }
</span></span><span class="line"><span class="cl">.               { return 0; /* end when meet everything else */ }
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int yywrap(void) { 
</span></span><span class="line"><span class="cl">    return 1;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><h2 id="parser---yaccbison">Parser - Yacc/Bison</h2>
<p>bison 可以认为是 yacc 的开源实现。</p>
<p>Bison 文件的格式：</p>
<blockquote>
<p><a href="https://pandolia.net/tinyc/ch13_bison.html">https://pandolia.net/tinyc/ch13_bison.html</a></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">%{
</span></span><span class="line"><span class="cl">Declarations
</span></span><span class="line"><span class="cl">%}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Definitions
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">Productions
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">User subroutines
</span></span></code></pre></div><ul>
<li>
<p>Declarations：声明，会被原样复制入 <code>y.tab.c</code> 。一般用于声明全局变量和函数。</p>
</li>
<li>
<p>Definitions：定义，可以定义 bison 专有的变量。</p>
<ul>
<li><code>%token</code>：单字符 token （token type 值与字符的 ASCII 码相同）不需要使用 <code>%token</code> 进行预定义，其他类型的 token 都需要使用 <code>%token</code> 进行预定义。bison 会自动为 token 分配一个编号，并写入 <code>y.tab.h</code> 中，因此在 flex 文件中是可以直接调用的。</li>
<li><code>%left</code> 、<code>%right</code>：表示符号是左（左向右）、右（右向左）结合的。</li>
<li><code>%nonassoc</code> ：表示符号是不可结合的，如 <code>x op y op z</code> 是非法的。</li>
<li><code>%prec</code>：上下文依赖的优先级，如「负号」就是一个很典型的例子，见 <a href="https://www.gnu.org/software/bison/manual/html_node/Contextual-Precedence.html">Context-Dependent Precedence</a>。</li>
<li>更多定义可见 <a href="https://www.gnu.org/software/bison/manual/html_node/Declarations.html">bison Declarations</a>。</li>
</ul>
</li>
<li>
<p>Productions：</p>
<ul>
<li>
<p><code>:</code> 代表 <code>-&gt;</code>，或 EBNF 式中的 <code>=</code>。</p>
</li>
<li>
<p><code>|</code> 用于分隔同一个非终结符的不同产生式。</p>
</li>
<li>
<p><code>/* empty */</code> ，若产生式右边为 $\epsilon$ 时，不需要写任何符号，可写为注释 <code>/* empty */</code>。</p>
</li>
<li>
<p><code>;</code> 表示结束一个非终结符的产生式。</p>
</li>
<li>
<p>每个产生式后面花括号内，都是一段 C 代码，可在产生式被应用时执行。</p>
</li>
<li>
<p>例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">s : S E &#39;\n&#39;       { printf(&#34;ans = %d\n&#34;, $2); }
</span></span><span class="line"><span class="cl">  | /* empty */    { /* empty */}
</span></span><span class="line"><span class="cl">  ;
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>User subroutines：用户定义过程，会被原样复制到 <code>y.tab.c</code> 的最末尾。</p>
</li>
</ul>
<p>bison 会将语法产生式以及符号优先级转换成一个 C 语言的 LALR(1) 动作表，输出到 <code>y.tab.c</code> 中。并会将这个动作表转换为可读形式输出至 <code>y.output</code> 中。</p>
<p>bison 会根据自定义语法文件在 <code>y.tab.c</code> 中生成一个函数 <code>int yyparse(void)</code> 。这个函数按照 LR(1) 解析流程，对词法分析中得到的 token 流进行解析。每当读取下一个符号时，就会执行一次 <code>x = yylex()</code> 。每当要执行一个折叠动作（reduce）时，相应的产生式后的 C 代码将被执行，执行完后将相应的状态出栈。</p>
<p>若 token 流不合法，<code>yyparse</code> 会在第一次出错的地方终止，并调用 <code>yyerror</code> 函数，最后返回 1。</p>
<p>在 reduce 动作时，可用 <code>$1</code>, <code>$2</code> &hellip; <code>$n</code> 来引用属性栈的属性（可以认为是产生式中的第 n 个属性内容，并在最后将这个状态下的属性出栈。其中，<code>$$</code> 代表产生式左侧的终结符，可在 reduce 动作设置 <code>$$</code> 的值，最后将 <code>$$</code> 入栈。</p>
<p>如一个简单的计算器实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">%{
</span></span><span class="line"><span class="cl">#include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">void yyerror(const char* msg) {}
</span></span><span class="line"><span class="cl">int yylex();
</span></span><span class="line"><span class="cl">%}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%token T_NUM
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%left &#39;+&#39; &#39;-&#39;
</span></span><span class="line"><span class="cl">%left &#39;*&#39; &#39;/&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">S   :   S E &#39;\n&#39;        { printf(&#34;ans = %d\n&#34;, $2); }
</span></span><span class="line"><span class="cl">    |   /* empty */     { /* empty */ }
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">E   :   E &#39;+&#39; E         { $$ = $1 + $3; }
</span></span><span class="line"><span class="cl">    |   E &#39;-&#39; E         { $$ = $1 - $3; }
</span></span><span class="line"><span class="cl">    |   E &#39;*&#39; E         { $$ = $1 * $3; }
</span></span><span class="line"><span class="cl">    |   E &#39;/&#39; E         { $$ = $1 / $3; }
</span></span><span class="line"><span class="cl">    |   T_NUM           { $$ = $1; }
</span></span><span class="line"><span class="cl">    |   &#39;(&#39; E &#39;)&#39;       { $$ = $2; }
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main() {
</span></span><span class="line"><span class="cl">    return yyparse();
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div>]]></content>
        <author>
            <name><![CDATA[TripleZ’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.zeddyu.info/2022/01/08/2022-01-08-TheEndOfLFI/</id>
        <title><![CDATA[hxp CTF 2021 - The End Of LFI?]]></title>
        <updated>2022-01-08T09:44:57+08:00</updated>
        <link href="https://blog.zeddyu.info/2022/01/08/2022-01-08-TheEndOfLFI/"/>
        <content type="text/html" src="https://blog.zeddyu.info/2022/01/08/2022-01-08-TheEndOfLFI/"><![CDATA[<p>[TOC]</p>
<p>接上回 hxp CTF 的题目，本文介绍一下之前 counter 题目的 LFI 解法，以及令人极其赞叹的 LFI 新技巧，可以说是 The End Of LFI 了。</p>]]></content>
        <author>
            <name><![CDATA[Zedd’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.zeddyu.info/2021/12/27/2021-12-20-ANewNovelLFI/</id>
        <title><![CDATA[hxp CTF 2021 - A New Novel LFI]]></title>
        <updated>2021-12-27T07:32:24+08:00</updated>
        <link href="https://blog.zeddyu.info/2021/12/27/2021-12-20-ANewNovelLFI/"/>
        <content type="text/html" src="https://blog.zeddyu.info/2021/12/27/2021-12-20-ANewNovelLFI/"><![CDATA[<p>上周参与了 hxp CTF ，其中有两个 PHP Web 题目令人印象深刻，也产生了一种让我拍手称快的、对我来说算是新的 LFI 方法，这里就将本次比赛题目分析写一下。当然我不确定这个是不是新方法，若有错误，希望各位师傅们斧正，多多海涵</p>]]></content>
        <author>
            <name><![CDATA[Zedd’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.triplez.cn/posts/grub-rescue-oops/</id>
        <title><![CDATA[grub rescue>,  Oops!]]></title>
        <updated>2021-11-28T13:56:16+08:00</updated>
        <link href="https://blog.triplez.cn/posts/grub-rescue-oops/"/>
        <content type="text/html" src="https://blog.triplez.cn/posts/grub-rescue-oops/"><![CDATA[<p>教你如何修复丢失的 Linux GRUB 启动引导。</p>
<h2 id="起因">起因</h2>
<p>为了再将神船 Z7 用起来，笔者决定扩展其仅有 200GB 的游戏分区空间。然而由于可用空间的位置并不连续，Windows 自带磁盘工具无法处理这种情况，且笔者并不希望将分区转为动态分区，因此使用了一个第三方软件 <a href="https://www.easeus.com/partition-manager/epm-free.html">EaseUS Partition Master Free</a> 来完成磁盘数据的迁移和分区重分配工作。就在设置好分区，重启了之后，屏幕上赫然显示着一个命令行界面：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">error: unknown filesystem.
</span></span><span class="line"><span class="cl">Entering rescue mode...
</span></span><span class="line"><span class="cl">grub rescue&gt; 
</span></span></code></pre></div><p>Oops！难道重新分个区就把系统搞挂了吗？！<code>grub rescue&gt;</code> 这个命令行界面在我心中一直是噩梦般的存在，之前遇到都只能选择计算机三大法宝之一：重装来解决问题。</p>
<p>既然双系统里的 Linux 进不去了，那我试试直接进 Windows？于是重启了一下机器，通过 BIOS 直接进入了系统盘位于 SSD 中的 Windows。好家伙，这能正常启动，那问题就不大了。</p>
<p>Windows 磁盘分区的重分配工作得到了验证，看上去非常完美。笔者用于存储游戏的专用分区已经扩容至 ~450GB ，那接下来还是修复下 Linux 启动引导的问题吧。</p>
<p>经过一番简单的搜索，笔者摸清了其中大概的原因：在进行 Windows 磁盘操作时，对整个 HDD 做了分区、合并等处理，导致 GPT 元数据发生了改变，Linux 的引导程序 GRUB 自然就无法找到之前的 <code>/boot</code> 启动分区了，这也是报出 <code>error: unknown filesystem</code> 的原因。</p>
<h2 id="在-grub-rescue-中修复启动项">在 grub rescue 中修复启动项</h2>
<p>由于是硬盘元数据发生了改变导致 GRUB 失效，那我们的思路就是更新 GRUB 中的配置。</p>
<p>首先要找到目前 Linux 的 <code>/boot</code> 启动分区的位置，在 <code>grub rescue</code> 中，可以用 <code>ls</code> 来寻找：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">grub rescue&gt; ls
</span></span><span class="line"><span class="cl"><span class="o">(</span>hd0<span class="o">)</span> <span class="o">(</span>hd0,gpt7<span class="o">)</span> <span class="o">(</span>hd0,gpt6<span class="o">)</span> <span class="o">(</span>hd0,gpt5<span class="o">)</span> <span class="o">(</span>hd0,gpt4<span class="o">)</span> <span class="o">(</span>hd0,gpt3<span class="o">)</span> <span class="o">(</span>hd0,gpt2<span class="o">)</span> <span class="o">(</span>hd0,gpt1<span class="o">)</span> <span class="o">(</span>hd1<span class="o">)</span> <span class="o">(</span>hd1,gpt3<span class="o">)</span> <span class="o">(</span>hd1,gpt2<span class="o">)</span> <span class="o">(</span>hd1,gpt1<span class="o">)</span>
</span></span></code></pre></div><p>直接输入 <code>ls</code> ，即可得到所有的分区位置。但是启动分区到底是哪个呢？我们可以继续用 <code>ls</code> 来查找，先试试 <code>(hd0,gpt1)</code> 这个分区吧。</p>
<blockquote>
<p>此处要注意的是，我们要查找的是 <code>/boot/grub</code> 这个文件夹目录存在的分区。由于笔者的 <code>/boot</code> 启动分区是单独挂载的，所以查找的路径是 <code>&lt;partition&gt;/grub</code> 。若安装的 Linux 并没有单独挂载 <code>/boot</code> 启动分区，则查找路径应为 <code>&lt;partition&gt;/boot/grub</code>。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">grub rescue&gt; ls <span class="o">(</span>hd0,gpt1<span class="o">)</span>/grub
</span></span><span class="line"><span class="cl">error: unknown filesystem.
</span></span></code></pre></div><p>输出为 <code>error: unknown filesystem.</code> ，说明这个分区并不是我们想要的启动分区，那再试试下一个分区。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">grub rescue&gt; ls <span class="o">(</span>hd0,gpt2<span class="o">)</span>/grub
</span></span><span class="line"><span class="cl">./ ../ x86_64-efi/ grubenv themes/ fonts/ grub.cfg
</span></span></code></pre></div><p>Bingo！这就是我们要找的东西丫！好，记下这个分区 <code>(hd0,gpt2)</code>，它就是我们宝贵的启动分区。</p>
<p>接下来就是给 GRUB 修改启动配置，只要改两个参数即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">grub rescue&gt; <span class="nb">set</span> <span class="nv">root</span><span class="o">=(</span>hd0,gpt2<span class="o">)</span>
</span></span><span class="line"><span class="cl">grub rescue&gt; <span class="nb">set</span> <span class="nv">prefix</span><span class="o">=(</span>hd0,gpt2<span class="o">)</span>/grub
</span></span></code></pre></div><ul>
<li>将 <code>root</code> 设置为启动分区。</li>
<li>将 <code>prefix</code> 设置为 <code>grub</code> 安装文件夹。若 <code>/boot</code> 未挂载单独分区，也可能为 <code>&lt;partition&gt;/boot/grub</code>。</li>
</ul>
<p>配置也修改好了之后，重新使 GRUB 进入普通模式就可以找回我们的启动项了！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">grub rescue&gt; insmod normal
</span></span><span class="line"><span class="cl">grub rescue&gt; normal
</span></span></code></pre></div><p>执行完后，应该能看到我们熟悉的 GRUB 引导界面了。</p>
<h2 id="持久化">持久化</h2>
<p>事实上，这样的修复只是暂时的，我们还需要对 GRUB 配置进行持久化的更新，否则每次开机都要这样操作一遍。</p>
<p>进入 Linux，打开终端，输入如下命令，GRUB 就会自动更新配置。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ sudo update-grub
</span></span><span class="line"><span class="cl">$ sudo grub-install /dev/sda
</span></span></code></pre></div><p><code>/dev/sda</code> 为 Linux 的安装磁盘。</p>
<p>可以再重启一次计算机，验证 Linux 启动引导是否修复成功。</p>
<h2 id="references">References</h2>
<ul>
<li>Repair Linux boot failures in GRUB 2 rescue mode</br>
<a href="https://www.howtoforge.com/tutorial/repair-linux-boot-with-grub-rescue/">https://www.howtoforge.com/tutorial/repair-linux-boot-with-grub-rescue/</a></li>
<li>grub rescue 救援模式的处理</br>
<a href="http://xstarcd.github.io/wiki/Linux/grub_rescue.html">http://xstarcd.github.io/wiki/Linux/grub_rescue.html</a></li>
<li>Linux 系统引导失败，出现 grub rescue 恢复界面 - 少数派</br>
<a href="https://sspai.com/post/55875">https://sspai.com/post/55875</a></li>
</ul>]]></content>
        <author>
            <name><![CDATA[TripleZ’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.zeddyu.info/2021/09/30/2021-09-30-FromHexoToHugo/</id>
        <title><![CDATA[从 Hexo 搬迁至 Hugo]]></title>
        <updated>2021-09-29T17:15:01+08:00</updated>
        <link href="https://blog.zeddyu.info/2021/09/30/2021-09-30-FromHexoToHugo/"/>
        <content type="text/html" src="https://blog.zeddyu.info/2021/09/30/2021-09-30-FromHexoToHugo/"><![CDATA[<p>由于之前突发奇想，看到某些同学的博客确实好看，心血来潮便花了大概几个晚上把博客生成工具从原来的 Hexo 迁移到了 Hugo 上，便有了这次搬迁记录，也算是给其他想迁移小伙伴一个参考。</p>]]></content>
        <author>
            <name><![CDATA[Zedd’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.stdioa.com/2021/09/homelab-share/</id>
        <title><![CDATA[HomeLab 玩法简单分享]]></title>
        <updated>2021-09-16T06:41:52+08:00</updated>
        <link href="https://blog.stdioa.com/2021/09/homelab-share/"/>
        <content type="text/html" src="https://blog.stdioa.com/2021/09/homelab-share/"><![CDATA[<p>大学毕业之前一个冲动买了台式机，又一个冲动买了台 Linux 主机。到现在它已经运行了四年多了，简单分享下自己的玩法。</p>]]></content>
        <author>
            <name><![CDATA[Stdio’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.stdioa.com/2021/07/scrape-prometheus-metrics-outside-kubernetes/</id>
        <title><![CDATA[在 K3S 集群外监控集群内的指标]]></title>
        <updated>2021-07-11T11:58:14+08:00</updated>
        <link href="https://blog.stdioa.com/2021/07/scrape-prometheus-metrics-outside-kubernetes/"/>
        <content type="text/html" src="https://blog.stdioa.com/2021/07/scrape-prometheus-metrics-outside-kubernetes/"><![CDATA[<p><s>吃饱了撑的</s>，尝试一下 Prometheus 在 K3S 集群外抓取集群内指标的若干姿势。</p>]]></content>
        <author>
            <name><![CDATA[Stdio’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>http://blog.qrzbing.cn/post/2021-ciscn-little-evil/</id>
        <title><![CDATA[CISCN 2021 Little Evil]]></title>
        <updated>2021-06-07T12:25:50+08:00</updated>
        <link href="http://blog.qrzbing.cn/post/2021-ciscn-little-evil/"/>
        <content type="text/html" src="http://blog.qrzbing.cn/post/2021-ciscn-little-evil/"><![CDATA[<p>对 KLEE 的学习，一些小小的自动化操作。</p>]]></content>
        <author>
            <name><![CDATA[QRZ’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.noisyfox.io/natj-memory-management.html</id>
        <title><![CDATA[A Brief Explanation of Memory Management in NatJ]]></title>
        <updated>2021-05-17T14:15:50+08:00</updated>
        <link href="https://www.noisyfox.io/natj-memory-management.html"/>
        <content type="text/html" src="https://www.noisyfox.io/natj-memory-management.html"><![CDATA[<p><a href="https://github.com/multi-os-engine/moe-natj" target="_blank" rel="noreferrer noopener">NatJ</a> is the Java library used by MOE for interoperating with native APIs, such as creating Java bindings of Objective-C classes and calling C APIs directly in Java without the need of writing wrappers in JNI by your own. One critical problem NatJ needs to handle is the difference in the way Java and native APIs manage memory: Java uses GC, while Objective-C uses ARC, and C requires manual memory management by calling <code>free()</code> explicitly.</p>



<h2>C</h2>



<p>When interoperating with C APIs, the rules are simple:</p>



<ul><li>When the native object (anything you allocate with <code>malloc</code> etc.) has the same lifecycle as the corresponding Java representative object (<code><a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/java/org/moe/natj/general/Pointer.java" target="_blank" rel="noreferrer noopener">org.moe.natj.general.Pointer</a></code>), i.e., the native object is OWNED by your Java code, then as soon as the <code>Pointer</code> instance is GC-ed, the native memory will be <code>free()</code>-ed automatically (by the <code><a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/java/org/moe/natj/c/CRuntime.java#L120-L130" target="_blank" rel="noreferrer noopener">CRuntime.strongReleaser</a></code>).</li><li>When the native object is not owned by the Java side, then NatJ won&#8217;t do anything for you. You need to free it by yourself when appropriate.</li></ul>



<p>These two rules correspond to the <code>owned</code> parameter of the <a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/java/org/moe/natj/c/CRuntime.java#L143-L145" target="_blank" rel="noreferrer noopener"><code>CRuntime.createStrongPointer</code> method</a>.</p>



<h2>Objective-C</h2>



<p>Objective-C uses ARC. Every OC object has a reference counter. The object will be deallocated as soon as the reference counter reaches 0. This creates several restrictions when using OC objects in Java world (and vice versa):</p>



<ol id="objc-restriction"><li>When a Java instance is passed to native side by mapping to an OC object (i.e., a Java object of the <a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/java/org/moe/natj/objc/ObjCObject.java#L31-L33" target="_blank" rel="noreferrer noopener">hybrid or inherited mode</a>), and that OC object is retained on the native side (e.g. the <code>retain</code> function is called on this object), the Java GC should not attempt to free that object.</li><li>When a Java representative object is still used by the Java code (i.e., the object has not been finalized by GC thread), the corresponding native object should not be deallocated by ARC (i.e., the reference count should not reach 0).</li></ol>



<p>NatJ has two major different types of relationships between Java object and OC object, which can be found <a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/java/org/moe/natj/objc/ObjCObject.java#L29-L38" target="_blank" rel="noreferrer noopener">here</a>, based on whether the Java object stores any extra state:</p>



<ol><li>A <strong>Binding</strong> class, which simply represents an existing Objective-C object, with ALL of the states store in the OC object, and ALL methods are implemented on the native side;</li><li>A class which stores part of (or all) the states in Java object, and/or implement part of (or all) the methods in Java, which then can be divided further into two types:<ul><li>An <strong>Inherited</strong> class, which ALL states are stored in the Java object, and ALL methods are implemented in Java;</li><li>A <strong>Hybrid</strong> class, which sits in between.</li></ul></li></ol>



<h3>Binding Class</h3>



<p>The reason of categorizing them into 2 major types is whether they are affected by the <a href="#objc-restriction">restriction 1</a>.</p>



<p>When the states are stored purely on the native side, there is no need of keeping a permanent 1-to-1 mapping between the native object and the Java object. and the life span of the Java object can also be shorter than the native object. In other word, you can have multiple Java objects that point to the same native object, and those Java bindings can be GC-ed at anytime BEFORE the native object is deallocated.</p>



<p>For these reasons, a Binding class works similar to ARC: when a binding object is created, the corresponding native object will be <a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/java/org/moe/natj/objc/map/ObjCObjectMapper.java#L104" target="_blank" rel="noreferrer noopener">retained</a> (i.e., reference count + 1), and when the binding object is finalized by GC, the corresponding native object will be <a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/java/org/moe/natj/objc/map/ObjCObjectMapper.java#L83" target="_blank" rel="noreferrer noopener">released</a>, thus guarantees the <a href="#objc-restriction">restriction 2</a>.</p>



<h3>Inherited &amp; Hybrid Class</h3>



<p>On the other hand, for an inherited/hybrid class, it&#8217;s important to make sure the Java object has the same lifetime as the native object.</p>



<p>To meet restriction 1, NatJ needs a way of telling if the native object is held (retained) by any native code. Normally when an OC object is now held by anything, it&#8217;s reference count will be 0 and that&#8217;s when this object is deallocated. </p>



<p>However this violates restriction 2 as the corresponding Java object has not been freed by GC yet. NatJ does a clever trick: when the OC object is created, NatJ <a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/native/natj/ObjCImplementations.mm#L112" target="_blank" rel="noreferrer noopener">immediately calls <code>retain</code> on it</a>, then use this object normally. Now whenever the reference count reaches 1 instead of 0, we know this object is not held by anything, other than the initial <code>retain</code> by NatJ. And when the Java object is finalized, NatJ will call the final <code>release</code> on that to free it.</p>



<p>The problem now is: how to stop the Java object been freed by GC when the reference count is greater than 1, and how to allow it when the reference count reaches 1. The answer is simple: when the reference count <a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/native/natj/ObjCImplementations.mm#L167-L170" target="_blank" rel="noreferrer noopener">is greater than 1</a>, the corresponding Java object will be <a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/native/natj/ObjCImplementations.mm#L167-L170" target="_blank" rel="noreferrer noopener">stored in a global static map</a> (the <a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/java/org/moe/natj/general/NatJ.java#L555" target="_blank" rel="noreferrer noopener">strong reference map</a>), so it will never be released by GC; when the reference count <a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/native/natj/ObjCImplementations.mm#L204-L208" target="_blank" rel="noreferrer noopener">reaches 1</a>, the Java object is <a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/native/natj/ObjCInstanceContainer.mm#L335-L337" target="_blank" rel="noreferrer noopener">removed from that map</a> (and added into another map with WeakReference, the <a href="https://github.com/multi-os-engine/moe-natj/blob/3ebc36fa4da160bf93b018686ee3ca5076ad61ee/src/main/java/org/moe/natj/general/NatJ.java#L604-L605" target="_blank" rel="noreferrer noopener">weak reference map</a>), thus allows GC to do its work.</p>



<p></p>
<p><a rel="nofollow" href="https://www.noisyfox.io/natj-memory-management.html">A Brief Explanation of Memory Management in NatJ</a>，首发于<a rel="nofollow" href="https://www.noisyfox.io">狐狸的小小窝</a>。</p>]]></content>
        <author>
            <name><![CDATA[狐狸的小小窝]]></name>
        </author>
    </entry>
    
    <entry>
        <id>http://blog.qrzbing.cn/post/2021-ciscn/</id>
        <title><![CDATA[CISCN 2021]]></title>
        <updated>2021-05-16T07:57:01+08:00</updated>
        <link href="http://blog.qrzbing.cn/post/2021-ciscn/"/>
        <content type="text/html" src="http://blog.qrzbing.cn/post/2021-ciscn/"><![CDATA[<p>摸了一小会鱼。</p>]]></content>
        <author>
            <name><![CDATA[QRZ’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://cosmosning.github.io/2020/12/06/review-of-logseq/</id>
        <title><![CDATA[Logseq：开源优雅的知识管理工具]]></title>
        <updated>2021-05-14T12:17:25+08:00</updated>
        <link href="https://cosmosning.github.io/2020/12/06/review-of-logseq/"/>
        <content type="text/html" src="https://cosmosning.github.io/2020/12/06/review-of-logseq/"><![CDATA[<figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/12/altumcode-GVASc0_Aam0-unsplash.jpg" alt="题图" /><figcaption>题图</figcaption></figure><h1 id="前言">前言</h1><p>笔记，对于我个人来说，是一个非常重要的整理与回顾知识的工具。找到适合自己的笔记载体，将会极大地提高的效率。为追求最佳效率，我尝试过多种方式，从手写到电子，从文档到导图。它们各具特色，又难免缺失某种特性而使我最终放弃。</p><h2 id="印象笔记">印象笔记</h2><p>16年，新买的笔记本电脑上预装了印象笔记。当时的印象笔记还仅支持富文本编辑模式。富文本编辑意味着所见即所得，格式可以轻松地点击菜单按钮随时调整。</p><p>但是对于我来说，这就意味着我将要腾出一只手握住鼠标，在需要时调整格式。这其实会降低笔记的效率，因为这种模式下，你不仅仅要关注笔记的内容，而且需时不时地分心调整格式。这与我追求高效的笔记体验背道而驰。</p><p>除此以外，在富文本模式下，公式的输入非常繁琐，这也是我最终放弃印象笔记的原因之一。</p><p>虽然，印象笔记在 18 年开始支持 Markdown，但其编辑、预览双屏的设计，对于追求简洁的我太过复杂，也就没有再拾起。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/12/yinxiang-markdown.png" alt="印象笔记 Markdown 双屏设计" /><figcaption>印象笔记 Markdown 双屏设计</figcaption></figure><h2 id="typora">Typora</h2><p>18 年左右，经朋友推荐，了解到 <a href="https://typora.io/" target="_blank" rel="noopener">Typora</a> 这款简洁的 Markdown 编辑器，并一直使用至今。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/12/typora.png" alt="Typora:所见即所得" /><figcaption>Typora:所见即所得</figcaption></figure><p>Typora 主要令我喜爱的一点是其“<strong>所见即所得</strong>”的即时 Markdown 渲染。该软件只用一屏，既提供了 Markdown 的排版功能，又减去了编辑模式下 Markdown 中的影响阅读体验的格式符号。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/12/fences.png" alt="Typora 代码块" /><figcaption>Typora 代码块</figcaption></figure><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/12/math.png" alt="Typora 数学公式" /><figcaption>Typora 数学公式</figcaption></figure><p>然而，Typora 只是一个编辑器，只能记录，<strong>难以检索和回顾</strong>。因此，仅靠 Typora ，难以完成笔记的完整闭环。一种常见的工作流可以勉强解决这个问题，即 Typora（编辑）+ Hexo（生成静态博客网页）+ GitHub Pages（发布与检索）。然而，笔记的<strong>私密性</strong>和博客的<strong>开放性</strong>的矛盾无法得到有效解决，这使我陷入了两难的境地。</p><h2 id="幕布">幕布</h2><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/12/mubu.png" alt="幕布" /><figcaption>幕布</figcaption></figure><p>20 年，准备考研复试的专业课时，我开始尝试幕布这个在线笔记软件。对于整理概念性的知识，幕布绝对是一个非常强大的工具。将一门课，一本书化为一个个知识点，并通过层次表达它们的关系，最后还能生成相应的思维导图，这个笔记体验真的是太美妙了。</p><p>美中不足的是，幕布并<strong>不支持公式和代码块的渲染</strong>，这对于有大量公式代码笔记需求的我来说有点遗憾。</p><h2 id="logseq">Logseq</h2><p>最近，在 GitHub 上发现了一款开源笔记应用，<a href="https://github.com/logseq/logseq" target="_blank" rel="noopener">Logseq</a>，个人感觉比较完美的满足了我的几点需求：</p><ol type="1"><li>支持 Markdown，并且所见即所得 ；</li><li>支持公式和代码块渲染；</li><li>保持笔记的私密性。</li></ol><p>下一部分，我将聊一聊我对 Logseq 的使用体验。</p><h1 id="logseq-初体验">Logseq 初体验</h1><h2 id="快速上手">快速上手</h2><p>使用 Logseq 非常简单，只需要你拥有一个浏览器，一个 GitHub 账户及笔记仓库。</p><div class="note info"><p>如果要保持你笔记的私密性，你可以创建一个<strong>私有</strong>的 GitHub 笔记仓库供 Logseq 存储数据文件。</p></div><p>当你，准备好上述要求，只需访问 <a href="https://logseq.com/" target="_blank" rel="noopener">https://logseq.com/</a> ，并使用 Github 登录授权，设置好笔记仓库，就可以开始你的笔记了。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/12/daily-notes.PNG" alt="Logseq默认界面" /><figcaption>Logseq默认界面</figcaption></figure><p>登陆后，Logseq 会默认创建一个标题为今天的文件，你可以直接在此开始笔记。如果要创建新的页面，你可以在左上的搜索框输入新页面的文件名，并选择相应的下拉选项，完成创建。</p><h2 id="体验感受">体验感受</h2><p>从我的使用体验来说，Logseq 的手感是十分惊艳的。主要有如下几点：</p><ul><li><strong>快速笔记</strong><ul><li>十分类似于幕布的高效的笔记手感</li></ul></li><li><strong>数据完全属于你</strong><ul><li>Logseq 不保存你的任何数据。它在运行过程中，仅仅将你的数据缓存在浏览器的本地缓存中，并与你设定的 GitHub 仓库同步。</li></ul></li><li><strong>强大的页面引用、块引用</strong><ul><li>受 <a href="https://roamresearch.com/" target="_blank" rel="noopener">Roam</a> 启发</li><li>这建立了独立的笔记文件之间的联系，更利于笔记整合成知识库。</li></ul></li><li><strong>支持 Markdown，并且所见即所得</strong></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/12/markdown-support.png" alt="Logseq 中 Markdown 支持情况" /><figcaption>Logseq 中 Markdown 支持情况</figcaption></figure><ul><li><strong>丰富的命令</strong><ul><li>键入 <code>/</code> （slash 键），你会发现一个全新的大陆：可以创建待办事项、插入页面引用或者块引用，甚至还能在其中插入一个画图的页面。</li></ul></li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/12/commands.PNG" alt="Logseq 中的命令" /><figcaption>Logseq 中的命令</figcaption></figure><h2 id="使用场景">使用场景</h2><p>在我看来，Logseq 具有非常丰富的使用场景：</p><ul><li><strong>自由写作</strong>：你可以在 Logseq 写下任何你思想的火花，供日后整理。</li><li><strong>待办事项</strong>：Logseq 提供了比较丰富的待办事项功能，包括创建待办事项，设置事项优先级，设定 deadline 和 schedule。</li><li><strong>知识整理</strong>：这也许是 Logseq 最核心的使用方式之一。</li><li>...（也许还有更多）</li></ul><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/12/deadline-and-schedule.png" alt="Logseq 的 deadline 和 schedule" /><figcaption>Logseq 的 deadline 和 schedule</figcaption></figure><h1 id="从内联到外联">从内联到外联</h1><p>传统的笔记软件，通常把笔记独立为一个一个文件，关注一个文件内的内在联系，而忽视了不同笔记之间的联系。</p><p>Logseq 受 Roam 启发，将不同的笔记文件通过<strong>页面引用</strong>联系起来，从而更好地构建自己的知识网络。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/12/KG.PNG" alt="Logseq 图谱示例" /><figcaption>Logseq 图谱示例</figcaption></figure><p>近期，新版的幕布也上线了 <code>@文件名</code> 引用不同的笔记，想必也是受到类似应用的启发。</p><p>由此可见，笔记软件正在从内联走向外联，越来越符合对知识整理的需求。</p><h1 id="不足">不足</h1><p>目前来说，Logseq 还存在许多不足：</p><ul><li>Logseq 还处在快速迭代阶段，很多功能存在不稳定的可能；</li><li>相关的文档稀少，对新手不太友好；</li></ul><p>但我相信，开源社区的支持会使得它更加完善。</p>]]></content>
        <author>
            <name><![CDATA[CosmosNing的个人博客]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://cosmosning.github.io/2020/10/08/notes-of-keyword-search-knowledge-2020/</id>
        <title><![CDATA[Keyword Search over Knowledge Graphs via Static and Dynamic Hub Labelings 阅读笔记]]></title>
        <updated>2021-05-14T12:17:25+08:00</updated>
        <link href="https://cosmosning.github.io/2020/10/08/notes-of-keyword-search-knowledge-2020/"/>
        <content type="text/html" src="https://cosmosning.github.io/2020/10/08/notes-of-keyword-search-knowledge-2020/"><![CDATA[<h1 id="highlights">Highlights</h1><ul><li><strong>Static Hub Labelings</strong></li><li><strong>Dynamic Hub Labelings</strong></li></ul><h1 id="what">What？</h1><h2 id="problem">Problem</h2><p>一种常见的图数据上的关键词查询的方法是，将每一个关键词与图上的一个顶点匹配，并且从中抽取出包含这些匹配顶点的最小权重的树（这种树被称为 <em>minimum-weight Steiner trees</em>）。更规范地说，给定一个有权边的数据图和一个关键词查询，首先对于每一个关键词，在图中找到与之匹配的所有顶点，形成一个匹配集；然后，在图中找到一个扩展匹配集的树，该树对于每一个匹配集，至少包含其中的一个顶点，并且总边权重最小。这个优化问题叫做 <em>group Steiner tree (GST) problem</em> 。</p><div class="note info"><p>数据图中的边也可以被关键词匹配。我们可以通过 <em>graph subdivision</em> 将边匹配转换为点匹配，之后使用点匹配的方式处理该匹配就行了。</p></div><h2 id="contributions">Contributions</h2><ul><li>设计了一个质量有保证的近似算法，能够在毫秒级内，从百万级大小的知识图谱中返回不错的结果。</li><li>设计了动态、静态 HL，提高了总体的效率。</li></ul><h1 id="why">Why？</h1><p>知识图谱越来越大，现存的算法太慢了。</p><h1 id="how">How？</h1><h2 id="problem-formulation">Problem Formulation</h2><ul><li><strong>知识图谱（<em>KG</em>）</strong>：规范的，知识图谱是一个简单的无向图 <span class="math inline">\(G=&lt;V,E&gt;\)</span> ，其中 <span class="math inline">\(V\)</span> 是包含 <span class="math inline">\(n\)</span> 个顶点的有限集合，用来指代实体（<em>entity</em>），而 <span class="math inline">\(E\subseteq V\times V\)</span> 是顶点无序对的有限集合，作为图的无向边，用来代表实体之间的关系（<em>relation</em>）。<ul><li><strong>边权重</strong>：定义一个权重函数 <span class="math inline">\(\textrm{wt}:E\mapsto \mathbb{R}^{0+}\)</span> （<strong>小权重表示重要性大</strong>）。</li></ul></li><li><strong>图中术语</strong><ul><li><span class="math inline">\(\textrm{len}(p)\)</span> ：对于一条路径 <span class="math inline">\(p\)</span> ，它的<strong>长度</strong>是路径中所有边的权重之和。</li><li><span class="math inline">\(\textrm{dist}(u,v)\)</span> ：在图 <span class="math inline">\(G\)</span> 中，连接 <span class="math inline">\(u\)</span> 、<span class="math inline">\(v\)</span> 的<strong>最短路径的长度</strong>。如果不存在，那么为 <span class="math inline">\(\infty\)</span> 。</li></ul></li><li><strong>关键词映射</strong>：定义一个获取函数 <span class="math inline">\(\textrm{hits}:\mathbb{K}\mapsto 2^V\)</span> ，它将关键词映射到顶点集 <span class="math inline">\(V\)</span> 的子集。</li><li><strong>关键词查询</strong>：一个<strong>关键词查询</strong> <span class="math inline">\(Q\subseteq \mathbb{K}\)</span> 是一个关键词的有限集合。<ul><li>给定一个含有 <span class="math inline">\(g\)</span> 个关键词的查询 <span class="math inline">\(Q=\{k_1,k_2,\dots,\ k_g\}\)</span> ，将 <span class="math inline">\(\textrm{hits}(k_i)\)</span> 简记为 <span class="math inline">\(K_i\)</span> （<span class="math inline">\(1\le i\le g\)</span>），并称之为<strong>关键词顶点</strong>。</li><li>给定一个图 <span class="math inline">\(G=&lt;V,E&gt;\)</span> ，在 <span class="math inline">\(G\)</span> 上关于 <span class="math inline">\(Q\)</span> 的结果是一个 <em>group Steiner tree (GST)</em> ，记作 <span class="math inline">\(T=&lt;V_T,E_T&gt;\)</span> ，满足以下条件<ul><li><span class="math inline">\(V_T\subseteq V,E_T\subseteq E\)</span> ，并且 <span class="math inline">\(T\)</span> 是一棵树；</li><li><span class="math inline">\(V_T\)</span> 包含来自每一个 <span class="math inline">\(K_i\)</span> （<span class="math inline">\(1\le i\le g\)</span>）中的至少一个顶点，也就是 <span class="math inline">\(V_T\cap K_i \ne \emptyset\)</span> ；</li><li>树的权重（定义为 <span class="math inline">\(\textrm{WT}(T)=\sum_{e\in E_T}\textrm{wt}(e)\)</span>）最小</li></ul></li></ul></li></ul><h2 id="overview-of-two-algorithm">Overview of Two Algorithm</h2><p>第一个算法 <em>KeyKG</em> 为每一个关键词选取匹配的顶点，并且找到对应的树。对于 <span class="math inline">\(g\)</span> 个关键词，<em>KeyKG</em> 是一个 <span class="math inline">\((g-1)\)</span> - 近似算法，也就是说，一个 GST 的边权值的总和至多是最小权重的 <span class="math inline">\((g-1)\)</span> 倍。获得这样的近似效果要归功于匹配顶点集的选择和利用最短路径树的构造。为了更高效的在线计算距离和最短路径，该文章设计了一个 HL ，这个 HL 使用了一种全新的基于 <em>betweenness centrality</em> 的启发式方法改善了现存的 <em>pruned landmark labeling</em> 。传统的，这种 HL 是静态的，因为它是离线生成的，并且对查询是不变的。在巨大的知识图谱中， 使用静态 HL 的 <em>KeyKG</em> 算法至少比目前先进的算法快一个数量级，并且所得结果的质量也较高。</p><p>第二个算法 <em>KeyKG+</em> 通过使用一种新颖的 HL 扩展了 <em>KeyKG</em> 算法。这里所提出的 HL 是动态的，因为它是在处理一个具体的查询时，通过倒排和聚集某些查询相关的静态标签，而动态生成的。它减少了 KeyKG 算法中的重复操作（这些重复操作是指使用传统静态 HL 计算顶点集的距离）。尽管在线生成会花费额外的时间，使用动态 HL 为总体效率带来了几个数量级的提高。</p><h2 id="keykg-with-static-hl">KeyKG With Static HL</h2><h3 id="algorithm-keykg">Algorithm KeyKG</h3><h4 id="algorithm-explained">Algorithm Explained</h4><p>如下图<strong>算法 1</strong> 所示，<em>KeyKG</em> 在知识图谱中找到一个 <em>GST</em> ，这个 <em>GST</em> 是由 <span class="math inline">\(g\)</span> 个关键词集合扩展而来。简而言之， <em>KeyKG</em> 首先贪婪地选择一组相互靠近的一组关键词顶点集合（记作 <span class="math inline">\(U_x\)</span>），这组关键词顶点集合包含了来自每一个 <span class="math inline">\(K_i\)</span> （<span class="math inline">\(1\le i\le g\)</span>）中的一个顶点（<strong>Line 1 - 8</strong>）。然后，<em>KeyKG</em> 贪婪地找到一个由 <span class="math inline">\(U_x\)</span> 扩展而来的 <em>GST</em> （记作 <span class="math inline">\(T_{u_{min}}\)</span>），这个过程是通过迭代地扩展最短路径而得到的（<strong>Line 9 - 18</strong>）。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/Algo1.PNG" alt="算法 1" /><figcaption>算法 1</figcaption></figure><p>具体的，对于每一个 <span class="math inline">\(v_1 \in K_1\)</span> （<strong>Line 1</strong>），<em>KeyKG</em> 从每一个 <span class="math inline">\(K_i\)</span> 找到一个顶点 <span class="math inline">\(v_i\)</span> ，它距离 <span class="math inline">\(v_1\)</span> 的距离最短（<strong>Line 2 - 4</strong>）。令 <span class="math inline">\(U_{v_1}\)</span> 为所有这样的顶点 <span class="math inline">\(v_i\)</span> （包括 <span class="math inline">\(v_1\)</span>）的的集合，并且令 <span class="math inline">\(W_{v_1}\)</span> 为它们到 <span class="math inline">\(v_1\)</span> 的距离之和（<strong>Line 5 - 6</strong>）。令 <span class="math inline">\(x\in K_1\)</span> 为 <span class="math inline">\(K_1\)</span> 中 <span class="math inline">\(W_{v_1}\)</span> 最小的顶点（<strong>Line 8</strong>）。</p><div class="note info"><p><strong>扩展 <span class="math inline">\(U_x\)</span> 所得到的 GST 可能有较小的权重</strong></p><ul><li>因为 <span class="math inline">\(U_x\)</span> 包含了来自每一个 <span class="math inline">\(K_i\)</span> （<span class="math inline">\(1\le i\le g\)</span>）中的一个顶点，并且这些顶点相对而言十分接近，所以扩展 <span class="math inline">\(U_x\)</span> 所得到的 GST 可能有较小的权重。</li></ul></div><p><strong>算法 1</strong> 剩下的部分以每一个 <span class="math inline">\(u\in U_x\)</span> 构造一个 <em>GST</em> <span class="math inline">\(T_u\)</span> ，并且从这 <span class="math inline">\(|U_x|\)</span> 棵 <em>GST</em> 中找出权重最小的那一个。具体的，每一棵 <span class="math inline">\(T_u\)</span> 被初始化为只含有一个单一的顶点 <span class="math inline">\(u\)</span> （<strong>Line 9 - 10</strong>）。然后，不断迭代直至 <span class="math inline">\(T_u\)</span> 扩展了 <span class="math inline">\(U_x\)</span> 中的所有顶点（<strong>Line 11</strong>）：从 <span class="math inline">\(T_u\)</span> 中选取一个点 <span class="math inline">\(s_{\textrm{min}}\)</span> ，从 <span class="math inline">\(U_x-T_u\)</span> 中选一个点 <span class="math inline">\(t_{\textrm{min}}\)</span> ，它们之间的距离最短（<strong>Line 12</strong>）。接着，找到 <span class="math inline">\(s_{\textrm{min}}\)</span> 和 <span class="math inline">\(t_{\textrm{min}}\)</span> 之间的最短路径，并将路径上的顶点和边加入 <span class="math inline">\(T_u\)</span> （<strong>Line 13 -14</strong>）。令 <span class="math inline">\(u_{\textrm{min}}\in U_x\)</span> 表示一个顶点，满足它所对应的 <span class="math inline">\(T_u\)</span> 的权重最小（<strong>Line 17</strong>）。最终 <em>KeyKG</em> 将 <span class="math inline">\(T_{u_\textrm{min}}\)</span> 作为结果返回。</p><div class="note default"><p><strong>算法 1 中的 <code>getD</code> 和 <code>getSP</code></strong></p><ul><li><code>getD</code> ：计算两个顶点之间的距离。</li><li><code>getSP</code>：计算两个顶点之间的最短路径。</li></ul></div><h4 id="running-example">Running Example</h4><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><p>举个例子，如上图，给定一个查询 <span class="math inline">\(Q=\{k_1,k_2,k_3\}\)</span> ，则 <span class="math inline">\(K_1=\{B,F\},\;K_2=\{E\},\;K_3=\{C,D\}\)</span> 。</p><ul><li>对于 <span class="math inline">\(B\in K_1\)</span> ，<span class="math inline">\(E\)</span> 必选；由于 <span class="math inline">\(\textrm{dist}(B,C) = 1 &lt; 1.6 = \textrm{dist}(B,D)\)</span> ，所以选择 <span class="math inline">\(C\)</span> 。故 <span class="math inline">\(U_B = \{B,E,C\}\)</span> 。</li><li>对于 <span class="math inline">\(B\in K_2\)</span> ，<span class="math inline">\(E\)</span> 必选；由于 <span class="math inline">\(\textrm{dist}(F,C) = 1.1 &lt; 1.7 = \textrm{dist}(F,D)\)</span> ，所以选择 <span class="math inline">\(C\)</span> 。故 <span class="math inline">\(U_B = \{F,E,C\}\)</span> 。</li></ul><p>下面计算各自的权重之和：</p><ul><li>对于 <span class="math inline">\(U_B\)</span> ，<span class="math inline">\(W_B=\textrm{dist}(B,E)+\textrm{dist}(B,C) = 0.8+1 = 1.8\)</span></li><li>对于 <span class="math inline">\(U_F\)</span> ，<span class="math inline">\(W_B=\textrm{dist}(F,E)+\textrm{dist}(F,C) = 0.9+1.1 = 2\)</span></li></ul><p>由于 <span class="math inline">\(W_B &lt; W_F\)</span> ，故 <span class="math inline">\(x = B\)</span> 。</p><p>接下来生成 <em>GST</em> ：</p><ul><li><span class="math inline">\(T_B\)</span><ul><li>初始化 <span class="math inline">\(T_B\)</span> 中仅有一个顶点 <span class="math inline">\(B\)</span></li><li>令 <span class="math inline">\(s_{\textrm{min}} = B\)</span> ，则 <span class="math inline">\(t_{\textrm{min}} = E\)</span> ，因为 <span class="math inline">\(\textrm{dist}(B,E) &lt; \textrm{dist}(B,C)\)</span></li><li>令 <span class="math inline">\(t_{\textrm{min}} = C\)</span> ，则 <span class="math inline">\(s_\textrm{min} = E\)</span> ，因为 <span class="math inline">\(dist(E,C) &lt; \textrm{dist}(B,C)\)</span></li><li>再求出相关最短距离的路径，将路径上的顶点和边加入 <span class="math inline">\(T_B\)</span> ，即可得到图 <strong>KeyKG 执行的例子</strong> 中的 <span class="math inline">\(T_B\)</span></li></ul></li><li><span class="math inline">\(T_E\)</span> ：类似 <span class="math inline">\(T_B\)</span> 分析可得</li><li><span class="math inline">\(T_C\)</span> ：类似 <span class="math inline">\(T_B\)</span> 分析可得</li></ul><h3 id="static-hl">Static HL</h3><h4 id="why-we-need-hub-labeling">Why we need Hub Labeling？</h4><p>由上述介绍可知，<em>KeyKG</em> 依赖于两个子函数 <code>getD</code> 和 <code>getSP</code> 。在巨大的知识图谱中，一种直观的在线的实现这些子函数的方法（例如 Dijkstra 算法）的执行时间太长了；另一方面，离线生成每对顶点之间的距离和最短路径的空间开销十分大。为了权衡时空开销，这篇文章使用了 Hub Labeling ，一种离线生成的索引结构。</p><h4 id="basic-concept">Basic Concept</h4><p>一个静态的 HL 是一个图上的离线生成的索引结构。规范的说，对于一个图 <span class="math inline">\(G=&lt;V,E&gt;\)</span> ，一个静态的 HL ，可以看作一个函数 <span class="math inline">\(L:V\mapsto 2^V\)</span> ，它将顶点映射到顶点的集合（称作 <em>hub</em>），并且满足下列条件：</p><ul><li><span class="math inline">\(\forall u,v\in V\)</span> ，并且 <span class="math inline">\(u，v\)</span> 在 <span class="math inline">\(G\)</span> 中是连通的，<span class="math inline">\(\exists h\in L(u)\cap L(v)\)</span> ，使得 <span class="math inline">\(h\)</span> 在 <span class="math inline">\(u,v\)</span> 之间的最短路径上</li></ul><div class="note info"><p>对于 <span class="math inline">\(\forall v\in V\)</span> ， <span class="math inline">\(L(v)\)</span> 称为顶点 <span class="math inline">\(v\)</span> 的<strong>标签</strong>。</p></div><h4 id="supporting-for-computing-getd-but-not-getsp">Supporting For Computing <code>getD</code> but not <code>getSP</code></h4><p>在标准的索引结构中，每一个 <span class="math inline">\(L(v)\)</span> 是一个列表，其中包含按标识符排序的 hubs 。对于每一个 <span class="math inline">\(h\in L(v)\)</span> ，<span class="math inline">\(\textrm{dist}(v,h)\)</span> 也会预先计算出来并保存。这样我们就可以通过如下公式计算 <code>getD</code> ： <span class="math display">\[\textrm{getD}(u,v)=\begin{cases}\underset{h\in L(u)\cap L(v)}{min} \textrm{dist}(u,h) + \textrm{dist}(v,h) &amp; L(u)\cap L(v) \ne \emptyset\\\infty &amp; L(u)\cap L(v) = \emptyset\\\end{cases}\]</span> 其中，<span class="math inline">\(\textrm{dist}(u,h)\)</span> 和 <span class="math inline">\(\textrm{dist}(v,h)\)</span> 分别存储在 <span class="math inline">\(L(u)\)</span> 和 <span class="math inline">\(L(v)\)</span> 中。</p><p>但是，无法计算 <code>getSP</code></p><h4 id="improvement-in-construction">Improvement in Construction</h4><p><strong>动机</strong></p><p>从 <span class="math inline">\(\textrm{getD}(u,v)\)</span> 计算公式来看，当索引标签较小时，<code>getD</code> 的在线计算会更快。但是，最小化索引标签的平均大小是一个 NP-Hard 问题，并且具有对数不可近似性（<em>logarithmic inapproximability</em>）。给定一个图，有很多不同的启发式的方法能够构建合理的较小的索引标签。在其他的方法中，<em>pruned landmark labeling</em> (PLL) 是一个非常热门的实现方法，它利用了 Dijkstra 算法，并且能够高效的剪枝达到缩小索引标签大小的目的。</p><p><strong>算法</strong></p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/Algo2.PNG" alt="Algorithm 2" /><figcaption>Algorithm 2</figcaption></figure><p>如<strong>算法 2</strong> 所示，标准的 PLL 基本流程是执行 Dijkstra 算法 <span class="math inline">\(n\)</span> 次，其中 <span class="math inline">\(n\)</span> 为顶点的个数（Line 3 - 24），并且在此过程中迭代地扩展顶点标签（Line 4，Line 12）。记 <span class="math inline">\(i\)</span> 次迭代后 <span class="math inline">\(v\)</span> 的标签为 <span class="math inline">\(L_i(v)\)</span> 。在第 <span class="math inline">\(i\)</span> 次迭代，Dijkstra 算法从一个不同的顶点 <span class="math inline">\(v_i\in V\)</span> 出发（Line 7），访问其他顶点并且计算它们与 <span class="math inline">\(v_i\)</span> 之间的距离，存储到 <span class="math inline">\(d\)</span> 中（Line 14 - 15），再将 <span class="math inline">\(v_i\)</span> 加入到它们的索引标签中。</p><div class="note info"><p><strong>关于剪枝</strong></p><ul><li>由于一些顶点 <span class="math inline">\(u\)</span> 没有被访问到，所以它们的标签可以剪掉。</li><li>当 <span class="math inline">\(u\)</span> 与 <span class="math inline">\(v_i\)</span> 的距离可由构造好的 <span class="math inline">\(L_{i-1}\)</span> 标签计算得到，也就是 Line 11 的条件为假，那么会发生剪枝。</li></ul></div><p><strong>改进：Betweenness Centrality</strong></p><p>我们的目标是能够做更多剪枝来提高整个系统的性能。具体的，我们想要迭代早期构造的索引标签能够支持计算更多对顶点之间的距离，这样在后期的迭代过程中，就可以更频繁地发生剪枝操作。直观地，这可以通过这种方式实现，即在 Dijkstra 算法迭代的早期，选择那些许多最短路径都经过的顶点作为起始顶点。为了实现这个想法，原始的 PLL 实现方式是利用一些启发式的方法，对这些起始顶点按照其度数降序排列，因为高度数的顶点更有可能出现在许多顶点对之间的最短路径上。与传统方法不同，我们基于 <em>betweenness centrality</em> 对它们降序排序。顶点 <span class="math inline">\(v\)</span> 的 <em>betweenness centrality</em> 定义如下： <span class="math display">\[\textrm{bc}(v)=\underset{s,\;t\in V\backslash\ \{v\}}{\sum}\frac{\sigma_{st}(v)}{\sigma_{st}}\]</span> 其中，<span class="math inline">\(\sigma_{st}\)</span> 表示顶点 <span class="math inline">\(s,\;t\)</span> 之间最短路径的个数，<span class="math inline">\(\sigma_{st}(v)\)</span> 表示上述路劲中经过顶点 <span class="math inline">\(v\)</span> 的。</p><div class="note info"><p><strong>图上任意两个顶点之间的最短路径不止一条</strong>，因为可能存在<strong>最小权值相等但是路径不同</strong>的情况。</p></div><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><div class="note default"><p>举个例子，如上图中的图。可以用 Floyd 算法计算出任意两顶点之间的最短距离和路径。之后依据这个信息和 <em>betweenness centrality</em> 的定义可得：</p><ul><li><span class="math inline">\(\textrm{bc}(A) = 7\)</span></li><li><span class="math inline">\(\textrm{bc}(B)=4\)</span></li><li><span class="math inline">\(\textrm{bc}(C)=\textrm{bc}(D)=\textrm{bc}(E)=\textrm{bc}(F)=0\)</span></li></ul><p>但是，论文中用了 [4] （<strong>TODO</strong>）中的近似算法来缩短计算时间。</p></div><p><strong>构造 Static HL 的例子</strong></p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><p>假设图的结构如上图所示。</p><p>首先初始化 <span class="math inline">\(L_0(v)\)</span> ：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_0(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_0(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_0(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_0(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_0(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_0(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>接着按照 <em>betweenness centrality</em> 对顶点降序排序，顺序为 <strong>A, B, C, D, E, F</strong>；</p><hr /><p>进入第一次循环：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(d[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>0</strong></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr></tbody></table><p>PQ 优先队列为：</p><table><thead><tr class="header"><th style="text-align: center;">A</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头（队尾）</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>进入内层 while 循环，</p><p>从 PQ 中弹出 <span class="math inline">\(A\)</span> 赋给 <span class="math inline">\(u\)</span> ，即 <span class="math inline">\(u=A\)</span> ；</p><p>将 <span class="math inline">\(visit[u]\)</span> 置 1，则：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><p>利用 <span class="math inline">\(L_0\)</span> 计算 <span class="math inline">\(\textrm{getD}(v_1,u)\)</span> ，即计算 <span class="math inline">\(\textrm{getD}(A,A)\)</span> 。由于 <span class="math inline">\(L_0(A)=\emptyset\)</span> ，故 <span class="math inline">\(L_0(A)\cap L_0(A) = \emptyset\)</span>，所以 <span class="math inline">\(\textrm{getD}(A,A) = \infty\)</span> （利用 <span class="math inline">\(\textrm{getD}\)</span> 的公式可得）。</p><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[A] = 0 &lt; \textrm{getD}(v_1,u)\)</span> ，故 Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrow L_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 42%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><hr /><p>在接下来的对 <span class="math inline">\(u=A\)</span> 未被访问的邻居顶点执行操作。</p><p>访问第一个邻居 <span class="math inline">\(B\)</span> 后，<span class="math inline">\(d\)</span> 变化如下：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(d[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;"><strong>0.6</strong></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr></tbody></table><p>则有属于 <span class="math inline">\(L_1(B)\)</span> 的 <span class="math inline">\(A(\textrm{dist} = 0.6, \textrm{pred}= A)\)</span> ，同时 B 插入到 PQ 中。</p><p>类似的，有</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(d[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0.6</td><td style="text-align: center;"><strong>0.4</strong></td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;"><strong>0.3</strong></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr></tbody></table><p>属于 <span class="math inline">\(L_1(C)\)</span> 的 <span class="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}= A)\)</span></p><p>属于 <span class="math inline">\(L_1(D)\)</span> 的 <span class="math inline">\(A(\textrm{dist} = 1, \textrm{pred}= A)\)</span></p><p>属于 <span class="math inline">\(L_1(E)\)</span> 的 <span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></p><p>在所有 A 的邻居访问完后，PQ 变为</p><table><thead><tr class="header"><th style="text-align: center;">E</th><th style="text-align: center;">C</th><th style="text-align: center;">B</th><th style="text-align: center;">D</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">队尾</td><td style="text-align: center;"></td></tr></tbody></table><p>然后，回到 <code>while</code> 循环。</p><hr /><p>PQ 弹出 E，置 <span class="math inline">\(visit\)</span> 为 1：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">0</td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[E] = 0.3 &lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,E) = \infty\)</span> ，故 Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrow L_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 31%" /><col style="width: 8%" /><col style="width: 8%" /><col style="width: 8%" /><col style="width: 33%" /><col style="width: 8%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>E 未访问的邻居为 B，但由于 <span class="math inline">\(d[u]+\text{wt}((u,w)) = d[E] + \text{wt}((E,B)) = 0.3 + 0.8 = 1.1 &gt; d[B] = 0.6\)</span>，所以不更新；又由于 B 在 PQ 中，所以不加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;">C</th><th style="text-align: center;">B</th><th style="text-align: center;">D</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头</td><td style="text-align: center;"></td><td style="text-align: center;">队尾</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>PQ 弹出 C，置 <span class="math inline">\(visit\)</span> 为 1：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[C] = 0.4 &lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,C) = \infty\)</span> ，故 Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrow L_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 25%" /><col style="width: 7%" /><col style="width: 26%" /><col style="width: 7%" /><col style="width: 26%" /><col style="width: 7%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>C 未访问的邻居为 F，但由于 <span class="math inline">\(d[u]+\text{wt}((u,w)) = d[C] + \text{wt}((C,F)) = 0.4 + 2 = 2.4 &lt; d[F] = \infty\)</span>，所以，更新 <span class="math inline">\(d[F]\)</span> ：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(d[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0.6</td><td style="text-align: center;">0.4</td><td style="text-align: center;">1</td><td style="text-align: center;">0.3</td><td style="text-align: center;"><strong>2.4</strong></td></tr></tbody></table><p>此时，属于 <span class="math inline">\(L_1(F)\)</span> 的 <span class="math inline">\(A(\textrm{dist} = 2.4, \textrm{pred}= C)\)</span></p><p>又由于 F 不在 PQ 中，所以加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;">B</th><th style="text-align: center;">D</th><th style="text-align: center;">F</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头</td><td style="text-align: center;"></td><td style="text-align: center;">队尾</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>PQ 弹出 B，置 <span class="math inline">\(visit\)</span> 为 1：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[B] = 0.6 &lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,B) = \infty\)</span> ，故 Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrow L_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table style="width:100%;"><colgroup><col style="width: 21%" /><col style="width: 23%" /><col style="width: 22%" /><col style="width: 5%" /><col style="width: 22%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math display">\[A(\textrm{dist} = 0.6, \textrm{pred}= A)\]</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>B 未访问的邻居为 F，但由于 <span class="math inline">\(d[u]+\text{wt}((u,w)) = d[B] + \text{wt}((B,F)) = 0.6 + 0.1 = 0.7 &lt; d[F] = 2.4\)</span>，所以，更新 <span class="math inline">\(d[F]\)</span> ：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(d[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(d[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0.6</td><td style="text-align: center;">0.4</td><td style="text-align: center;">1</td><td style="text-align: center;">0.3</td><td style="text-align: center;"><strong>0.7</strong></td></tr></tbody></table><p>此时，属于 <span class="math inline">\(L_1(F)\)</span> 的 <span class="math inline">\(A(\textrm{dist} = 0.7, \textrm{pred}= B)\)</span></p><p>又由于 F 在 PQ 中，所以不加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;">D</th><th style="text-align: center;">F</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头</td><td style="text-align: center;">队尾</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>PQ 弹出 D，置 <span class="math inline">\(visit\)</span> 为 1：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"><strong>1</strong></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[D] = 1 &lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,D) = \infty\)</span> ，故 Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrow L_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 18%" /><col style="width: 20%" /><col style="width: 19%" /><col style="width: 18%" /><col style="width: 19%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math display">\[A(\textrm{dist} = 0.6, \textrm{pred}= A)\]</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 1, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(\emptyset\)</span></td></tr></tbody></table><p>D 没有未访问的邻居，故不更新 <span class="math inline">\(d[F]\)</span> ，也就没有顶点加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;">F</th><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">队头（队尾）</td><td style="text-align: center;"></td></tr></tbody></table><hr /><p>PQ 弹出 F，置 <span class="math inline">\(visit\)</span> 为 1：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(visited[A]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[B]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[C]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[D]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[E]\)</span></th><th style="text-align: center;"><span class="math inline">\(visited[F]\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"><strong>1</strong></td></tr></tbody></table><p>由于 <span class="math inline">\(\textrm{d}[u] = \textrm{d}[F] = 0.7 &lt; \textrm{getD}(v_1,u) = \textrm{getD}(A,F) = \infty\)</span> ，故 Line 11 的条件满足，进入条件体。</p><p><span class="math inline">\(L_i(u)\leftarrow L_{i-1}(u)\cup\{v_i\}\)</span> ，使得索引变化为：</p><table><colgroup><col style="width: 16%" /><col style="width: 17%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math display">\[A(\textrm{dist} = 0.6, \textrm{pred}= A)\]</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 1, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.7, \textrm{pred}= B)\)</span></td></tr></tbody></table><p>F 没有未访问的邻居，故不更新 <span class="math inline">\(d[F]\)</span> ，也就没有顶点加入 PQ。</p><p>此时 PQ 为：</p><table><thead><tr class="header"><th style="text-align: center;"><code>NULL</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td></tr></tbody></table><hr /><p>至此，第一次 for 迭代结束，索引结果为</p><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(L_1(A)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(B)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(C)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(D)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(E)\)</span></th><th style="text-align: center;"><span class="math inline">\(L_1(F)\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.6, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.4, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 1, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.3, \textrm{pred}= A)\)</span></td><td style="text-align: center;"><span class="math inline">\(A(\textrm{dist} = 0.7, \textrm{pred}= B)\)</span></td></tr></tbody></table><p>类似的处理，可得下图右下角的索引。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><h4 id="extension-of-index-structure">Extension of Index Structure</h4><p>为了支持计算 <code>getSP</code> ，我们需要扩展 <code>L</code> 的索引结构。在<strong>算法 2</strong> 中，对于每一个 hub <span class="math inline">\(v_i\in L(w)\)</span> ，我们不仅仅存储了 <span class="math inline">\(\textrm{dist}(w,v_i)\)</span> ，还存储了以 <span class="math inline">\(v_i\)</span> 为根节点搜索树中 <span class="math inline">\(w\)</span> 的前驱顶点，并将其记作 <span class="math inline">\(\textrm{pred}(w,v_i)\)</span> （Line 16）。</p><p>有了扩展后的索引结构，<code>getSP</code> 就可以通过<strong>算法 3</strong> 计算得到。为了得到顶点 <span class="math inline">\(u,\;v\)</span> 之间的一条最短路径 <span class="math inline">\(p\)</span> ，我们首先在 <span class="math inline">\(p\)</span> 上找到它们所共有的 hub <span class="math inline">\(h_{\textrm{min}}\)</span> （Line 1），然后重复地跟随前驱顶点，构造路径 <span class="math inline">\(p\)</span> 的从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(h_{\textrm{min}}\)</span> 的一段（Line 2-8），以及 <span class="math inline">\(v\)</span> 到 <span class="math inline">\(h_{\textrm{min}}\)</span> 的一段（Line 9-14）。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/Algo3.PNG" alt="Algorithm 3" /><figcaption>Algorithm 3</figcaption></figure><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><p>举个例子，比如计算 <code>getSP(D, F)</code> 。</p><p>首先，<code>L(D)</code> 和 <code>L(F)</code> 的公共 hub 只有一个，就是 <span class="math inline">\(A\)</span>，则 <span class="math inline">\(h_{\textrm{min}} = A\)</span> 。</p><p>然后，通过 <code>pred</code> 信息找到 D-A 的路径，为 D-A ，因为 <code>L(D)</code> 中 <span class="math inline">\(A\)</span> 的 <code>pred</code> 为 <span class="math inline">\(A\)</span>。</p><p>接着，同样的，找到 F-A 的路径，为 F-B-A，因为 <code>L(F)</code> 中的 A 的 <code>pred</code> 为 <span class="math inline">\(B\)</span>，L(B) 中的 <span class="math inline">\(A\)</span> 的 <code>pred</code> 为 <span class="math inline">\(A\)</span>。</p><p>最后，将上面两个子路径连起来，我们就找到了路径 <span class="math inline">\(p\)</span>，为 D-A-B-F。</p><h2 id="keykg-with-dynamic-hl">KeyKG+ With Dynamic HL</h2><h3 id="dynamic-hl">Dynamic HL</h3><h4 id="features">Features</h4><ul><li><strong>查询相关的</strong>（<em>query-relevant</em>）</li><li><strong>在线构造的</strong>（<em>online constructed</em>）</li></ul><h4 id="definition-and-structure">Definition and structure</h4><p>一个动态 HL 是一个 <span class="math inline">\((g-1)\times n\)</span> 的矩阵，记作 <span class="math inline">\(M\)</span> 。行对应于关键词顶点集 <span class="math inline">\(K_2,K_3,\dots,K_g\)</span> ，列对应于 hub 顶点。<span class="math inline">\(M\)</span> 的第 <span class="math inline">\((i-1)\)</span> 行（记作 <span class="math inline">\(M_{i-1}\)</span>）倒排并且聚集了 <span class="math inline">\(K_i\)</span> 中顶点的静态索引标签。<span class="math inline">\(M_{i-1}\)</span> 的第 j 个元素（记作 <span class="math inline">\(M_{i-1,j}\)</span>）是非空的，如果 <span class="math inline">\(h_j\in V\)</span> 是一个 hub，并且它在 <span class="math inline">\(K_i\)</span> 的至少一个顶点的静态索引标签中。在 <span class="math inline">\(K_i\)</span> 中的这些顶点中（这些顶点的静态索引标签包括 <span class="math inline">\(h_j\)</span>），<span class="math inline">\(M_{i-1, j}\)</span> 代表了最小化到达 <span class="math inline">\(h_j\)</span> 的距离的顶点。如果， <span class="math inline">\(h_j\)</span> 不是一个在 <span class="math inline">\(K_i\)</span> 中任意一个顶点的索引标签中的 hub，那么我们令 <span class="math inline">\(M_{i-1, j}\)</span> 为 null： <span class="math display">\[M_{i-1,j}=\begin{cases}&amp;\underset{u\in K_i\; s.t.\; h_j\in L(u)}{\textrm{argmin}}\textrm{dist}(u, h_j)&amp;h_j\in \bigcup_{u\in K_i}L(u),\\&amp;null&amp;h_j\not\in \bigcup_{u\in K_i}L(u),\end{cases}\]</span> 具体的，论文中使用<strong>二维数组</strong>存储矩阵 <span class="math inline">\(M\)</span> ，因此可以支持常数时间的随机访问。对于每一个不为 null 的 <span class="math inline">\(M_{i-1, j}\)</span> ，与 <span class="math inline">\(h_j\)</span> 的距离也是先计算出来，并保存到 <span class="math inline">\(M\)</span> 中。</p><h4 id="example">Example</h4><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><ul><li><span class="math inline">\(i = 2\)</span> 时，<span class="math inline">\(K_2=\{E\}\)</span> ，<span class="math inline">\(L(E) = \{A,B,E\}\)</span> ，因此矩阵 <span class="math inline">\(M\)</span> <span class="math inline">\(K_2\)</span> 行只有 <span class="math inline">\(A,B,E\)</span> 不为 null，其他都为 null；由于 <span class="math inline">\(K_2\)</span> 中只有一个元素 <span class="math inline">\(E\)</span> ，故 <span class="math inline">\(K_2\)</span> 行 <span class="math inline">\(A,B,E\)</span> 列中的元素都为 <span class="math inline">\(E\)</span> 和到它的距离（从 <span class="math inline">\(L(E)\)</span> 中直接取得）。</li><li><span class="math inline">\(i = 3\)</span> 时，<span class="math inline">\(K_3=\{C,D\}\)</span> ，<span class="math inline">\(L(C)\cup L(D) = \{A,C,D\}\)</span> ，因此矩阵 <span class="math inline">\(M\)</span> <span class="math inline">\(K_3\)</span> 行只有 <span class="math inline">\(A,C,D\)</span> 不为 null，其他都为 null；由于 <span class="math inline">\(K_3\)</span> 中有两个元素，故 <span class="math inline">\(K_3\)</span> 行 <span class="math inline">\(A,C,D\)</span> 列中的元素需要对比一下分别到 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span> 的距离，选择较小的存入矩阵 <span class="math inline">\(M\)</span> （比如 <span class="math inline">\(M_{K_3, A}\)</span> ，由于 <span class="math inline">\(\textrm{dist}(C,A) &lt; \textrm{dist}(D,A)\)</span>，所以将 <span class="math inline">\(C\)</span> 存入矩阵）。</li></ul><p>综上所示，矩阵 <span class="math inline">\(M\)</span> 如下图所示：</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/11/matrix-M.PNG" alt="Dynamic HL Example" /><figcaption>Dynamic HL Example</figcaption></figure><h3 id="algorithm-keykg-1">Algorithm KeyKG+</h3><h4 id="algorithm-explained-1">Algorithm Explained</h4><p>KeyKG+ 如<strong>算法 4</strong> 所示。这个算法主要构造了动态 HL，并将其使用在两个方面，提高执行的总体性能，并且对最终结果没有任何影响。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/11/Algo4.PNG" alt="Algorithm 4" /><figcaption>Algorithm 4</figcaption></figure><p>在第一部分，首先，为 <span class="math inline">\(K_2,\dots,K_g\)</span> 构造矩阵 <span class="math inline">\(M\)</span> （Line 1-3）。然后，按照如下流程利用 <span class="math inline">\(M_{i-1}\)</span> 找到 <span class="math inline">\(v_i\)</span> （Line 6）。对于每一个 hub <span class="math inline">\(h_j\in L(v_1)\)</span> ，我们从 <span class="math inline">\(L(v_1)\)</span> 中取得 <span class="math inline">\(\textrm{dist}(v_1,h_j)\)</span> ，并且从 <span class="math inline">\(M_{i-1}\)</span> 中取 <span class="math inline">\(M_{i-1, j}\)</span> 元素的 <span class="math inline">\(\textrm{dist}(M_{i-1,j},h_j)\)</span> 。如果 <span class="math inline">\(M_{i-1,j}\)</span> 非空，那么我们计算： <span class="math display">\[\textrm{dist}(v_1,h_j)+\textrm{dist}(M_{i-1,j},h_j)\]</span> 这个结果表示了 <span class="math inline">\(v_1\)</span> 到在 <span class="math inline">\(K_i\)</span> 中经过一个特定的 <span class="math inline">\(h_j\)</span> 所能到达的顶点之间的最短距离。最后， 通过如下方式，找到 <span class="math inline">\(v_i\)</span> ： <span class="math display">\[v_i=\underset{M_{i-1, j}\; s.t.\; h_j\in L(v_1)\; \textrm{and}\; M_{i-1, j}\ne \textrm{null}}{\textrm{argmin}} \textrm{dist}(v_1,h_j)+\textrm{dist}(M_{i-1,j},h_j)\]</span> KeyKG+ Line 6 计算得到的 <span class="math inline">\(v_i\)</span> 和 KeyKG Line 3 得到的 <span class="math inline">\(v_i\)</span> 等价，但是 KeyKG+ 的效率更高。</p><p>第二部分，我们像为 <span class="math inline">\(K_i\)</span> 创建 <span class="math inline">\(M_{i-1}\)</span> 一样，为 <span class="math inline">\(V_{T_u}\)</span> （Line 14）创建 <span class="math inline">\(M&#39;_{u}\)</span> 。随着 <span class="math inline">\(T_u\)</span> 在每次迭代中逐渐扩展（Line 21），<span class="math inline">\(M&#39;_{u}\)</span> 通过加入到 <span class="math inline">\(T_u\)</span> 的顶点的静态索引标签得到更新（Line 22）。对于每一个 <span class="math inline">\(t_i\in(U_x\backslash V_{T_u})\)</span> ，<span class="math inline">\(M&#39;_u\)</span> 被用来找到与 <span class="math inline">\(t_i\)</span> 距离最短的顶点 <span class="math inline">\(s_i\in V_{T_u}\)</span> （Line 16-18）。我们在所有的这样的 <span class="math inline">\(&lt;s_i,t_i&gt;\)</span> 中找到最小的 <span class="math inline">\(&lt;s_{\textrm{min}},t_{\textrm{min}}&gt;\)</span> （Line 19）</p><p>KeyKG+ Line 16-19 计算得到的 <span class="math inline">\(&lt;s_{\textrm{min}},t_{\textrm{min}}&gt;\)</span> 和 KeyKG Line 12 得到的 <span class="math inline">\(&lt;s_{\textrm{min}},t_{\textrm{min}}&gt;\)</span> 等价，但是 KeyKG+ 的效率更高。</p><h4 id="running-example-1">Running Example</h4><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/10/example-of-KeyKG.PNG" alt="KeyKG 执行的例子" /><figcaption>KeyKG 执行的例子</figcaption></figure><p>如上图，</p><ul><li>令 <span class="math inline">\(B\in K_1\)</span> 为 <span class="math inline">\(v_1\)</span> ，查询其 Static HL，得到 <span class="math inline">\(L(B) = \{A,B\}\)</span> ；<ul><li>因为 <span class="math inline">\(M_{1,A} = M_{1,B} = E\)</span> ，所以令 <span class="math inline">\(E\in K_2\)</span> 为 <span class="math inline">\(v_2\)</span> ；</li><li>因为 <span class="math inline">\(M_{2,A} = C, M_{2,B} = \textrm{null}\)</span> ，所以令 <span class="math inline">\(C\in K_3\)</span> 为 <span class="math inline">\(v_3\)</span> ；</li><li>这样就形成了 <span class="math inline">\(U_B=\{B,E,C\}\)</span> （这与算法 KeyKG 得到的结果是一致的）</li></ul></li><li>令 <span class="math inline">\(F\in K_1\)</span> 为 <span class="math inline">\(v_1\)</span> ，查询其 Static HL，得到 <span class="math inline">\(L(F) = \{A,B,F\}\)</span> ；<ul><li>因为 <span class="math inline">\(M_{1,A} = M_{1,B} = E, M_{1,F} = \textrm{null}\)</span> ，所以令 <span class="math inline">\(E\in K_2\)</span> 为 <span class="math inline">\(v_2\)</span> ；</li><li>因为 <span class="math inline">\(M_{2,A} = C, M_{2,B} = M_{2,F} = \textrm{null}\)</span> ，所以令 <span class="math inline">\(C\in K_3\)</span> 为 <span class="math inline">\(v_3\)</span> ；</li><li>这样就形成了 <span class="math inline">\(U_F=\{F,E,C\}\)</span> （这与算法 KeyKG 得到的结果是一致的）</li></ul></li></ul><div class="note default"><p><strong>TODO</strong>：另一半的例子怎么解释？？？</p></div><h1 id="how-much">How much？</h1><ul><li>基于 <em>betweenness centrality</em> 的启发式方法构建的 <em>Static Hub Labelings</em> 超越了现存的方案。</li><li><em>Dynamic Hub Labelings</em> 则通过倒排并聚集查询相关的静态标签，加速了总体的查询效率。</li></ul><h1 id="what-then">What Then？</h1><ul><li>寻找支持更高效地边删除（<em>edge deletion</em>）的解决方案</li><li>KeyKG+ 的近似比率可以进一步得到提高</li><li>现存 HL 方案无法处理巨大而稠密的图。</li></ul><h1 id="problems-to-solve">Problems to Solve</h1><ul><li><input type="checkbox" disabled="" />Hub Labeling<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></li><li><input type="checkbox" disabled="" />pruned landmark labeling <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></li><li><input type="checkbox" disabled="" />PLL<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></li><li><input type="checkbox" disabled="" />between centrality？？？【10】 <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> vs 【4】<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></li></ul><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>Ittai Abraham, Daniel Delling, Andrew V. Goldberg, and Renato Fonseca F. Werneck. 2011. A Hub-Based Labeling Algorithm for Shortest Paths in Road Networks. In SEA. 230–241.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩</a></p></li><li id="fn2" role="doc-endnote"><p>Takuya Akiba, Yoichi Iwata, and Yuichi Yoshida. 2013. Fast exact shortest-path distance queries on large networks by pruned landmark labeling. In SIGMOD. 349–360<a href="#fnref2" class="footnote-back" role="doc-backlink">↩</a></p></li><li id="fn3" role="doc-endnote"><p>Takuya Akiba, Yoichi Iwata, and Yuichi Yoshida. 2013. Fast exact shortest-path distance queries on large networks by pruned landmark labeling. In SIGMOD. 349–360<a href="#fnref3" class="footnote-back" role="doc-backlink">↩</a></p></li><li id="fn4" role="doc-endnote"><p>Ulrik Brandes. 2001. A faster algorithm for betweenness centrality. J. Math. Soc. 25, 2 (2001), 163–177.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩</a></p></li><li id="fn5" role="doc-endnote"><p>Ziyad AlGhamdi, Fuad Jamour, Spiros Skiadopoulos, and Panos Kalnis. 2017. A Benchmark for Betweenness Centrality Approximation Algorithms on Large Graphs. In SSDBM<a href="#fnref5" class="footnote-back" role="doc-backlink">↩</a></p></li></ol></section>]]></content>
        <author>
            <name><![CDATA[CosmosNing的个人博客]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://cosmosning.github.io/2020/09/19/pac-learning-and-its-variants/</id>
        <title><![CDATA[PAC 模型及其变体]]></title>
        <updated>2021-05-14T12:17:25+08:00</updated>
        <link href="https://cosmosning.github.io/2020/09/19/pac-learning-and-its-variants/"/>
        <content type="text/html" src="https://cosmosning.github.io/2020/09/19/pac-learning-and-its-variants/"><![CDATA[<blockquote><p>本文将介绍通用的学习模型 PAC 及其变体形式。</p><ul><li><p>最原始的 PAC 主要需要满足<strong>可实现假设</strong>，<strong>训练样本量要大于样本复杂度函数</strong>。</p></li><li><p>现实情况中，<strong>可实现假设难以满足</strong>（先验知识不一定猜得准），因此<strong>将目标标记函数改为数据-标签分布，并从中采样训练样本</strong>，就可以类似的得到 Agnostic PAC 。</p></li><li><p>原始的 PAC 中，标记函数将学习问题限制在二元分类任务中。为了获得更加通用的学习模型，我们定义更加一般的损失函数。通过损失函数，可计算真实误差和经验风险：</p></li></ul><blockquote><ul><li><p>在<strong>问题分布</strong>（<span class="math inline">\(\mathcal{D}\)</span>）上采样得到的误差函数的<strong>期望</strong>，作为<strong>真实误差</strong>；</p></li><li><p>在<strong>训练样本</strong>（<span class="math inline">\(S\)</span>）上采样得到的误差函数的<strong>平均值</strong>，作为<strong>经验风险</strong>；</p></li></ul></blockquote></blockquote><h1 id="pac-learning">PAC Learning</h1><p>在<a href="/2020/09/16/statistical-learning-framework-and-empirical-risk-minimization/">上一篇文章</a>中，我们证明了对于一个有限的假设集，<mark>如果拥有足量的训练样本（这些训练样本是从同一分布中独立采样，并被同一标记函数标记而生成的），ERM 会输出近似正确的假设</mark>。更一般的，我们定义 <em>Probably Approximately Correct Learning</em> （PAC）如下：</p><div class="note primary"><p><strong>Def. PAC Learnability</strong></p><p>如果</p><ul><li>存在一个函数 <span class="math inline">\(m_{\mathcal{H}}:(0,1)^2\rightarrow \mathbb{N}\)</span> ，</li><li>并且存在一个学习算法满足以下条件：<ul><li>对于任意的 <span class="math inline">\(\epsilon, \delta\in(0,1)\)</span> ，任意的 <span class="math inline">\(\mathcal{X}\)</span> 上的分布 <span class="math inline">\(\mathcal{D}\)</span> ，任意的标记函数 <span class="math inline">\(f: \mathcal{X}\rightarrow \lbrace 0,1\rbrace\)</span> ，如果对于 <span class="math inline">\(\mathcal{H,D},f\)</span> 可实现假设（<em>realizability assumption</em> ，即 <span class="math inline">\(\exists\ h^\star\in \mathcal{H}, L_{D,f}(h^\star) = 0\)</span>）成立，那么当学习算法的训练样本量 <span class="math inline">\(m \ge m_{\mathcal{H}}(\epsilon, \delta)\)</span> 时（这些训练样本是由从 <span class="math inline">\(\mathcal{D}\)</span> 中独立采样，并被 <span class="math inline">\(f\)</span> 标记而生成的），学习算法会以至少 <span class="math inline">\(1 - \delta\)</span> 的概率返回一个假设 <span class="math inline">\(h\)</span>，并且该假设满足 <span class="math inline">\(L_{(\mathcal{D},f)}(h) \le \epsilon\)</span></li></ul></li></ul><p>则一个假设类 <span class="math inline">\(\mathcal{H}\)</span> 是 PAC 可学习的</p></div><div class="note info"><p><strong>有关 PAC Learnability 的补充说明</strong></p><ul><li><span class="math inline">\(\epsilon\)</span> 称作<strong>精度参数</strong>（<em>accuracy parameter</em>），代表输出分类器与最优之间的误差大小（对应 PAC 中的 <strong><em>approximately correct</em></strong>）。这意味着，<span class="math inline">\(\epsilon\)</span> 允许学习算法犯一些小错误。</li><li><span class="math inline">\(\delta\)</span> 称作<strong>置信参数</strong>（<em>confidence parameter</em>），代表输出分类器满足上述精度要求的可能性（对应 PAC 中的 <strong><em>probably</em></strong>）</li><li><span class="math inline">\(m_{\mathcal{H}}:(0, 1) \rightarrow \mathbb{N}\)</span> 称作<strong>样本复杂度</strong>（<em>sample complexity</em>）函数，表示<strong>需要多少训练样本数据，才能够保证获得一个尽可能近似正确的答案</strong>。该函数依赖于 <span class="math inline">\(\epsilon, \delta,\mathcal{H}\)</span> 。依据 PAC Learnability 的定义，存在不止一个 <span class="math inline">\(m_{\mathcal{H}}\)</span> 满足条件。通常，我们定义 <span class="math inline">\(m_{\mathcal{H}}\)</span> 为满足条件的<strong>最小整数</strong>。</li></ul></div><p>对上一篇文章中获得的结论，我们换一种表达，则有下面的推论</p><div class="note default"><p><strong>PAC 可学习的样本复杂度条件</strong></p><p>每一个有限假设类都是 PAC 可学习的，只要它的样本复杂度满足： <span class="math display">\[m_{\mathcal{H}} \le \lceil \frac{log(\frac{\mathcal{H}}{\delta})}{\epsilon} \rceil\]</span></p></div><h1 id="a-more-general-learning-model">A More General Learning Model</h1><p>对于大多数任务，可实现假设很难得到满足，而且上述定义只适用于二元分类问题，因此通用性不佳。为了得到更加通用的学习模型，我们对上述模型从以下两个方面进行拓展：</p><ol type="1"><li>去除可实现假设。引入 <strong>Agnostic PAC</strong> 解决这个问题。</li><li>学习比二元分类问题更加广泛的任务。通过对<strong>损失函数的一般化</strong>来支持这种拓展。</li></ol><h2 id="releasing-the-realizablity-assumption-agnostic-pac-learning">Releasing the Realizablity Assumption —— Agnostic PAC Learning</h2><h3 id="a-more-realistic-model-for-the-data-generating-distribution">A More Realistic Model for the Data-Generating Distribution</h3><p>简单来说，我们可以将 “目标标记函数” 替换为<strong>数据-标签</strong>生成分布。</p><p>规范地，设 <span class="math inline">\(\mathcal{D}\)</span> 为 <span class="math inline">\(\mathcal{X} \times \mathcal{Y}\)</span> 上的概率分布，其中 <span class="math inline">\(\mathcal{X}\)</span> 为领域集，<span class="math inline">\(\mathcal{Y}\)</span> 为标签集。也就是说，<span class="math inline">\(\mathcal{D}\)</span> 为在领域点和标签上的联合分布。我们可以将 <span class="math inline">\(\mathcal{D}\)</span> 看作由两个部分组成：一个在未被标记的领域点上的分布 <span class="math inline">\(\mathcal{D}_x\)</span> （有时候，也称作<strong>边缘分布</strong>） ，另一个为每一个领域点的标签上的<strong>条件概率</strong> <span class="math inline">\(\mathcal{D}((x,y)|x)\)</span> 。</p><div class="note info"><p><strong>如何理解条件概率？</strong></p><ul><li>很多事情无法精确刻画，因此可用一个条件分布来描述。随着某一变量的变化，对应事件的概率也会发生变化。例如，<span class="math inline">\(\mathcal{D}(y|x)\)</span> 事件 <span class="math inline">\(y\)</span> 的概率会随着 <span class="math inline">\(x\)</span> 的变化而变化；此外，在 <span class="math inline">\(\mathcal{D}(y|x)\)</span> 中，<span class="math inline">\(\mathcal{D}(y|x)\)</span> 是关于 <span class="math inline">\(y\)</span> 的函数，而 <span class="math inline">\(x\)</span> 是作为函数的参数（如果要确定关于 <span class="math inline">\(y\)</span> 的函数关系，<span class="math inline">\(x\)</span> 要事先指定）。</li></ul></div><h3 id="the-empirical-and-true-error-revised">The Empirical and True Error Revised</h3><p>与分布的改变相对应，我们定义预测规则 <span class="math inline">\(h\)</span> <strong>真实误差</strong>（或者叫做<strong>风险</strong>）如下： <span class="math display">\[L_{\mathcal{D}}\overset{def}{=}\underset{(x,y)\sim \mathcal{D}}{\mathbb{P}}[h(x)\ne y] \overset{def}{=}\mathcal{D}(\lbrace (x,y): h(x) \ne y \rbrace) \tag{3.1}\]</span> 而经验风险并没有改变，依然是： <span class="math display">\[L_{S}(h)\overset{def}{=}\frac{|\lbrace i\in[m] : h(x_i) \ne y_i \rbrace|}{m}\]</span></p><h3 id="the-goal">The Goal</h3><p>学习算法的目标是寻找一些假设，<span class="math inline">\(h:\mathcal{X}\rightarrow \mathcal{Y}\)</span> ，尽可能近似最小化真实风险，<span class="math inline">\(L_{\mathcal{D}}(h)\)</span></p><h3 id="the-bayes-optimal-predictor">The Bayes Optimal Predictor</h3><p>给定任意的在 <span class="math inline">\(\mathcal{X} \times \lbrace 0,1\rbrace\)</span> 上的概率分布，从 <span class="math inline">\(\mathcal{X}\)</span> 到 <span class="math inline">\(\lbrace 0, 1 \rbrace\)</span> 的最佳标记函数为 <span class="math display">\[f_{\mathcal{D}}(x) = \begin{cases} 1 &amp;if\ \mathbb{P}[y=1|x]\ge \frac{1}{2}\\ 0 &amp; otherwise\end{cases}\]</span> 这也就是说，对于任意的二元分类器 <span class="math inline">\(g: \mathcal{X}\rightarrow \lbrace 0, 1\rbrace\)</span>，<span class="math inline">\(L_{\mathcal{D}}(f_{\mathcal{D}}) \le L_{\mathcal{D}}(g)\)</span></p><div class="note info"><p><strong>证明 The Bayes Optimal Predictor</strong>（TODO）</p></div><p>一旦我们对数据生成分布不做任何预先假设，那么将没有算法将保证找到一个预测器，媲美 Bayes Optimal Predictor 的效果。因此，我们需要学习算法找到一个预测器，在给定某些假设类的基准测试时，<strong>它的误差并不会比可能的最佳的预测器的误差大太多</strong>。因此，我们有如下的 <strong>Agnostic PAC Learnability</strong>：</p><div class="note primary"><p><strong>Def. Agnostic PAC Learnability</strong></p><p>如果</p><ul><li><p>存在一个函数 <span class="math inline">\(m_{\mathcal{H}}:(0,1)^2\rightarrow \mathbb{N}\)</span> ，</p></li><li><p>并且存在一个学习算法满足以下条件：</p><ul><li>对于任意的 <span class="math inline">\(\epsilon, \delta\in(0,1)\)</span> ，任意的 <span class="math inline">\(\mathcal{X} \times\mathcal{Y}\)</span> 上的分布 <span class="math inline">\(\mathcal{D}\)</span> ，当学习算法的训练样本量 <span class="math inline">\(m \ge m_{\mathcal{H}}(\epsilon, \delta)\)</span> 时（这些训练样本是由从 <span class="math inline">\(\mathcal{D}\)</span> 中独立采样而生成的），学习算法会以至少 <span class="math inline">\(1 - \delta\)</span> 的概率返回一个假设 <span class="math inline">\(h\)</span>，并且该假设满足： <span class="math display">\[L_{\mathcal{D}}(h) \le \underset{h&#39;\in\mathcal{H}}{min}L_D(h&#39;) + \epsilon\]</span></li></ul></li></ul><p>则一个假设类 <span class="math inline">\(\mathcal{H}\)</span> 是 Agnostic PAC 可学习的</p></div><h2 id="generalized-loss-function-agnostic-pac-learning-for-general-loss-function">Generalized Loss Function —— Agnostic PAC Learning for General Loss Function</h2><p>为了适应不同的任务，我们接下来定义通用的损失函数。</p><p>给定任意的集合 <span class="math inline">\(\mathcal{H}\)</span> 和领域集 <span class="math inline">\(Z\)</span> ，设 <span class="math inline">\(l\)</span> 为任意 <span class="math inline">\(\mathcal{H}\times Z\)</span> 到非负实数的函数， <span class="math inline">\(l: \mathcal{H} \times Z \rightarrow \mathbb{R}_+\)</span> ，我们称 <span class="math inline">\(l\)</span> 为<strong>损失函数</strong>。</p><p>下面用分类器误差的期望来定义<strong>风险函数</strong>。</p><p>给定一个 <span class="math inline">\(h\in \mathcal{H}\)</span> ，关于在 <span class="math inline">\(Z\)</span> 上的概率分布 <span class="math inline">\(\mathcal{D}\)</span> ，对应的风险函数为： <span class="math display">\[L_{\mathcal{D}}(h)\overset{def}{=}\underset{z\sim \mathcal{D}}{\mathbb{E}}[l(h,z)]\tag{3.3}\]</span> 相似的，经验风险函数为对采样样本 <span class="math inline">\(S=(z_1,\dots,z_m)\in Z^m\)</span> 上的损失的期望： <span class="math display">\[L_S(h)\overset{def}{=}\frac{1}{m}\sum_{i=1}^{m}l(h,z_i)\tag{3.4}\]</span> 综上所述，有如下更加通用的 Agnostic PAC 的定义：</p><div class="note primary"><p><strong>Def. Agnostic PAC Learning for General Loss Function</strong></p><p>如果</p><ul><li><p>存在一个函数 <span class="math inline">\(m_{\mathcal{H}}:(0,1)^2\rightarrow \mathbb{N}\)</span> ，</p></li><li><p>并且存在一个学习算法满足以下条件：</p><ul><li>对于任意的 <span class="math inline">\(\epsilon, \delta\in(0,1)\)</span> ，任意的 <span class="math inline">\(Z\)</span> 上的分布 <span class="math inline">\(\mathcal{D}\)</span> ，当学习算法的训练样本量 <span class="math inline">\(m \ge m_{\mathcal{H}}(\epsilon, \delta)\)</span> 时（这些训练样本是由从 <span class="math inline">\(\mathcal{D}\)</span> 中独立采样而生成的），学习算法会以至少 <span class="math inline">\(1 - \delta\)</span> 的概率返回一个假设 <span class="math inline">\(h\in \mathcal{H}\)</span>，并且该假设满足 <span class="math display">\[L_{\mathcal{D}}(h) \le \underset{h&#39;\in\mathcal{H}}{min}L_{\mathcal{D}}(h&#39;)+ \epsilon\]</span> 其中 <span class="math inline">\(L_{\mathcal{D}}(h) = \mathbb{E}_{z\sim D}[l(h, z)]\)</span></li></ul></li></ul><p>则一个假设类 <span class="math inline">\(\mathcal{H}\)</span> 关于一个集合 <span class="math inline">\(Z\)</span> 和 损失函数 <span class="math inline">\(l:\mathcal{H}\times Z\rightarrow \mathbb{R}_+\)</span> 是 Agnostic PAC 可学习的</p></div><h1 id="reference">Reference</h1><p>Shai Shalev-Shwartz, Shai Ben-David. <a href="https://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/index.html" target="_blank" rel="noopener">Understanding Machine Learning: From Theory to Algorithms</a></p>]]></content>
        <author>
            <name><![CDATA[CosmosNing的个人博客]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://cosmosning.github.io/2020/09/16/statistical-learning-framework-and-empirical-risk-minimization/</id>
        <title><![CDATA[统计学习框架及经验风险最小化]]></title>
        <updated>2021-05-14T12:17:25+08:00</updated>
        <link href="https://cosmosning.github.io/2020/09/16/statistical-learning-framework-and-empirical-risk-minimization/"/>
        <content type="text/html" src="https://cosmosning.github.io/2020/09/16/statistical-learning-framework-and-empirical-risk-minimization/"><![CDATA[<blockquote><p>本文主要介绍两个内容：</p><ol type="1"><li><strong>统计学习框架</strong>。这是一个十分通用的框架，指明了学习的<strong>输入</strong>、<strong>输出</strong>和<strong>学习目标</strong>。</li><li><strong>经验风险最小化</strong>（<strong>ERM</strong>）的学习方法。引入<strong>经验风险</strong>，从而可以<strong>从训练数据中管中窥豹</strong>，归纳出一般规律。但是 ERM <strong>会产生过拟合</strong>现象。一种常见的解决方案是<strong>引入归纳偏好</strong>（或者是先验知识）。具体来说，确定一个有<strong>限的假设类</strong>集合，供学习算法学习。这样是否是有效的？通过证明发现，<strong>只要有足够的训练样本，就可以达到比较好的效果</strong>。</li></ol></blockquote><h1 id="a-formal-model-the-statistical-learning-framework">A Formal Model —— The Statistical Learning Framework</h1><h2 id="the-learners-input">The Learner's Input</h2><ul><li><strong>领域集（<em>Domain set</em>）</strong>：这是我们<strong>希望标记的事物的集合</strong>，记作 <span class="math inline">\(\mathcal{X}\)</span> 。通常情况下，人们会用一个特性向量（vector of <em>features</em>）表示这些领域点（<em>domain points</em>）。</li></ul><div class="note info"><ul><li>领域集（<em>domain set</em>）又称作实例空间（<em>instance space</em>）</li><li>领域点（<em>domain points</em>）又称作实例（<em>instances</em>）</li></ul></div><ul><li><strong>标签集（<em>Label set</em>）</strong>：这是<strong>可能的标签的集合</strong>，记作 <span class="math inline">\(\mathcal{Y}\)</span> 。</li><li><strong>训练数据（<em>Training data</em>）</strong>：这是一系列已经被标记的领域点，常常表示为 <span class="math inline">\(S=((x_1,\ y_1)\dots(x_m,\ y_m))\)</span> （这是在 <span class="math inline">\(\mathcal{X}\times \mathcal{Y}\)</span> 中的<strong>有限</strong>的数对序列）</li></ul><div class="note info"><ul><li>训练数据（<em>training data</em>）又称作 <strong><em>training examples</em></strong>，或者 <strong><em>training set</em></strong></li></ul></div><h2 id="the-learners-output">The Learner's Output</h2><p>人们希望学习器输出一个<strong>预测规则</strong>（<em>prediction rule</em>）：<span class="math inline">\(h:\mathcal{X} \rightarrow \mathcal{Y}\)</span> 。这个函数又称作为<strong>预测器</strong>（<em>predictor</em>）、<strong>假设</strong>（<em>hypothesis</em>）或者是<strong>分类器</strong>（<em>classifier</em>）。此外，我们记一个学习算法 <span class="math inline">\(A\)</span> ，接受训练数据 <span class="math inline">\(S\)</span> 为输入，返回对应假设为 <span class="math inline">\(A(S)\)</span> 。</p><h2 id="a-simple-data-generation-model">A Simple Data-generation Model</h2><p>训练数据是如何生成的？这里给出两个假设。</p><ul><li>假设所有的实例都由一个概率分布生成，记这个在 <span class="math inline">\(\mathcal{X}\)</span> 上的概率分布为 <span class="math inline">\(\mathcal{D}\)</span> 。</li><li>假设存在一个“完全正确”的标记函数 <span class="math inline">\(f:\mathcal{X}\rightarrow \mathcal{Y}\)</span> ，显然，对于任意的 <span class="math inline">\(i\)</span> ，有 <span class="math inline">\(y_i=f(x_i)\)</span></li></ul><p>总的来说，在训练数据中的每一个数对，都由以下方式生成：</p><ol type="1"><li>先从概率分布 <span class="math inline">\(\mathcal{D}\)</span> 采样得到一个点 <span class="math inline">\(x_i\)</span> ；</li><li>再利用标记函数 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(x_i\)</span> 打上标签。</li></ol><h2 id="measures-of-success">Measures of Success</h2><p>如何衡量算法学习是否成功？这里可以定义一个<strong>分类器的误差</strong>（<em>error of a classifier</em>），即学习算法没有正确预测随机数据（这些随机数据，是由前面提到的对于学习算法隐含的概率分布所生成的）的标签的概率。也就是说，<span class="math inline">\(h\)</span> 的误差是<strong>从分布 <span class="math inline">\(\mathcal{D}\)</span> 随机中取出一个 <span class="math inline">\(x\)</span> ，而 <span class="math inline">\(h(x)\)</span> 不等于 <span class="math inline">\(f(x)\)</span> 的概率</strong>。</p><p>规范的来讲，给定一个领域子集（<em>domain subset</em>），<span class="math inline">\(A\subset \mathcal{X}\)</span> ，概率分布 <span class="math inline">\(\mathcal{D}\)</span> ，定义一个数 <span class="math inline">\(\mathcal{D}(A)\)</span> ，其中 <span class="math inline">\(\mathcal{D}(A)\)</span> 表示学习算法在 <span class="math inline">\(\mathcal{D}\)</span> 中观察到一个点 <span class="math inline">\(x\in A\)</span> 的可能性。我们定义预测规则（<em>prediction rule</em>）的误差如下： <span class="math display">\[L_{\mathcal{D},f}(h)\overset{def}{=}\underset{x\sim\mathcal{D}}{\mathbb{P}}[h(x)\ne f(x)]\overset{def}{=}\mathcal{D}(\lbrace x:h(x)\ne f(x)\rbrace)\tag{2.1}\]</span> <div class="note info"><p><strong>有关 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(\mathcal{D}(A)\)</span> 的补充说明</strong></p><ul><li>在许多情况下，我们将 <span class="math inline">\(A\)</span> 称作一个事件（<em>event</em>）</li><li>二元分类问题中，我们定义 <span class="math inline">\(A\)</span> 为 <span class="math inline">\(\pi :\mathcal{X}\rightarrow \lbrace0,1\rbrace\)</span> ，也就有 <span class="math inline">\(A = \lbrace x\in\mathcal{X}: \pi(x) = 1\rbrace\)</span> 。在这种情况下，我们也使用 <span class="math inline">\(\mathbb{P}_{x\sim \mathcal{D}}[\pi(x)]\)</span> 来表达 <span class="math inline">\(\mathcal{D}(A)\)</span> 。</li></ul></div></p><div class="note info"><p><strong><span class="math inline">\(L_{\mathcal{D},f}\)</span> 的别称</strong></p><p><span class="math inline">\(L_{\mathcal{D},f}\)</span> 又称作<strong>泛化误差</strong>（<strong><em>generalization error</em></strong>），<strong>风险</strong>（<strong><em>risk</em></strong>），<strong><span class="math inline">\(h\)</span> 的真正误差</strong>（<strong><em>true error</em> of h</strong>）</p></div><h2 id="a-note-about-the-information-available-to-the-learner">A Note about The Information Available to The Learner</h2><p>要注意的是，<strong>学习器本身并不知晓隐含的概率分布 <span class="math inline">\(\mathcal{D}\)</span> 和 “完全正确” 的标记函数 <span class="math inline">\(f\)</span></strong> 。因此，学习器只能通过观察训练数据集，和环境交互，才能发现规律。</p><div class="note info"><h2 id="summary">Summary</h2><ul><li><strong>学习算法的输入和输出</strong>：一个学习算法接受一个<strong>训练集</strong> <span class="math inline">\(S\)</span> 作为<strong>输入</strong>，并且<strong>输出</strong>一个<strong>预测器</strong>（<em>predictor</em>） <span class="math inline">\(h_S: \mathcal{X} \rightarrow \mathcal{Y}\)</span> 。其中，训练集 <span class="math inline">\(S\)</span> 通过以下过程生成：首先从一个未知分布 <span class="math inline">\(D\)</span> 中采样，然后使用目标函数（<em>target function</em>） <span class="math inline">\(f\)</span> 标记。此外，预测器 <span class="math inline">\(h_S\)</span> 的下标 <span class="math inline">\(S\)</span> 强调了输出的 <span class="math inline">\(h_S\)</span> 是依赖于 <span class="math inline">\(S\)</span> 的。</li><li><strong>学习算法的目标</strong>：学习算法的目标是找到一个 <span class="math inline">\(h_S\)</span> ，关于未知分布 <span class="math inline">\(\mathcal{D}\)</span> 和标记函数 <span class="math inline">\(f\)</span> ，它能最小化误差。</li></ul></div><h1 id="empirical-risk-minimization-erm">Empirical Risk Minimization （ERM）</h1><h2 id="empirical-error">Empirical Error</h2><p>由于学习器并不知道 <span class="math inline">\(\mathcal{D}\)</span> 和 <span class="math inline">\(f\)</span> ，因此，式（2.1）无法直接计算。学习器能够计算的是<strong>训练误差</strong>（<em>training error</em>），即分类器在训练数据上产生的误差，其定义如下： <span class="math display">\[L_S(h)\overset{def}{=}\frac{|\lbrace i\in[m]:h(x_i)\ne y_i \rbrace|}{m}\tag{2.2}\]</span></p><p>其中 <span class="math inline">\([m]=\lbrace 1,\dots ,m\rbrace\)</span> 。</p><div class="note info"><p><strong>训练误差</strong>（<em>training error</em>）有时又称作<strong>经验误差</strong>（<strong><em>empirical error</em></strong>）或者<strong>经验风险</strong>（<strong><em>empirical risk</em></strong>）</p></div><h2 id="erm">ERM</h2><p>既然学习算法能够从训练数据中获取关于这个世界的简要情况，所以寻找一个在训练数据上效果良好的答案是说得通的。<strong>寻找一个最小化 <span class="math inline">\(L_S(h)\)</span> 的 <span class="math inline">\(h\)</span></strong> 的学习范式称作经验风险最小化（<strong>Empirical Risk Minimization</strong>），简称 <strong>ERM</strong></p><h2 id="the-problem-of-erm-overfitting">The problem of ERM —— Overfitting</h2><p>然而，ERM 可能会产生一种错误——过拟合。下面用一个例子说明。</p><figure><img data-src="https://gitee.com/CosmosNing/MyPicGo/raw/master/images/2020/09/example-of-overfitting.PNG" alt="过拟合的例子. Source:《Understanding Machine Learning: From Theory to Algorithms》" /><figcaption>过拟合的例子. Source:《Understanding Machine Learning: From Theory to Algorithms》</figcaption></figure><p>假设概率分布 <span class="math inline">\(\mathcal{D}\)</span> 是灰色正方形框中的均匀分布，如果实例落在蓝色实例所在的黑色正方形框中，标记函数 <span class="math inline">\(f\)</span> 将其标记为 1，否则标记为 0。考虑如下的预测器：</p><p><span class="math display">\[h_S(x)= \begin{cases}y_i\quad &amp;if\ \exists i\in[m]\ s.t. x_i=x;\\0\quad &amp;ohterwise. \end{cases}\]</span></p><p>因为 <span class="math inline">\(h_S\)</span> 在训练数据上，对实例标签的预测全部正确，所以 <span class="math inline">\(L_S(h_s) = 0\)</span> 。根据经验风险最小化的原则，式子 （2.3）会被 ERM 选中（因为没有比 0 更小的训练损失）。然而如果取训练数据以外的一个点 <span class="math inline">\(x&#39;\)</span>，并且这个点在黑色正方形框中，那么根据式（2.3），<span class="math inline">\(h_S(x&#39;) = 0\)</span> 。而实际上 <span class="math inline">\(f(x&#39;) = 1\)</span>，这就会产生错误。</p><p>这种现象称作<strong>“过拟合”</strong>（<em>overfitting</em>）。直观的来说，当学习算法找到的假设<strong>太符合</strong>训练数据时，就会发生过拟合。</p><h2 id="empirical-risk-minimization-with-inductive-bias">Empirical Risk Minimization with Inductive Bias</h2><h3 id="applying-erm-over-a-restricted-search-space">Applying ERM over a Restricted Search Space</h3><p>一种常见的解决 ERM 过拟合的方法是<strong>限制 ERM 的搜索空间</strong>。规范的讲，在见到数据之前，学习器应该事先挑选出一个预测器集合。这个预测器集合又称作<strong>“假设类”</strong>（<em>hypothesis class</em>），记作 <span class="math inline">\(\mathcal{H}\)</span> 。每一个 <span class="math inline">\(h\in \mathcal{H}\)</span> 是一个 <span class="math inline">\(\mathcal{X}\rightarrow \mathcal{Y}\)</span> 的函数。<strong>给定一个假设类 <span class="math inline">\(\mathcal{H}\)</span> ，一个训练集 <span class="math inline">\(\mathcal{S}\)</span> ，<span class="math inline">\(ERM_{\mathcal{H}}\)</span> 学习器使用 ERM 规则来选取一个在 <span class="math inline">\(\mathcal{S}\)</span> 上有最小可能误差的 <span class="math inline">\(h\)</span> ，其中 <span class="math inline">\(h\in \mathcal{H}\)</span></strong> 。规范地，我们有如下公式： <span class="math display">\[ERM_{\mathcal{H}}(S)\in \underset{h\in \mathcal{H}}{argmin}(L_S(h))\]</span> 其中，<span class="math inline">\(argmin\)</span> 表示在 <span class="math inline">\(\mathcal{H}\)</span> 中使得 <span class="math inline">\(L_S(h)\)</span> 最小的假设集合（<span class="math inline">\(h\in\mathcal{H}\)</span>）。通过限制学习器从 <span class="math inline">\(\mathcal{H}\)</span> 中选取预测器，学习器会偏向我们所特定的预测器集合。这种限制常常被称为<strong>归纳偏好</strong>（<em>inductive bias</em>）。由于这种限制的选择在学习器看到数据之前就确定了，因此在理想情况下，它应该基于一些有关所学问题的先验知识（<em>prior knowledge</em>）。</p><p>直观地，<strong>选择一个首先更多的假设类会更好地防止过拟合的发生，但是与此同时，这可能会导致一个更强的归纳偏好</strong>。</p><h3 id="finite-hypothesis-classes">Finite Hypothesis Classes</h3><p>对类的最简单的限制是设置一个其大小的上界（也就是，限制 <span class="math inline">\(\mathcal{H}\)</span> 中预测器 <span class="math inline">\(h\)</span> 的个数）。对应的，我们有如下结论：</p><ul><li><strong>只要有足够数量的训练样本，如果 <span class="math inline">\(\mathcal{H}\)</span> 是一个有限的类（<em>finite class</em>），那么 <span class="math inline">\(ERM_{\mathcal{H}}\)</span> 将不会产生过拟合。</strong></li></ul><p>那么至少需要多少训练样本呢？下面我们讨论这个问题</p><p>在此之前，我们先引入两个假设：</p><ol type="1"><li><strong>可实现假设</strong>（<strong><em>The Realizability Assumption</em></strong>）：<span class="math inline">\(\exists h^\star \in \mathcal{H},\ L_{(\mathcal{D},f)}(h^\star) = 0\)</span> 。</li><li><strong>独立同分布假设</strong>（<strong><em>The i.i.d. Assumption</em></strong>）：训练数据中每一个样本都关于分布 <span class="math inline">\(\mathcal{D}\)</span> <strong>独立同分布</strong>（<strong>independently and identically distributed</strong>，short for <strong>i.i.d.</strong>），记作 <span class="math inline">\(S\sim D^m\)</span> 。其中， <span class="math inline">\(m\)</span> 是 <span class="math inline">\(S\)</span> 的大小，<span class="math inline">\(D^m\)</span> 表示了根据 <span class="math inline">\(\mathcal{D}\)</span> 采样 <span class="math inline">\(m\)</span> 个元素，构成 <span class="math inline">\(m\)</span> 元组，且每一个元素都独立于 <span class="math inline">\(m\)</span> 元组其他元素</li></ol><div class="note info"><p><strong>有关 <code>可实现假设</code> 和 <code>独立同分布假设</code> 的补充说明</strong></p><ul><li><code>可实现假设</code> 暗示了在随机的训练样本 <span class="math inline">\(S\)</span> ，<span class="math inline">\(S\)</span> 由从 <span class="math inline">\(\mathcal{D}\)</span> 中采样，又被 <span class="math inline">\(f\)</span> 标记所得，<span class="math inline">\(L_S(h^\star) = 0\)</span> 的可能性为 1。</li><li><code>独立同分布假设</code> 表示每一个 <span class="math inline">\(S\)</span> 中 <span class="math inline">\(x_i\)</span> 都是全新地从 <span class="math inline">\(\mathcal{D}\)</span> 中采样，并被 <span class="math inline">\(f\)</span> 标记后生成的。</li></ul></div><p>此外，定义 <span class="math inline">\(\delta\)</span> 为取得一个不具代表性（<em>nonrepresentative</em>）的样本的<strong>概率</strong>，<span class="math inline">\(1-\delta\)</span> 为预测行为的<strong>置信参数</strong>（<em>confidence parameter</em>）。</p><div class="note info"><p><strong>什么叫不具代表性（<em>nonrepresentative</em>）的样本？</strong></p><ul><li>这个样本不能代表实例的潜在规律。如一个水果本身很好吃，但是碰巧训练样本都是不好吃的，导致学习器学到了错误的结论。其中的不好吃的训练样本即是不具代表性的样本。</li></ul></div><p>由于我们不能确保完美的标签预测，因此这里我们进一步引入另一个用来衡量预测效果的参数，即<strong>精度参数</strong>（<em>accuracy parameter</em>）。其通常记作 <span class="math inline">\(\epsilon\)</span> 。我们用如下公式描述学习器是否获得成功：</p><ul><li>事件 <span class="math inline">\(L_{(\mathcal{D},f)}(h_s)&gt;\epsilon\)</span> 表示学习器的<strong>失败</strong></li><li>事件 <span class="math inline">\(L_{(\mathcal{D},f)}(h_S)\le \epsilon\)</span> 表示学习器的<strong>近似成功</strong>。</li></ul><p>令我们感兴趣的是，在由 <span class="math inline">\(m\)</span> 个实例构成的 <span class="math inline">\(m\)</span> 元组采样，会导致学习器失败的概率的<strong>上界</strong>。</p><p>规范的，记 <span class="math inline">\(S|_{x} = \lbrace x_1,\ \dots,\ x_m\rbrace\)</span> 为训练数据的实例，我们希望找到下式的上界：</p><p><span class="math display">\[\mathcal{D}(\lbrace S|_{x} : L_{(\mathcal{D},f)}(h_{S}) &gt; \epsilon \rbrace)\]</span></p><p>记 <span class="math inline">\(\mathcal{H}_B\)</span> 为“坏的”假设，即</p><p><span class="math display">\[\mathcal{H}_B = \lbrace h\in\mathcal{H}: L_{(\mathcal{D},f)}(h) &gt; \epsilon\rbrace\]</span></p><p>再令</p><p><span class="math display">\[M = \lbrace S|_x : \exists h\in \mathcal{H}_B, L_S(h) = 0 \rbrace\]</span></p><p>显然，<span class="math inline">\(M\)</span> 表示了误导学习器的样本集合。换句话说，对于每一个 <span class="math inline">\(S|_x \in M\)</span> ，存在一个坏的假设，<span class="math inline">\(h\in \mathcal{H}_B\)</span> ，但是在 <span class="math inline">\(S|_x\)</span> 中它看上去是一个好的假设。</p><p>既然可实现假设表示存在 <span class="math inline">\(L_S(h_S) = 0\)</span> ，因此，事件 <span class="math inline">\(L_{(\mathcal{D},f)}(h_s)&gt;\epsilon\)</span> 只可能在这种情况下发生：<span class="math inline">\(h\in \mathcal{H}_B\)</span> ，但是 <span class="math inline">\(L_S(h) = 0\)</span> 。也就是说，<strong>如果我们的采样样本在误导集合中，这种事件才会发生</strong>。因此，我们有：</p><p><span class="math display">\[\lbrace S|_{x} : L_{(\mathcal{D},f)}(h_S) &gt; \epsilon\rbrace \subseteq M\]</span></p><p>进一步的，<span class="math inline">\(M\)</span> 可改写成：</p><p><span class="math display">\[M = \underset{h\in \mathcal{H}_B}{\bigcup} \lbrace S|_x : L_S(h) = 0\rbrace \tag{2.5}\]</span></p><p>因此，</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_{(\mathcal{D},f)}(h_S) &gt; \epsilon\rbrace) \le \mathcal{D}^m(M) = \mathcal{D}^m({\cup}_{h\in \mathcal{H}_B} \lbrace S|_x : L_S(h) = 0\rbrace) \tag{2.6}\]</span></p><p>利用 <code>Union Bound</code> 定理，可得：</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_{(\mathcal{D},f)}(h_S) &gt; \epsilon\rbrace) \le \underset{h\in \mathcal{H}_B}{\sum}\mathcal{D}^m(\lbrace S|_x : L_S(h) = 0\rbrace)\tag{2.7}\]</span></p><div class="note info"><p><strong>定理（Union Bound）</strong></p><ul><li>对于两个集合 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 和分布 <span class="math inline">\(\mathcal{D}\)</span> ，有 <span class="math display">\[\mathcal{D}(A\cup B) \le \mathcal{D}(A) + \mathcal{D}(B)\]</span></li></ul></div><p>由于事件 <span class="math inline">\(L_S(h) = 0\)</span> 等价于 <span class="math inline">\(\forall i, h(x_i) = f(x_i)\)</span> ，所以，</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_S(h) = 0\rbrace) = \mathcal{D}^m(\lbrace S|_x : \forall i, h(x_i) = f(x_i) \rbrace)\]</span></p><p>又因为采样训练样本相互独立，且服从同一个分布 <span class="math inline">\(\mathcal{D}\)</span> ，因此，</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : \forall i, h(x_i) = f(x_i) \rbrace) = \prod_{i=1}^{m}\mathcal{D}(\lbrace x_i : h(x_i) = f(x_i) \rbrace)\]</span></p><p>故有</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_S(h) = 0\rbrace) = \prod_{i=1}^{m}\mathcal{D}(\lbrace x_i : h(x_i) = f(x_i) \rbrace) \tag{2.8}\]</span></p><p>对于训练集中每一个独立的元素，有</p><p><span class="math display">\[{D}(\lbrace x_i : h(x_i) = y_i \rbrace) = 1 - L_{(\mathcal{D},f)}\]</span></p><p>由于 <span class="math inline">\(L_{(\mathcal{D},f)}(h_s)&gt;\epsilon\)</span> ，故</p><p><span class="math display">\[{D}(\lbrace x_i : h(x_i) = y_i \rbrace) = 1 - L_{(\mathcal{D},f)} \le 1 - \epsilon\]</span></p><p>利用 <span class="math inline">\(1-\epsilon \le e^{-\epsilon}\)</span> 不等式对上式放缩，有</p><p><span class="math display">\[{D}(\lbrace x_i : h(x_i) = y_i \rbrace) = 1 - L_{(\mathcal{D},f)} \le 1 - \epsilon \le e^{- \epsilon}\]</span></p><p>将上式带入式（2.8），有</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_S(h) = 0\rbrace)\le (1 - \epsilon)^m \le e^{- m\epsilon} \tag{2.9}\]</span></p><p>结合式（2.7），有</p><p><span class="math display">\[\mathcal{D}^m(\lbrace S|_x : L_{(\mathcal{D},f)}(h_S) &gt; \epsilon\rbrace) \le |\mathcal{H}_B|e^{- m\epsilon} \le |\mathcal{H}|e^{- m\epsilon}\]</span></p><p>设 <span class="math inline">\(\mathcal{D}^m(\lbrace S|_x : L_{(\mathcal{D},f)}(h_S) &gt; \epsilon\rbrace) \le |\mathcal{H}|e^{- m\epsilon}&lt; \delta\)</span> ，则有</p><p><span class="math display">\[m &gt; \frac{log(\frac{|\mathcal{H}|}{\delta})}{\epsilon}\]</span></p><div class="note info"><p><strong>推导过程</strong></p><p><span class="math display">\[\delta &gt; |\mathcal{H}|e^{-m\epsilon}\]</span></p><p><span class="math display">\[log\delta &gt; log|\mathcal{H}|-m\epsilon\]</span></p><p><span class="math display">\[m\epsilon &gt; log|\mathcal{H}| - log\delta\]</span></p><p><span class="math display">\[m&gt; \frac{log(\frac{|\mathcal{H}|}{\delta})}{\epsilon}\]</span></p></div><p>综上所述，有如下重要结论：</p><div class="note info"><p>设 <span class="math inline">\(\mathcal{H}\)</span> 为一个有限的假设类，令 <span class="math inline">\(\delta \in (0,1)\)</span> ，<span class="math inline">\(\epsilon &gt; 0\)</span> ，<span class="math inline">\(m\)</span> 为一个满足以下条件的整数： <span class="math display">\[m&gt; \frac{log(\frac{|\mathcal{H}|}{\delta})}{\epsilon}\]</span> 那么，对于任意的标记函数 <span class="math inline">\(f\)</span> ，任意的分布 <span class="math inline">\(\mathcal{D}\)</span> ，如果满足可实现假设（即，存在 <span class="math inline">\(h\in \mathcal{H}\)</span> ，使得 <span class="math inline">\(L_{(\mathcal{D},f)}(h) = 0\)</span>），则至少有 <span class="math inline">\(1-\delta\)</span> 的可能性，在 <span class="math inline">\(S\)</span> 上独立采样 <span class="math inline">\(m\)</span> 个点，对于每一个 <span class="math inline">\(ERM\)</span> 假设，满足如下式子： <span class="math display">\[L_{(\mathcal{D},f)}(h_S) \le \epsilon\]</span></p></div><p>这个结论意味着，只要有足够的训练数据（<span class="math inline">\(m&gt; \frac{log(\frac{|\mathcal{H}|}{\delta})}{\epsilon}\)</span>），在有限假设类上的 <span class="math inline">\(ERM_{\mathcal{H}}\)</span> 会尽可能近似正确（其置信参数为 <span class="math inline">\(1-\delta\)</span> ，最大的误差为 <span class="math inline">\(\epsilon\)</span>）。</p><h1 id="reference">Reference</h1><p>Shai Shalev-Shwartz, Shai Ben-David. <a href="https://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/index.html" target="_blank" rel="noopener">Understanding Machine Learning: From Theory to Algorithms</a></p>]]></content>
        <author>
            <name><![CDATA[CosmosNing的个人博客]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://cosmosning.github.io/2020/09/13/intro-to-ml/</id>
        <title><![CDATA[《从理论到算法理解机器学习》引言]]></title>
        <updated>2021-05-14T12:17:25+08:00</updated>
        <link href="https://cosmosning.github.io/2020/09/13/intro-to-ml/"/>
        <content type="text/html" src="https://cosmosning.github.io/2020/09/13/intro-to-ml/"><![CDATA[<blockquote><p>最近上了一门课，叫做“智能信息检索”。老师推荐了一本教材 《Understanding Machine Learning: From Theory to Algorithms》（文末提供官方下载链接），来解释<strong>智能</strong>的含义。本文基于我对教材的理解，对其引言部分做了一些要点概括，供读者参考。</p></blockquote><h1 id="what-is-learning">What Is Learning？</h1><p>粗略地讲，<strong>学习是一个将经历（<em>experience</em>）转换为技能（<em>expertise</em>）或知识（<em>knowledge</em>）的过程</strong>。一般地，一个学习算法的<strong>输入</strong>是<strong>训练数据</strong>（代表经历），<strong>输出</strong>是<strong>技能</strong>。</p><p>一种常见的学习方法是 “记忆学习”（<em>learning by memorization</em>）。类似人类学习的“死记硬背”，这种学习方法有时候十分有效，但是它却缺失了学习系统中一个十分重要的能力，即<strong>泛化能力</strong>（<em>generalization</em>）。换句话讲，一个成功的学习系统理应能够依据已知知识，正确处理未知的情况。</p><div class="note info"><p><strong>泛化能力</strong> （<em>generalization</em>） 有时也被称作<strong>归纳推理</strong> （<em>inductive reasoning / inductive inference</em>）</p></div><p>然而，<strong>归纳推理可能会导致错误结论</strong>。那么怎样才能减少犯错呢？</p><p>答案是：在学习系统中<strong>引入先验知识</strong>（<em>prior knowledge</em>）！</p><div class="note info"><p><strong>先验知识</strong>（<em>prior knowledge</em>） 有时也被称作<strong>归纳偏好</strong> （<em>inductive bias</em>）</p></div><p>从书中举得几个例子来看，<strong>引入先验知识，使整个学习过程带有偏好，是一个成功的学习算法必然发生的事情</strong>（这种现象是 <strong>No-Free-Lunch Theorem</strong> 的具体表现）。粗略来说，学习算法开始训练时所引入的先验知识越强，从训练样本中学习就越简单。但是，先验知识越强，学习的灵活性也就越低，因为整个学习过程被这些预定假设束缚住了。</p><h1 id="when-we-need-machine-learning">When We Need Machine Learning？</h1><p>那么，在哪些情况下，我们需要利用机器学习解决问题呢？主要有以下两个方面：</p><ul><li>问题的复杂性（<em>complexity</em>）</li><li>任务的适应性需求（<em>adaptivity</em>）</li></ul><h2 id="tasks-that-are-to-complex-to-program">Tasks That Are to Complex to Program</h2><ul><li><em>Tasks Performed by Animals / Humans</em>：我们暂时无法理解一些我们能够处理的日常任务，例如驾驶汽车、语音识别、图像理解。以现有的知识，难以抽象出一个良好的程序去执行这些任务。然而，先进的机器学习程序，只要接受足够的训练样本训练，就可以从中学习经验，并在这些任务中达到不错的效果。</li><li><em>Tasks beyond Human Capabilities</em>：另一类适合用机器学习解决的问题是对巨大的且复杂的数据（例如宇宙空间数据、医疗数据、天气数据等）进行分析。这些数据的处理和分析通常超越了我们自身的分析能力。使用机器学习，可以充分利用计算机的能力，找到数据中有价值的信息。</li></ul><h2 id="adaptivity">Adaptivity</h2><ul><li>预先编程的程序有一个缺陷，即死板性（<em>rigidity</em>）。也就是说，一旦程序写好了，安装到系统中后，程序就不会变化了。然而，现实中许多任务都是在不断变化的。</li><li>而机器学习（其天生可以适应不同的输入数据）提供了一种解决此类任务的方案。</li></ul><h1 id="types-of-learning">Types of Learning</h1><h2 id="supervised-versus-unsupervised">Supervised versus Unsupervised</h2><p>如果将学习看作是一个“利用经历来获取技能”的过程，那么监督学习和非监督学习可以描述如下：</p><ul><li><strong>监督（<em>Supervised</em>）学习</strong>：在该场景中，“经历”（亦可称作训练样本）包含了十分重要的信息；而这些信息却在测试样本中丢失了。从监督学习中学习到的技能的目标是，预测测试数据中的确实信息。这就好像环境作为一名老师通过提供额外的信息（通常称作<strong>“标签”</strong> <em>label</em>）"监督"学生（学习算法）的学习。</li><li><strong>非监督（<em>Unsupervised</em>）学习</strong>：对于非监督学习来说，训练数据和测试数据几乎没什么区别。通常，这种学习方法通过处理输入数据，来达到<strong>总结数据</strong>、<strong>压缩数据</strong>的目标。<strong>聚类</strong>——将一个数据集分成几个子集，同一子集具有相似性——是非监督学习中一个典型的例子。</li><li>在监督与非监督之间，还存在一种不同的方法——<strong>强化学习</strong>。</li></ul><h2 id="active-versus-passive">Active versus Passive</h2><ul><li><strong>主动（<em>Active</em>）学习</strong>：主动学习在在训练过程中将会与环境交互。</li><li><strong>被动（<em>Passive</em>）学习</strong>：被动学习只会观测环境所提供的信息，而不会影响（influence）或指导（direct）它。</li></ul><div class="note info"><p><strong>例子</strong></p><ul><li>垃圾邮件识别通常是被动学习，因为它等着用户为它标记收到的邮件是否是垃圾邮件。</li><li>在主动学习的场景下，学习算法会在训练过程中要求用户标记它指定的邮件，或者甚至是由学习算法生成的邮件，来增强它对什么是垃圾邮件的理解。</li></ul></div><h2 id="helpful-of-the-teacher">Helpful of the Teacher</h2><ul><li>主动提供信息<ul><li>训练信息<strong>正相关</strong>——普通学习：例如，教师会不断尝试为学生提供最有用的信息，来达到某种学习目标。</li><li>训练信息<strong>负相关</strong>——<strong>对抗（<em>Adversarial</em>）学习</strong>：例如垃圾邮件生成器将会努力误导垃圾邮件识别器。</li></ul></li><li>被动提供信息<ul><li><strong>统计学习（<em>Statistical Learning</em>）</strong>：有时候，信息并不是他人主动提供的。例如科学家在认识自然时，环境，作为一位老师，并不会根据学生的需求主动的提供信息，因此是被动的提供信息。这种情况下，输入数据常常被认为是由某种随机过程（<em>random process</em>）产生。这样，就可以使用统计学习解决问题</li></ul></li></ul><h2 id="online-versus-batch-learning-protocol">Online versus Batch Learning Protocol</h2><ul><li><strong>在线学习（<em>Online Learning</em>）</strong>：学习算法必须在训练过程中，在线反馈。例如，股票交易员需要基于目前位置积累的经验，做出每日决策。虽说随着时间推移，他会称为一名专家，但是也可能在此过程中犯下代价高昂的错误。</li><li><strong>批处理学习（<em>Batch Learning</em>）</strong>：只有在处理大量的数据后，该算法才能获得所需的技能。在数据挖掘场景下，数据挖掘算法会处理大量的数据之后，才会得出相关的结论。</li></ul><h1 id="relations-to-other-fields">Relations to Other Fields</h1><h2 id="with-ai">With AI</h2><ul><li>机器学习是 AI 的一个分支。</li><li>机器学习更关注<strong>利用计算机的优势和独特的能力</strong>来<strong>补充</strong>人类的智能，因此常常处理一些远超人类能力的任务。</li><li>AI 更关注创造一个能够自动<strong>模仿</strong>智能行为的机器。</li></ul><h2 id="with-statistics">With Statistics</h2><ul><li>统计学：提出假设（专业人员） <span class="math inline">\(\rightarrow\)</span> <strong>验证假设</strong>（统计学）</li><li>机器学习：利用数据，<strong>挖掘规律</strong>，解释原因。</li><li>机器学习对<strong>算法</strong>层面的考虑更多</li><li>统计学常常关注数据的<strong>渐进性</strong>（<strong>无穷</strong>情况下的特性），机器学习则关注<strong>有限</strong>的样本空间</li><li>统计学通常<strong>预先假设数据分布</strong>，而机器学习是<strong>分布无关</strong>的（<em>distribution-free</em>）</li></ul><h1 id="reference">Reference</h1><p>Shai Shalev-Shwartz, Shai Ben-David. <a href="https://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/index.html" target="_blank" rel="noopener">Understanding Machine Learning: From Theory to Algorithms</a></p>]]></content>
        <author>
            <name><![CDATA[CosmosNing的个人博客]]></name>
        </author>
    </entry>
    
    <entry>
        <id>http://blog.qrzbing.cn/about/</id>
        <title><![CDATA[About]]></title>
        <updated>2021-05-02T07:33:00+08:00</updated>
        <link href="http://blog.qrzbing.cn/about/"/>
        <content type="text/html" src="http://blog.qrzbing.cn/about/"><![CDATA[关于我 一条咸鱼，努力提升自己中 目前方向：系统安全，研究逆向、Fuzzing。Rust 学习中。 爱好：业余无线电，游泳。 Call Sign: BG2EQV history 2021-05-02: 更换主题为 hugo-theme-even 2021-03-30:]]></content>
        <author>
            <name><![CDATA[QRZ’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.noisyfox.io/substratevm-on-ios.html</id>
        <title><![CDATA[SubstrateVM on iOS]]></title>
        <updated>2021-03-09T00:27:10+08:00</updated>
        <link href="https://www.noisyfox.io/substratevm-on-ios.html"/>
        <content type="text/html" src="https://www.noisyfox.io/substratevm-on-ios.html"><![CDATA[<p>This article records my attempts &amp; findings when using SubstrateVM to run JVM compatible languages on iOS. The goal is to replace the outdated Android Runtime (ART) currently used by MOE with SubstrateVM. Currently it&#8217;s still in a very early stage and this article is not meant to be a complete guide on running Java app on iOS, but to share my progress and give anyone who&#8217;s interested in this something to start with.</p>



<p>I will keep updating this article once I made any more progress, you could join the discussion by leaving comments down below, or join the Multi-OS Engine Community discord channel: <a href="https://discord.gg/m5t3qNXTWj" target="_blank" rel="noreferrer noopener">https://discord.gg/m5t3qNXTWj</a></p>



<hr class="wp-block-separator"/>



<h2>Motivation</h2>



<p>Current version of MOE is based on the ART from Android 6 and support Java 7 features only. With retrolambda we get limited support of Java 8 features like Lambda and default methods. However the lack of a true Java 8 support makes it harder and harder to use as nowadays more and more 3rd libraries moved to Java 8 (and even higher).</p>



<p>It is possible that we update the ART to a later version (such as from Android 7+), however this requires a huge amount of effort because:</p>



<ul><li>The Android code is not well documented</li><li>The code structure changes significantly between each Android major releases</li><li>ART has its own native code generator, instead of LLVM, so no bitcode support</li><li>ART is not designed to be run on any OS other than Android, and requires a lot of modifications to be able to run on iOS because Apple does things differently than Google</li><li>ART is not fully compatible with any &#8220;official&#8221; JDK release (Google likes to mix features from different JDK versions)</li></ul>



<p>On the contrary, SubstrateVM is:</p>



<ul><li>Created &amp; supported by Oracle</li><li>Support iOS (and may other platforms) by design</li><li>Based on official OpenJDK</li><li>Currently support Java 8 and Java 11</li><li>Better stacktrace</li></ul>



<p>This gives a clear advantage to SubstrateVM over ART as a much more reliable and futureproof solution.</p>



<p>SubstrateVM does come with some downsides, namely:</p>



<ul><li>Not production-ready yet</li><li>Binary size is larger reportedly</li><li>Slower and more memory consumption during compiling</li></ul>



<p>But those issues should be resolved eventually so I&#8217;m not that worried about at the moment.</p>



<hr class="wp-block-separator"/>



<h2>Problem to be Solved</h2>



<p>Here are some problems that need to be figured out before we could confidently use this in MOE:</p>



<ul><li>How to compile Java code into a static shared library / iOS framework / Mach-O file so it can be linked to a normal iOS app (partly solved, see below)</li><li>Figure out the difference to the (modified) ART used in MOE currently, and how this could cause issues when trying porting existing MOE project to this new VM</li><li>How to debug the application once it has been compiled to native binary</li><li>How bitcode could be supported</li></ul>



<hr class="wp-block-separator"/>



<h2>Acknowledgments</h2>



<p>The work I&#8217;ve done so far largely based on the awesome work from the Gluon Substrate project: <a href="https://github.com/gluonhq/substrate" target="_blank" rel="noreferrer noopener">https://github.com/gluonhq/substrate</a>.</p>



<p>Gluon is a framework that allows you to right JavaFX application that can be run on multiple platforms, including iOS (which is based on SubstrateVM). I highly recommend to check out their awesome project!</p>



<p>In the following parts I might include some code fragments from this project and might also uses certain files directly from Gluon&#8217;s website for demonstration purpose.</p>



<p>However, this article and any work I did/will do in the future are not directly related to Gluon or any of their product.</p>



<hr class="wp-block-separator"/>



<h2>Preparation</h2>



<p>Most of the work I&#8217;ve done are under MacOS, so all the tools I mention later are all MacOS versions. I&#8217;ll assume most of you have access to a Mac and are familiar with some basic dev tools &amp; processes on Mac, so I won&#8217;t explain everything in this article. Again, this is not a complete guide.</p>



<p>Download the official prebuilt GraalVM from <a href="https://github.com/graalvm/graalvm-ce-builds/releases/tag/vm-21.0.0.2" target="_blank" rel="noreferrer noopener">https://github.com/graalvm/graalvm-ce-builds/releases/tag/vm-21.0.0.2</a>. This is the version I&#8217;m using while writing this part. Download the <a href="https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-21.0.0.2/graalvm-ce-java11-darwin-amd64-21.0.0.2.tar.gz">graalvm-ce-java11-darwin-amd64-21.0.0.2.tar.gz</a> and extract it somewhere.</p>



<p>This is a complete JDK distribution, so I simply added it to the <strong>jenv</strong> for easier version switching. Once the GraalVM is activated as current JDK, run the following command to install the SubstrateVM (i.e. native-image):</p>



<pre class="EnlighterJSRAW" data-enlighter-language="shell" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">gu install --jvm native-image
gu install --jvm llvm-toolchain</pre>



<hr class="wp-block-separator"/>



<h2>Hello World</h2>



<p>I created a very simple hello world in Java:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="java" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="Test.java" data-enlighter-group="test-java">public class Test {
    public static void main(String[] args) {
        System.out.println("hello world!");
    }
}</pre>



<p>Then compile it to class file:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="shell" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">javac Test.java</pre>



<hr class="wp-block-separator"/>



<h2>Java Bytecode to Binary</h2>



<p>The document of SubstrateVM states by using the <code data-enlighter-language="shell" class="EnlighterJSRAW">native-image</code> command, one can compile the java bytecode (the .class file) into either an <a href="https://www.graalvm.org/reference-manual/native-image/#build-a-native-image" target="_blank" rel="noreferrer noopener">executable</a> (the default option) or a <a href="https://www.graalvm.org/reference-manual/native-image/#build-a-shared-library" target="_blank" rel="noreferrer noopener">shared (dynamic) library</a>. However none of these options fits our needs because:</p>



<ul><li>We need to link the generated binary into a normal iOS application, so it has to be a library, not a standalone executable</li><li>iOS does not allow loading our own dynamic library at runtime, so the library needs to be statically linked to our app</li></ul>



<p>Before I even worry about this problem, as a proof of concept, I first tried to compile it into a x86_64 Darwin executable and ran it using <code data-enlighter-language="shell" class="EnlighterJSRAW">native-image Test</code>:</p>



<div class="wp-block-image is-style-default"><figure class="aligncenter size-large"><a href="https://www.noisyfox.io/wp-content/uploads/2021/03/image.png" target="_blank" rel="noopener"><img loading="lazy" width="516" height="354" src="https://www.noisyfox.io/wp-content/uploads/2021/03/image.png" alt="SubstrateVM on iOS - compile with default settings" class="wp-image-812" srcset="https://www.noisyfox.io/wp-content/uploads/2021/03/image.png 516w, https://www.noisyfox.io/wp-content/uploads/2021/03/image-300x206.png 300w" sizes="(max-width: 516px) 100vw, 516px" /></a><figcaption>Compile with default settings</figcaption></figure></div>



<p>Ok that wasn&#8217;t too hard. Now let&#8217;s try using the LLVM backend by adding <code data-enlighter-language="shell" class="EnlighterJSRAW">-H:CompilerBackend=llvm</code> option to the command:</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><a href="https://www.noisyfox.io/wp-content/uploads/2021/03/image-1.png" target="_blank" rel="noopener"><img loading="lazy" width="828" height="709" src="https://www.noisyfox.io/wp-content/uploads/2021/03/image-1.png" alt="SubstrateVM on iOS - llvm compile failed" class="wp-image-814" srcset="https://www.noisyfox.io/wp-content/uploads/2021/03/image-1.png 828w, https://www.noisyfox.io/wp-content/uploads/2021/03/image-1-300x257.png 300w, https://www.noisyfox.io/wp-content/uploads/2021/03/image-1-768x658.png 768w" sizes="(max-width: 828px) 100vw, 828px" /></a><figcaption>LLVM compile failed with no extra options</figcaption></figure></div>



<p>Oops! A quick search of <code data-enlighter-language="raw" class="EnlighterJSRAW">ImageSingletons do not contain key org.graalvm.home.HomeFinder</code> lead me to <a href="https://github.com/oracle/graal/issues/1889#issuecomment-559136202" target="_blank" rel="noreferrer noopener">this github issue</a>, which tells me to add <code data-enlighter-language="shell" class="EnlighterJSRAW">--features=org.graalvm.home.HomeFinderFeature</code> to the command:</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><a href="https://www.noisyfox.io/wp-content/uploads/2021/03/image-2.png" target="_blank" rel="noopener"><img loading="lazy" width="613" height="410" src="https://www.noisyfox.io/wp-content/uploads/2021/03/image-2.png" alt="SubstrateVM on iOS - LLVM compiled with HomeFinderFeature enabled" class="wp-image-820" srcset="https://www.noisyfox.io/wp-content/uploads/2021/03/image-2.png 613w, https://www.noisyfox.io/wp-content/uploads/2021/03/image-2-300x201.png 300w" sizes="(max-width: 613px) 100vw, 613px" /></a><figcaption>LLVM compiled with HomeFinderFeature enabled</figcaption></figure></div>



<p>Ok. Now let&#8217;s try compile it into a library by adding <code data-enlighter-language="shell" class="EnlighterJSRAW">--shared</code> at the end:</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><a href="https://www.noisyfox.io/wp-content/uploads/2021/03/image-3.png" target="_blank" rel="noopener"><img loading="lazy" width="618" height="771" src="https://www.noisyfox.io/wp-content/uploads/2021/03/image-3.png" alt="SubstrateVM on iOS - compile into shared library" class="wp-image-825" srcset="https://www.noisyfox.io/wp-content/uploads/2021/03/image-3.png 618w, https://www.noisyfox.io/wp-content/uploads/2021/03/image-3-240x300.png 240w" sizes="(max-width: 618px) 100vw, 618px" /></a><figcaption>Compile into shared library</figcaption></figure></div>



<p>As you can see, a dynamic library has been generated (&#8220;test.dylib&#8221;), with few C header files. By looking at the content of the &#8220;test.h&#8221;, I found a function <code data-enlighter-language="c" class="EnlighterJSRAW">int run_main(int argc, char** argv);</code> which is pretty clear to me that I need to call this function in my iOS app to execute the Java main function, similar to the <code data-enlighter-language="c" class="EnlighterJSRAW">moevm(argc, argv);</code> we called from <a href="https://github.com/multi-os-engine-community/moe-samples-java/blob/69f97cb7743c0d19debfb7f85d64ab7984c892e5/Calculator/ios/xcode/ios/main.cpp#L4" target="_blank" rel="noreferrer noopener">the main function in MOE</a>.</p>



<p>Then what&#8217;s next is pretty clear: I need to somehow make that dynamic library into a static library so we could link it in iOS project.</p>



<hr class="wp-block-separator"/>



<h2>Or Maybe an Object File Instead&#8230;?</h2>



<p>TBC</p>
<p><a rel="nofollow" href="https://www.noisyfox.io/substratevm-on-ios.html">SubstrateVM on iOS</a>，首发于<a rel="nofollow" href="https://www.noisyfox.io">狐狸的小小窝</a>。</p>]]></content>
        <author>
            <name><![CDATA[狐狸的小小窝]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.creedowl.com/posts/ocaml-heap/</id>
        <title><![CDATA[Ocaml Heap]]></title>
        <updated>2021-03-03T07:10:56+08:00</updated>
        <link href="https://blog.creedowl.com/posts/ocaml-heap/"/>
        <content type="text/html" src="https://blog.creedowl.com/posts/ocaml-heap/"><![CDATA[<h1 id="简介">简介</h1>
<p>本次课设我实现的数据结构是<strong>堆（heap)</strong>，堆是一种非常重要的数据结构，分为大顶堆和小顶堆，可以快速地获取其中优先级最高的元素。若是满足以下特性，即可称为堆：“给定堆中任意节点P和C，若P是C的母节点，那么P的值会小于等于（或大于等于）C的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。所以堆又称作优先队列。</p>
<h1 id="原理">原理</h1>
<h2 id="完全二叉树">完全二叉树</h2>
<p>堆的实现方式通常是完全二叉树，采用数组进行模拟。完全二叉树的特点是较为对称，查找时时间复杂度较为稳定，可以通过数组进行模拟，而不需要实际构建一棵二叉树。</p>
<p>以数组 <code>[1, 2, 3, 4, 5, 6, 7]</code> 为例，可以构建出如下一棵完全二叉树。</p>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/blogUntitled.png" alt="p1"></p>
<p>对于每个节点都满足值大于父节点，所以这是一个小顶堆。对比数组和二叉树，可以发现：</p>
<ol>
<li>对于节点 <code>i</code> ，它的两个子节点在数组中的索引为 <code>2*i</code> 和 <code>2*i+1</code></li>
<li>两个子节点的大小对于堆的性质并没有影响，这点和二叉搜索树不一样</li>
</ol>
<p>其中的核心操作是 <code>shiftUp</code> 和 <code>shiftDown</code></p>
<p>分析其时间复杂度，有：</p>
<ul>
<li>获取堆顶元素：$O(1)$</li>
<li>插入元素：$O(logn)$</li>
<li>删除元素：$O(logn)$</li>
<li>合并堆：$O(n)$</li>
</ul>
<p>不过采用完全二叉树并不能方便地进行合并操作，需要转换成对一个堆的插入操作</p>
<hr>
<p>但在函数式语言中要如何实现一个堆呢？对于纯函数式语言，是不允许有副作用的。虽然 <code>Ocaml</code> 支持命令式操作，也支持传统的数组，但依然采用数组模拟的话和普通的命令式语言就没有太多区别，而且会产生副作用，这是不推荐的。那么如果用 <code>List</code> 来模拟数组操作呢？</p>
<p><code>Ocaml</code> 中的 <code>List</code> 是通过链表实现的，这就意味着 <code>List</code> 只能进行顺序访问，无法随机访问，也就无法像上面那样构建出一个虚拟的树形结构，而要全部转换成遍历操作。虽然可以通过计算和记录确定节点的位置，但会导致访问的时间复杂性大大提高。还有别的办法吗？</p>
<p>既然用数组模拟完全二叉树的方法在函数式语言中有很大的限制，那我们手动模拟一棵二叉树试试。我们可以定义出以下的数据结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">heap</span> <span class="o">=</span> 
	<span class="o">|</span> <span class="nc">Leaf</span>
	<span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">heap</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">heap</span>
</code></pre></div><p>该结构参考了书上的内容，一个节点由自身的值和左右子节点构成，空节点为叶子节点。</p>
<p>对于插入操作，传统的数组模拟方式将元素插入数组尾部，再调用 <code>shiftUp</code> 操作将元素移动到正确的位置，如图所示：</p>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/blog/1614757139001-Untitled%201.png" alt="p2"></p>
<p>但在树状结构中，我们很难找到最后一个元素的位置，或者说时间复杂度太高，不具备可行性，也就无法采用 <code>shiftUp</code> 的思想。而我们的树结构只保存了根节点的位置，也就意味着只能自顶向下想想办法。</p>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/blog/1614757187865-Untitled%202.png" alt="p3"></p>
<p>首先比较 1 和 4 ，1 比 4 小，应该继续向下，但应该走左边还是右边呢？堆能保持高效性的原因之一就是结构比较对称，即左右子树的深度大致相等。必须要找到一个规则来解决这个问题。</p>
<p>堆的另一个重要操作是删除，即删除最顶端节点。这时我们发现如果删掉了根节点，我们会得到两个二叉树：</p>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/blog/1614757208893-Untitled%203.png" alt="p4"></p>
<p>在数组模拟的方式中我们将数组的最后一个元素（也就是完全二叉树的最后一个节点）移动到原本根节点的为止，再采用 <code>shiftDown</code> 操作将它移动到正确的位置。但同上面的问题一样，无法快速定位到最后一个节点，因此问题变成了如何合并两个堆。这时再看插入操作，发现也可以当成合并堆解决，即将目标堆和由待插入元素构成的只有一个节点的堆进行合并。可见堆的核心操作都转换成了堆合并，这就需要找到一个可以高效地进行堆合并的方法。</p>
<h2 id="左偏树">左偏树</h2>
<p>搜索后发现，虽然大部分算法教程和书中堆都是采用数组模拟完全二叉树，但也有其它数据结构可以实现堆，就是左偏树。查看维基百科中的定义：</p>
<blockquote>
<p>左偏树是一种可并堆的实现。左偏树是一棵二叉树，它的节点除了和二叉树的节点一样具有左右子树指针（left, right）外，还有两个属性： 键值和距离（英文文献中称为s-value）。键值用于比较节点的大小。距离的定义如下：
当且仅当节点 i 的左子树或右子树为空时，节点被称作外节点（实际上保存在二叉树中的节点都是内节点，外节点是逻辑上存在而无需保存。把一颗二叉树补上全部的外节点，则称为extended binary tree）。节点i的距离是节点 i 到它的后代中的最近的外节点所经过的边数。特别的，如果节点 i 本身是外节点，则它的距离为0;而空节点的距离规定为 -1。</p>
</blockquote>
<p>光看定义比较复杂，但其实很简单，只需要在上面定义的树中加入一个距离（rank）即可，一个节点距离的值为到最右叶子节点的长度，如图所示：</p>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/blog/1614757222212-Untitled%204.png" alt="p5"></p>
<p>rank 是用来比较左右子树的长度的，在左偏树中，<strong>所有节点的左子树 rank 值一定大于等于右子树</strong>。因此每次进行合并操作时我们选择右子树，重复进行直到叶子节点或正确的位置，最后更新路径上的 rank 值，如果出现右子树的 rank 值大于左子树，则交换左右子树以保证左偏树的定义成立。</p>
<p>作为左偏树的核心操作，合并（merge）操作的流程如下：</p>
<ol>
<li>合并 <code>t1</code> ，<code>t2</code> 两个树 <code>merge t1 t2</code></li>
<li>比较两个树根节点的值，如果 <code>v1 &lt; v2</code> 则交换两个树（即 <code>merge t2 t1</code> ），这样做的目的是保证左边树的值小于右边，便于操作。实际比较操作是通过函子中的 <code>compare</code> 函数进行，可以根据该函数设置大顶堆或小顶堆</li>
<li>由于左边树（ <code>t1</code> ）根节点的值小于右边树（ <code>t2</code> ），<code>v1</code> 保持不变作为新的根节点</li>
<li>由于 <code>t1</code> 的右子树 <code>r</code> 一定是最短的，开始合并 <code>r</code> 和 <code>t2</code> （即 <code>merge r t2</code> ）</li>
<li>当任一子树是叶子节点时，只需要直接返回另一个子树，并开始向上更新每个节点的 <code>rank</code> 值</li>
<li>更新完毕后还要比较左右子树的 <code>rank</code> 值以确定是否需要交换左右子树</li>
</ol>
<p>看一个合并子树的例子：</p>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/blog/1614757235831-Untitled%205.png" alt="p6"></p>
<p>分析其时间复杂度，有：</p>
<ul>
<li>获取堆顶元素：$O(1)$</li>
<li>插入元素：$O(logn)$</li>
<li>删除元素：$O(logn)$</li>
<li>合并堆：$O(logn)$</li>
</ul>
<h1 id="代码">代码</h1>
<h2 id="完全二叉树-1">完全二叉树</h2>
<p>这部分代码是我一开始研究学习时写的测试代码，比较混乱，也采用了很多命令式语言的思维，比如有大量的副作用，对对象的操作都是在一个对象本身等。这里保留在这来和下面纯函数式的写法做一个对比</p>
<p><code>binary_heap.ml</code></p>
<div class="highlight"><pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="c">(* Input signature of the functor *)</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">OrderedType</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="c">(* the type of the heap elements *)</span>
  <span class="k">type</span> <span class="n">t</span>

  <span class="c">(* compare function used to determine the order of elements *)</span>
  <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Make</span> <span class="o">(</span><span class="nc">Ord</span> <span class="o">:</span> <span class="nc">OrderedType</span><span class="o">)</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">elt</span> <span class="o">=</span> <span class="nn">Ord</span><span class="p">.</span><span class="n">t</span>

  <span class="k">type</span> <span class="n">tree</span> <span class="o">=</span> <span class="o">{</span> <span class="k">mutable</span> <span class="n">elements</span> <span class="o">:</span> <span class="n">elt</span> <span class="kt">array</span><span class="o">;</span> <span class="k">mutable</span> <span class="n">size</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">}</span>

  <span class="k">let</span> <span class="n">create</span> <span class="n">n</span> <span class="n">default</span> <span class="o">=</span> <span class="o">{</span> <span class="n">size</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">elements</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="n">default</span> <span class="o">}</span>

  <span class="k">let</span> <span class="n">insert</span> <span class="n">v</span> <span class="n">t</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">elements</span> <span class="k">in</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">shiftUp</span> <span class="n">i</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">fi</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span> <span class="k">in</span>
      <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="nn">Ord</span><span class="p">.</span><span class="n">compare</span> <span class="n">d</span><span class="o">.(</span><span class="n">fi</span><span class="o">)</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="k">then</span> <span class="o">(</span>
        <span class="n">d</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">d</span><span class="o">.(</span><span class="n">fi</span><span class="o">);</span>
        <span class="n">shiftUp</span> <span class="n">fi</span> <span class="o">)</span>
      <span class="k">else</span> <span class="n">d</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">v</span>
    <span class="k">in</span>
    <span class="n">shiftUp</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="o">;</span>
    <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;-</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">1</span>

  <span class="k">let</span> <span class="n">deleteTop</span> <span class="n">t</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">0</span> <span class="k">then</span> <span class="n">failwith</span> <span class="s2">&#34;empty&#34;</span>
    <span class="k">else</span>
      <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">1</span> <span class="k">in</span>
      <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;-</span> <span class="n">n</span><span class="o">;</span>
      <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">elements</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">d</span><span class="o">.(</span><span class="n">n</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">let</span> <span class="k">rec</span> <span class="n">shiftDown</span> <span class="n">i</span> <span class="o">=</span>
        <span class="k">let</span> <span class="n">ci</span> <span class="o">=</span> <span class="o">(</span><span class="n">2</span> <span class="o">*</span> <span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span> <span class="k">in</span>
        <span class="k">if</span> <span class="n">ci</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="k">then</span>
          <span class="k">let</span> <span class="n">j</span> <span class="o">=</span>
            <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="n">ci</span> <span class="o">+</span> <span class="n">1</span> <span class="k">in</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="nn">Ord</span><span class="p">.</span><span class="n">compare</span> <span class="n">d</span><span class="o">.(</span><span class="n">k</span><span class="o">)</span> <span class="n">d</span><span class="o">.(</span><span class="n">ci</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="k">then</span> <span class="n">k</span> <span class="k">else</span> <span class="n">ci</span>
          <span class="k">in</span>
          <span class="k">if</span> <span class="nn">Ord</span><span class="p">.</span><span class="n">compare</span> <span class="n">d</span><span class="o">.(</span><span class="n">j</span><span class="o">)</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="k">then</span> <span class="o">(</span>
            <span class="n">d</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">d</span><span class="o">.(</span><span class="n">j</span><span class="o">);</span>
            <span class="n">shiftDown</span> <span class="n">j</span> <span class="o">)</span>
          <span class="k">else</span> <span class="n">d</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">x</span>
        <span class="k">else</span> <span class="n">d</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">x</span>
      <span class="k">in</span>
      <span class="n">shiftDown</span> <span class="n">0</span>

  <span class="k">let</span> <span class="n">getTop</span> <span class="n">t</span> <span class="o">=</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">0</span> <span class="k">then</span> <span class="n">failwith</span> <span class="s2">&#34;empty&#34;</span> <span class="k">else</span> <span class="n">t</span><span class="o">.</span><span class="n">elements</span><span class="o">.(</span><span class="n">0</span><span class="o">)</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">toList</span> <span class="n">t</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">0</span> <span class="k">then</span> <span class="bp">[]</span>
    <span class="k">else</span>
      <span class="k">let</span> <span class="n">top</span> <span class="o">=</span> <span class="n">getTop</span> <span class="n">t</span> <span class="k">in</span>
      <span class="n">deleteTop</span> <span class="n">t</span><span class="o">;</span>
      <span class="n">top</span> <span class="o">::</span> <span class="n">toList</span> <span class="n">t</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">fromList</span> <span class="n">n</span> <span class="n">default</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">create</span> <span class="n">n</span> <span class="n">default</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">fromList</span> <span class="n">n</span> <span class="n">default</span> <span class="n">tl</span> <span class="k">in</span>
        <span class="n">insert</span> <span class="n">hd</span> <span class="n">t</span><span class="o">;</span>
        <span class="n">t</span>
<span class="k">end</span>
</code></pre></div><p><code>binary_heap.mli</code></p>
<div class="highlight"><pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="c">(* Input signature of the functor *)</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">OrderedType</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="c">(* the type of the heap elements *)</span>
  <span class="k">type</span> <span class="n">t</span>

  <span class="c">(* compare function used to determine the order of elements *)</span>
  <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Make</span> <span class="o">:</span> <span class="k">functor</span> <span class="o">(</span><span class="nc">Ord</span> <span class="o">:</span> <span class="nc">OrderedType</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">elt</span> <span class="o">=</span> <span class="nn">Ord</span><span class="p">.</span><span class="n">t</span>

  <span class="k">type</span> <span class="n">tree</span>

  <span class="c">(* create an empty heap, with only a leaf *)</span>
  <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="n">tree</span>

  <span class="c">(* insert an element into a heap, just like merge two heap *)</span>
  <span class="k">val</span> <span class="n">insert</span> <span class="o">:</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="n">tree</span> <span class="o">-&gt;</span> <span class="kt">unit</span>

  <span class="c">(* delete the top element of a heap, just merge two children trees *)</span>
  <span class="k">val</span> <span class="n">deleteTop</span> <span class="o">:</span> <span class="n">tree</span> <span class="o">-&gt;</span> <span class="kt">unit</span>

  <span class="c">(* get the top element of a heap *)</span>
  <span class="k">val</span> <span class="n">getTop</span> <span class="o">:</span> <span class="n">tree</span> <span class="o">-&gt;</span> <span class="n">elt</span>

  <span class="c">(* generate a list from a heap *)</span>
  <span class="k">val</span> <span class="n">toList</span> <span class="o">:</span> <span class="n">tree</span> <span class="o">-&gt;</span> <span class="n">elt</span> <span class="kt">list</span>

  <span class="c">(* create a heap from list *)</span>
  <span class="k">val</span> <span class="n">fromList</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="n">elt</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">tree</span>
<span class="k">end</span>
</code></pre></div><h2 id="左偏堆">左偏堆</h2>
<p>这里的左偏堆采用了纯函数式的写法，包括采用联合体构建一棵二叉树，所有操作都无副作用，返回一个新的对象等。和上面命令式的写法相比，也更加简练，通过递归和迭代就实现了复杂的操作逻辑</p>
<p><code>heap.ml</code></p>
<div class="highlight"><pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="c">(* Input signature of the functor *)</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">OrderedType</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="c">(* the type of the heap elements *)</span>
  <span class="k">type</span> <span class="n">t</span>

  <span class="c">(* compare function used to determine the order of elements *)</span>
  <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Make</span> <span class="o">(</span><span class="nc">Ord</span> <span class="o">:</span> <span class="nc">OrderedType</span><span class="o">)</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">elt</span> <span class="o">=</span> <span class="nn">Ord</span><span class="p">.</span><span class="n">t</span>

  <span class="c">(* heaps are represented by leftist tree *)</span>
  <span class="k">type</span> <span class="n">tree</span> <span class="o">=</span>
    <span class="c">(* leaf node *)</span>
    <span class="o">|</span> <span class="nc">Leaf</span>
    <span class="c">(* left child, value of node, right child, rank of node *)</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="n">tree</span> <span class="o">*</span> <span class="n">elt</span> <span class="o">*</span> <span class="n">tree</span> <span class="o">*</span> <span class="kt">int</span>

  <span class="c">(* create an empty heap, with only a leaf *)</span>
  <span class="k">let</span> <span class="n">create</span> <span class="bp">()</span> <span class="o">=</span> <span class="nc">Leaf</span>

  <span class="c">(* create a node contains only v *)</span>
  <span class="k">let</span> <span class="n">singleton</span> <span class="n">v</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="n">1</span><span class="o">)</span>

  <span class="c">(* get the rank of a node *)</span>
  <span class="k">let</span> <span class="n">getRank</span> <span class="o">=</span> <span class="k">function</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="n">0</span> <span class="o">|</span> <span class="nc">Node</span> <span class="o">(_,</span> <span class="o">_,</span> <span class="o">_,</span> <span class="n">r</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">r</span>

  <span class="c">(* merge to heap, the most important function in leftist heap *)</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">merge</span> <span class="n">t1</span> <span class="n">t2</span> <span class="o">=</span>
    <span class="k">match</span> <span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="n">t</span> <span class="o">|</span> <span class="n">t</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="o">_),</span> <span class="nc">Node</span> <span class="o">(_,</span> <span class="n">v2</span><span class="o">,</span> <span class="o">_,</span> <span class="o">_)</span> <span class="o">-&gt;</span>
        <span class="c">(* switch two heap if the tree on the left have a bigger key *)</span>
        <span class="k">if</span> <span class="nn">Ord</span><span class="p">.</span><span class="n">compare</span> <span class="n">v1</span> <span class="n">v2</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="k">then</span> <span class="n">merge</span> <span class="n">t2</span> <span class="n">t1</span>
          <span class="c">(* the order is determined by the compare function *)</span>
        <span class="k">else</span>
          <span class="c">(* merge with the right tree *)</span>
          <span class="k">let</span> <span class="n">merged</span> <span class="o">=</span> <span class="n">merge</span> <span class="n">r</span> <span class="n">t2</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">leftRank</span> <span class="o">=</span> <span class="n">getRank</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">rightRank</span> <span class="o">=</span> <span class="n">getRank</span> <span class="n">merged</span> <span class="k">in</span>
          <span class="c">(* compare the rank of both tree *)</span>
          <span class="k">if</span> <span class="n">leftRank</span> <span class="o">&gt;=</span> <span class="n">rightRank</span> <span class="k">then</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">merged</span><span class="o">,</span> <span class="n">rightRank</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span>
            <span class="c">(* switch left and right since left tree is shorter *)</span>
          <span class="k">else</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">merged</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">leftRank</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span>

  <span class="c">(* insert an element into a heap, just like merge two heap *)</span>
  <span class="k">let</span> <span class="n">insert</span> <span class="n">v</span> <span class="n">t</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="n">singleton</span> <span class="n">v</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(_,</span> <span class="o">_,</span> <span class="o">_,</span> <span class="o">_)</span> <span class="o">-&gt;</span> <span class="n">merge</span> <span class="n">t</span> <span class="o">(</span><span class="n">singleton</span> <span class="n">v</span><span class="o">)</span>

  <span class="c">(* get the top element of a heap *)</span>
  <span class="k">let</span> <span class="n">getTop</span> <span class="o">=</span> <span class="k">function</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">&#34;empty&#34;</span> <span class="o">|</span> <span class="nc">Node</span> <span class="o">(_,</span> <span class="n">v</span><span class="o">,</span> <span class="o">_,</span> <span class="o">_)</span> <span class="o">-&gt;</span> <span class="n">v</span>

  <span class="c">(* delete the top element of a heap, just merge two children trees *)</span>
  <span class="k">let</span> <span class="n">deleteTop</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">&#34;empty&#34;</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="o">_,</span> <span class="n">r</span><span class="o">,</span> <span class="o">_)</span> <span class="o">-&gt;</span> <span class="n">merge</span> <span class="n">l</span> <span class="n">r</span>

  <span class="c">(* generate a list from a heap *)</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">toList</span> <span class="n">t</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">t</span> <span class="k">with</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="bp">[]</span> <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">getTop</span> <span class="n">t</span> <span class="o">::</span> <span class="n">toList</span> <span class="o">(</span><span class="n">deleteTop</span> <span class="n">t</span><span class="o">)</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">fromList</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">create</span> <span class="bp">()</span>
    <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">insert</span> <span class="n">hd</span> <span class="o">(</span><span class="n">fromList</span> <span class="n">tl</span><span class="o">)</span>
<span class="k">end</span>
</code></pre></div><p><code>heap.mli</code></p>
<div class="highlight"><pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="c">(* Input signature of the functor *)</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">OrderedType</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="c">(* the type of the heap elements *)</span>
  <span class="k">type</span> <span class="n">t</span>

  <span class="c">(* compare function used to determine the order of elements *)</span>
  <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Make</span> <span class="o">:</span> <span class="k">functor</span> <span class="o">(</span><span class="nc">Ord</span> <span class="o">:</span> <span class="nc">OrderedType</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">elt</span> <span class="o">=</span> <span class="nn">Ord</span><span class="p">.</span><span class="n">t</span>

  <span class="k">type</span> <span class="n">tree</span>

  <span class="c">(* create an empty heap, with only a leaf *)</span>
  <span class="k">val</span> <span class="n">create</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="n">tree</span>

  <span class="c">(* merge to heap, the most important function in leftist heap *)</span>
  <span class="k">val</span> <span class="n">merge</span> <span class="o">:</span> <span class="n">tree</span> <span class="o">-&gt;</span> <span class="n">tree</span> <span class="o">-&gt;</span> <span class="n">tree</span>

  <span class="c">(* insert an element into a heap, just like merge two heap *)</span>
  <span class="k">val</span> <span class="n">insert</span> <span class="o">:</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="n">tree</span> <span class="o">-&gt;</span> <span class="n">tree</span>

  <span class="c">(* get the top element of a heap *)</span>
  <span class="k">val</span> <span class="n">getTop</span> <span class="o">:</span> <span class="n">tree</span> <span class="o">-&gt;</span> <span class="n">elt</span>

  <span class="c">(* delete the top element of a heap, just merge two children trees *)</span>
  <span class="k">val</span> <span class="n">deleteTop</span> <span class="o">:</span> <span class="n">tree</span> <span class="o">-&gt;</span> <span class="n">tree</span>

  <span class="c">(* generate a list from a heap *)</span>
  <span class="k">val</span> <span class="n">toList</span> <span class="o">:</span> <span class="n">tree</span> <span class="o">-&gt;</span> <span class="n">elt</span> <span class="kt">list</span>

  <span class="c">(* create a heap from list *)</span>
  <span class="k">val</span> <span class="n">fromList</span> <span class="o">:</span> <span class="n">elt</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">tree</span>
<span class="k">end</span>
</code></pre></div><p><code>test.ml</code></p>
<p>测试文件，对所写的堆向外提供的函数进行测试。创建了一个带 <code>int</code> 类型的函子，采用自定义的排序函数实现大顶堆。还创建了一个 <code>String</code> 类型的函子</p>
<div class="highlight"><pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="c">(* int 型函子，带比较函数 *)</span>
<span class="k">module</span> <span class="nc">E</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>

  <span class="k">let</span> <span class="n">compare</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">compare</span> <span class="n">a</span> <span class="n">b</span>
<span class="k">end</span>

<span class="c">(* int 型大顶堆，采用左偏树 *)</span>
<span class="k">module</span> <span class="nc">H_int</span> <span class="o">=</span> <span class="nn">Heap</span><span class="p">.</span><span class="nc">Make</span> <span class="o">(</span><span class="nc">E</span><span class="o">)</span>

<span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">H_int</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span>

<span class="c">(* 测试基本的插入、删除等操作 *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span>
    <span class="nn">H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">3</span> <span class="n">t</span> <span class="o">|&gt;</span> <span class="nn">H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">5</span> <span class="o">|&gt;</span> <span class="nn">H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">1</span> <span class="o">|&gt;</span> <span class="nn">H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">4</span>
    <span class="o">|&gt;</span> <span class="nn">H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">2</span>
  <span class="k">in</span>
  <span class="k">assert</span> <span class="o">(</span><span class="nn">H_int</span><span class="p">.</span><span class="n">getTop</span> <span class="n">t</span> <span class="o">=</span> <span class="n">5</span><span class="o">);</span>
  <span class="k">assert</span> <span class="o">(</span><span class="nn">H_int</span><span class="p">.</span><span class="n">deleteTop</span> <span class="n">t</span> <span class="o">|&gt;</span> <span class="nn">H_int</span><span class="p">.</span><span class="n">deleteTop</span> <span class="o">|&gt;</span> <span class="nn">H_int</span><span class="p">.</span><span class="n">getTop</span> <span class="o">=</span> <span class="n">3</span><span class="o">);</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&#34;%d &#34;</span><span class="o">)</span> <span class="o">(</span><span class="nn">H_int</span><span class="p">.</span><span class="n">toList</span> <span class="n">t</span><span class="o">);</span>
  <span class="n">print_newline</span> <span class="bp">()</span>

<span class="c">(* 测试从 list 构建和生成 list *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">H_int</span><span class="p">.</span><span class="n">toList</span> <span class="o">(</span><span class="nn">H_int</span><span class="p">.</span><span class="n">fromList</span> <span class="o">[</span> <span class="n">4</span><span class="o">;</span> <span class="n">2</span><span class="o">;</span> <span class="n">1</span><span class="o">;</span> <span class="n">5</span><span class="o">;</span> <span class="n">6</span><span class="o">;</span> <span class="n">7</span><span class="o">;</span> <span class="n">2</span><span class="o">;</span> <span class="n">0</span> <span class="o">])</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">l</span> <span class="o">=</span> <span class="o">[</span> <span class="n">7</span><span class="o">;</span> <span class="n">6</span><span class="o">;</span> <span class="n">5</span><span class="o">;</span> <span class="n">4</span><span class="o">;</span> <span class="n">2</span><span class="o">;</span> <span class="n">2</span><span class="o">;</span> <span class="n">1</span><span class="o">;</span> <span class="n">0</span> <span class="o">]);</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&#34;%d &#34;</span><span class="o">)</span> <span class="n">l</span><span class="o">;</span>
  <span class="n">print_newline</span> <span class="bp">()</span>

<span class="c">(* 测试合并两个堆 *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span>
    <span class="nn">H_int</span><span class="p">.</span><span class="n">merge</span>
      <span class="o">(</span><span class="nn">H_int</span><span class="p">.</span><span class="n">fromList</span> <span class="o">[</span> <span class="n">1</span><span class="o">;</span> <span class="n">3</span><span class="o">;</span> <span class="n">5</span><span class="o">;</span> <span class="n">7</span><span class="o">;</span> <span class="n">9</span> <span class="o">])</span>
      <span class="o">(</span><span class="nn">H_int</span><span class="p">.</span><span class="n">fromList</span> <span class="o">[</span> <span class="n">2</span><span class="o">;</span> <span class="n">4</span><span class="o">;</span> <span class="n">6</span><span class="o">;</span> <span class="n">8</span> <span class="o">])</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">H_int</span><span class="p">.</span><span class="n">toList</span> <span class="n">t</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">l</span> <span class="o">=</span> <span class="o">[</span> <span class="n">9</span><span class="o">;</span> <span class="n">8</span><span class="o">;</span> <span class="n">7</span><span class="o">;</span> <span class="n">6</span><span class="o">;</span> <span class="n">5</span><span class="o">;</span> <span class="n">4</span><span class="o">;</span> <span class="n">3</span><span class="o">;</span> <span class="n">2</span><span class="o">;</span> <span class="n">1</span> <span class="o">]);</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&#34;%d &#34;</span><span class="o">)</span> <span class="n">l</span><span class="o">;</span>
  <span class="n">print_newline</span> <span class="bp">()</span>

<span class="c">(* string 型小顶堆 *)</span>
<span class="k">module</span> <span class="nc">H_string</span> <span class="o">=</span> <span class="nn">Heap</span><span class="p">.</span><span class="nc">Make</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span>

<span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">H_string</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span>

<span class="c">(* 测试基本的插入、删除等操作 *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span>
    <span class="nn">H_string</span><span class="p">.</span><span class="n">insert</span> <span class="s2">&#34;asdf&#34;</span> <span class="n">t</span> <span class="o">|&gt;</span> <span class="nn">H_string</span><span class="p">.</span><span class="n">insert</span> <span class="s2">&#34;qwer&#34;</span> <span class="o">|&gt;</span> <span class="nn">H_string</span><span class="p">.</span><span class="n">insert</span> <span class="s2">&#34;zz&#34;</span>
  <span class="k">in</span>
  <span class="k">assert</span> <span class="o">(</span><span class="nn">H_string</span><span class="p">.</span><span class="n">getTop</span> <span class="n">t</span> <span class="o">=</span> <span class="s2">&#34;asdf&#34;</span><span class="o">);</span>
  <span class="k">assert</span> <span class="o">(</span>
    <span class="nn">H_string</span><span class="p">.</span><span class="n">toList</span>
      <span class="o">(</span><span class="nn">H_string</span><span class="p">.</span><span class="n">deleteTop</span> <span class="n">t</span> <span class="o">|&gt;</span> <span class="nn">H_string</span><span class="p">.</span><span class="n">deleteTop</span> <span class="o">|&gt;</span> <span class="nn">H_string</span><span class="p">.</span><span class="n">insert</span> <span class="s2">&#34;bb&#34;</span><span class="o">)</span>
    <span class="o">=</span> <span class="o">[</span> <span class="s2">&#34;bb&#34;</span><span class="o">;</span> <span class="s2">&#34;zz&#34;</span> <span class="o">]</span> <span class="o">)</span>

<span class="c">(* 测试 string 类型上的操作 *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">l</span> <span class="o">=</span>
    <span class="nn">H_string</span><span class="p">.</span><span class="n">toList</span>
      <span class="o">(</span><span class="nn">H_string</span><span class="p">.</span><span class="n">merge</span>
         <span class="o">(</span><span class="nn">H_string</span><span class="p">.</span><span class="n">fromList</span> <span class="o">[</span> <span class="s2">&#34;Z&#34;</span><span class="o">;</span> <span class="s2">&#34;Y&#34;</span><span class="o">;</span> <span class="s2">&#34;X&#34;</span> <span class="o">])</span>
         <span class="o">(</span><span class="nn">H_string</span><span class="p">.</span><span class="n">fromList</span> <span class="o">[</span> <span class="s2">&#34;y&#34;</span><span class="o">;</span> <span class="s2">&#34;z&#34;</span><span class="o">;</span> <span class="s2">&#34;x&#34;</span> <span class="o">]))</span>
  <span class="k">in</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">l</span> <span class="o">=</span> <span class="o">[</span> <span class="s2">&#34;X&#34;</span><span class="o">;</span> <span class="s2">&#34;Y&#34;</span><span class="o">;</span> <span class="s2">&#34;Z&#34;</span><span class="o">;</span> <span class="s2">&#34;x&#34;</span><span class="o">;</span> <span class="s2">&#34;y&#34;</span><span class="o">;</span> <span class="s2">&#34;z&#34;</span> <span class="o">]);</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&#34;%s &#34;</span><span class="o">)</span> <span class="n">l</span><span class="o">;</span>
  <span class="n">print_newline</span> <span class="bp">()</span>

<span class="c">(* int 型大顶堆，采用数组模拟完全二叉树 *)</span>
<span class="k">module</span> <span class="nc">B_H_int</span> <span class="o">=</span> <span class="nn">Binary_heap</span><span class="p">.</span><span class="nc">Make</span> <span class="o">(</span><span class="nc">E</span><span class="o">)</span>

<span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">B_H_int</span><span class="p">.</span><span class="n">create</span> <span class="n">20</span> <span class="n">0</span>

<span class="c">(* 测试基本的插入、删除等操作 *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">B_H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">1</span> <span class="n">t</span><span class="o">;</span>
  <span class="nn">B_H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">3</span> <span class="n">t</span><span class="o">;</span>
  <span class="nn">B_H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">2</span> <span class="n">t</span><span class="o">;</span>
  <span class="nn">B_H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">4</span> <span class="n">t</span><span class="o">;</span>
  <span class="k">assert</span> <span class="o">(</span><span class="nn">B_H_int</span><span class="p">.</span><span class="n">getTop</span> <span class="n">t</span> <span class="o">=</span> <span class="n">4</span><span class="o">);</span>
  <span class="nn">B_H_int</span><span class="p">.</span><span class="n">deleteTop</span> <span class="n">t</span><span class="o">;</span>
  <span class="k">assert</span> <span class="o">(</span><span class="nn">B_H_int</span><span class="p">.</span><span class="n">getTop</span> <span class="n">t</span> <span class="o">=</span> <span class="n">3</span><span class="o">);</span>
  <span class="nn">B_H_int</span><span class="p">.</span><span class="n">deleteTop</span> <span class="n">t</span><span class="o">;</span>
  <span class="k">assert</span> <span class="o">(</span><span class="nn">B_H_int</span><span class="p">.</span><span class="n">getTop</span> <span class="n">t</span> <span class="o">=</span> <span class="n">2</span><span class="o">);</span>
  <span class="nn">B_H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">6</span> <span class="n">t</span><span class="o">;</span>
  <span class="k">assert</span> <span class="o">(</span><span class="nn">B_H_int</span><span class="p">.</span><span class="n">getTop</span> <span class="n">t</span> <span class="o">=</span> <span class="n">6</span><span class="o">);</span>
  <span class="nn">B_H_int</span><span class="p">.</span><span class="n">deleteTop</span> <span class="n">t</span><span class="o">;</span>
  <span class="nn">B_H_int</span><span class="p">.</span><span class="n">deleteTop</span> <span class="n">t</span><span class="o">;</span>
  <span class="k">assert</span> <span class="o">(</span><span class="nn">B_H_int</span><span class="p">.</span><span class="n">getTop</span> <span class="n">t</span> <span class="o">=</span> <span class="n">1</span><span class="o">)</span>

<span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">B_H_int</span><span class="p">.</span><span class="n">create</span> <span class="n">20</span> <span class="n">0</span>

<span class="c">(* 测试生成 list *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">B_H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">1</span> <span class="n">t</span><span class="o">;</span>
  <span class="nn">B_H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">3</span> <span class="n">t</span><span class="o">;</span>
  <span class="nn">B_H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">2</span> <span class="n">t</span><span class="o">;</span>
  <span class="nn">B_H_int</span><span class="p">.</span><span class="n">insert</span> <span class="n">4</span> <span class="n">t</span><span class="o">;</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&#34;%d &#34;</span><span class="o">)</span> <span class="o">(</span><span class="nn">B_H_int</span><span class="p">.</span><span class="n">toList</span> <span class="n">t</span><span class="o">);</span>
  <span class="n">print_newline</span> <span class="bp">()</span>

<span class="c">(* 测试从 list 构建 *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">B_H_int</span><span class="p">.</span><span class="n">fromList</span> <span class="n">20</span> <span class="n">0</span> <span class="o">[</span> <span class="n">1</span><span class="o">;</span> <span class="n">3</span><span class="o">;</span> <span class="n">5</span><span class="o">;</span> <span class="n">7</span><span class="o">;</span> <span class="n">9</span><span class="o">;</span> <span class="n">2</span><span class="o">;</span> <span class="n">4</span><span class="o">;</span> <span class="n">6</span><span class="o">;</span> <span class="n">8</span><span class="o">;</span> <span class="n">0</span> <span class="o">]</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="o">(</span><span class="nn">B_H_int</span><span class="p">.</span><span class="n">toList</span> <span class="n">t</span> <span class="o">=</span> <span class="o">[</span> <span class="n">9</span><span class="o">;</span> <span class="n">8</span><span class="o">;</span> <span class="n">7</span><span class="o">;</span> <span class="n">6</span><span class="o">;</span> <span class="n">5</span><span class="o">;</span> <span class="n">4</span><span class="o">;</span> <span class="n">3</span><span class="o">;</span> <span class="n">2</span><span class="o">;</span> <span class="n">1</span><span class="o">;</span> <span class="n">0</span> <span class="o">])</span>

<span class="c">(* 测试两种堆实现的结果一致 *)</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t1</span> <span class="o">=</span> <span class="nn">H_int</span><span class="p">.</span><span class="n">fromList</span> <span class="o">[</span> <span class="n">1</span><span class="o">;</span> <span class="n">3</span><span class="o">;</span> <span class="n">5</span><span class="o">;</span> <span class="n">7</span><span class="o">;</span> <span class="n">9</span><span class="o">;</span> <span class="n">2</span><span class="o">;</span> <span class="n">4</span><span class="o">;</span> <span class="n">6</span><span class="o">;</span> <span class="n">8</span><span class="o">;</span> <span class="n">0</span> <span class="o">]</span>
  <span class="ow">and</span> <span class="n">t2</span> <span class="o">=</span> <span class="nn">B_H_int</span><span class="p">.</span><span class="n">fromList</span> <span class="n">20</span> <span class="n">0</span> <span class="o">[</span> <span class="n">1</span><span class="o">;</span> <span class="n">3</span><span class="o">;</span> <span class="n">5</span><span class="o">;</span> <span class="n">7</span><span class="o">;</span> <span class="n">9</span><span class="o">;</span> <span class="n">2</span><span class="o">;</span> <span class="n">4</span><span class="o">;</span> <span class="n">6</span><span class="o">;</span> <span class="n">8</span><span class="o">;</span> <span class="n">0</span> <span class="o">]</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="o">(</span><span class="nn">H_int</span><span class="p">.</span><span class="n">toList</span> <span class="n">t1</span> <span class="o">=</span> <span class="nn">B_H_int</span><span class="p">.</span><span class="n">toList</span> <span class="n">t2</span><span class="o">)</span>
</code></pre></div><p>项目采用 <code>make</code> 进行构建</p>
<div class="highlight"><pre class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">.PHONY</span><span class="o">:</span>	<span class="n">all</span> <span class="n">clean</span> <span class="n">byte</span> <span class="n">native</span> <span class="n">profile</span> <span class="n">debug</span> <span class="n">test</span> <span class="n">run</span>

<span class="nv">OCB_FLAGS</span> <span class="o">=</span> -tag bin_annot
<span class="nv">OCB</span> <span class="o">=</span> 		ocamlbuild <span class="k">$(</span>OCB_FLAGS<span class="k">)</span>

<span class="nf">all</span><span class="o">:</span> <span class="n">native</span> <span class="n">byte</span>

<span class="nf">clean</span><span class="o">:</span>
	<span class="k">$(</span>OCB<span class="k">)</span> -clean

<span class="nf">native</span><span class="o">:</span>
	<span class="k">$(</span>OCB<span class="k">)</span> main.native

<span class="nf">byte</span><span class="o">:</span>
	<span class="k">$(</span>OCB<span class="k">)</span> main.byte

<span class="nf">profile</span><span class="o">:</span>
	<span class="k">$(</span>OCB<span class="k">)</span> -tag profile main.native

<span class="nf">debug</span><span class="o">:</span>
	<span class="k">$(</span>OCB<span class="k">)</span> -tag debug main.byte

<span class="nf">run</span><span class="o">:</span> <span class="n">native</span>
	./main.native
</code></pre></div><h1 id="心得体会">心得体会</h1>
<p>第一次用纯函数式语言写一个算法，和之前上课时在 <code>toplevel</code> 中测试还是有较大的区别，包括如何实现多文件编译，如何配置编译，如何编写模块等都困扰了我很久。最后依靠文档、手册、github上的一些项目等学会了如何构建一个 <code>Ocaml</code> 项目。</p>
<p>此外，<code>Ocaml</code> 标准库也给了我很大的帮助，里面的标准库如 <code>Set</code> 等都写得很清晰，有很详细的注释，我写的堆的模块结构、函子等都是参考 <code>Set</code> 库的处理方式。</p>
<p>对于函数式语言，特别是纯函数式的思想我也有了更深刻的理解。一开始我还是以命令式的思维来编写代码，认为不使用 <code>for</code> 、<code>while</code> 语句就是函数式，代码中还是存在很多 <code>mutable</code> 、<code>ref</code> 等内容，即存在副作用，也就导致了函数操作还是对一个“对象”进行操作，而不是每次返回一个新的结果。后来参考各种项目、教程，才发现了纯函数式“无副作用”的核心思想及处理方式。</p>
<p>我认为，纯函数式语言更贴近数学模型，可以用非常简练的语句写出算法，其核心是递归和迭代，例如我的堆通过短短几十行语句就实现了，通过一些精巧的递归就实现了命令式语言要写大量循环命令才能实现的功能。但这些简洁也带来了一些问题，比如代码抽象程度较高，理解起来较为困难；大量递归对栈上空间造成很大压力，性能降低了的同时也难以进行大量的计算，需要花费很大的力气去消除尾递归（但通常很难实现）；不允许副作用造成时间、空间的浪费；思维在两种思想中的转换较为困难等。但总的来说，函数式语言还是有很好的前景，从近年来越来越多的语言都开始支持函数式的写法（如 <code>lambda</code> 表达式等）可以看出。如 <code>C++</code> 、<code>Python</code> 、<code>Java</code> 等都有函数式的写法，我在平时编写代码的过程中也会用到函数式语句来简化代码。函数式语言和命令式语言在未来可能会越走越近，取长补短，最后融为一体。</p>]]></content>
        <author>
            <name><![CDATA[Creedowl’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.stdioa.com/2021/02/alpine-time-call/</id>
        <title><![CDATA[由 TT-RSS 解析数据库地址失败引出的一个问题]]></title>
        <updated>2021-02-23T12:59:07+08:00</updated>
        <link href="https://blog.stdioa.com/2021/02/alpine-time-call/"/>
        <content type="text/html" src="https://blog.stdioa.com/2021/02/alpine-time-call/"><![CDATA[<p>水一篇文章，主要用来告诫自己认真看文档。🌚</p>]]></content>
        <author>
            <name><![CDATA[Stdio’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://nuaa-s3lab.github.io/dailyPaper/2021/0129.html</id>
        <title><![CDATA[2021-01-29 论文推荐]]></title>
        <updated>2021-01-29T00:00:00+08:00</updated>
        <link href="https://nuaa-s3lab.github.io/dailyPaper/2021/0129.html"/>
        <content type="text/html" src="https://nuaa-s3lab.github.io/dailyPaper/2021/0129.html"><![CDATA[2021-01-29 论文推荐]]></content>
        <author>
            <name><![CDATA[S3lab 每日论文推荐]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://nuaa-s3lab.github.io/dailyPaper/2021/0128.html</id>
        <title><![CDATA[2021-01-28 论文推荐]]></title>
        <updated>2021-01-28T00:00:00+08:00</updated>
        <link href="https://nuaa-s3lab.github.io/dailyPaper/2021/0128.html"/>
        <content type="text/html" src="https://nuaa-s3lab.github.io/dailyPaper/2021/0128.html"><![CDATA[2021-01-28 论文推荐]]></content>
        <author>
            <name><![CDATA[S3lab 每日论文推荐]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://nuaa-s3lab.github.io/dailyPaper/2021/0127.html</id>
        <title><![CDATA[2021-01-27 论文推荐]]></title>
        <updated>2021-01-27T00:00:00+08:00</updated>
        <link href="https://nuaa-s3lab.github.io/dailyPaper/2021/0127.html"/>
        <content type="text/html" src="https://nuaa-s3lab.github.io/dailyPaper/2021/0127.html"><![CDATA[2021-01-27 论文推荐]]></content>
        <author>
            <name><![CDATA[S3lab 每日论文推荐]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://nuaa-s3lab.github.io/dailyPaper/2021/0126.html</id>
        <title><![CDATA[2021-01-26 论文推荐]]></title>
        <updated>2021-01-26T00:00:00+08:00</updated>
        <link href="https://nuaa-s3lab.github.io/dailyPaper/2021/0126.html"/>
        <content type="text/html" src="https://nuaa-s3lab.github.io/dailyPaper/2021/0126.html"><![CDATA[2021-01-26 论文推荐]]></content>
        <author>
            <name><![CDATA[S3lab 每日论文推荐]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://nuaa-s3lab.github.io/dailyPaper/2021/0125.html</id>
        <title><![CDATA[2021-01-25 论文推荐]]></title>
        <updated>2021-01-25T00:00:00+08:00</updated>
        <link href="https://nuaa-s3lab.github.io/dailyPaper/2021/0125.html"/>
        <content type="text/html" src="https://nuaa-s3lab.github.io/dailyPaper/2021/0125.html"><![CDATA[2021-01-25 论文推荐]]></content>
        <author>
            <name><![CDATA[S3lab 每日论文推荐]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.stdioa.com/2020/12/protobuf-upgrade/</id>
        <title><![CDATA[protobuf 升级后带来的一些坑]]></title>
        <updated>2020-12-27T06:53:32+08:00</updated>
        <link href="https://blog.stdioa.com/2020/12/protobuf-upgrade/"/>
        <content type="text/html" src="https://blog.stdioa.com/2020/12/protobuf-upgrade/"><![CDATA[<p>前段时间把公司某项目依赖的 <code>github.com/golang/protobuf</code> 的版本从 v1.3.3 升级到了 v1.4.2，本文记录了升级过程中遇到的一些问题。</p>]]></content>
        <author>
            <name><![CDATA[Stdio’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.creedowl.com/posts/gpg/</id>
        <title><![CDATA[GPG使用笔记]]></title>
        <updated>2020-04-02T06:47:31+08:00</updated>
        <link href="https://blog.creedowl.com/posts/gpg/"/>
        <content type="text/html" src="https://blog.creedowl.com/posts/gpg/"><![CDATA[<h2 id="why-gpg">Why GPG?</h2>
<p><a href="https://zh.wikipedia.org/wiki/GnuPG">GPG</a> 是一个密码学软件，用于加密、签名通信内容及管理非对称密码学的密钥，具体历史、介绍可以在wiki中看到，<a href="https://gnupg.org/">官网</a></p>
<p>而我使用 GPG 的缘由是，在 Github 上提交时，如果使用 GPG 对提交进行签名，会有一个<code>Verified</code>标识<del>看起来很nb</del></p>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/UTOOLS1585795152275.png/compress" alt="UTOOLS1585795152275.png"></p>
<p>当然使用 GPG 不仅是为了好看，它能确保你提供的信息是由你自己发布的，无法被别人篡改、冒充，前提是保护好自己的 GPG 私钥</p>
<h2 id="安装">安装</h2>
<p>这边以 MacOS 为示例进行操作</p>
<p><strong>强烈建议 MacOS 用户使用 <a href="https://gpgtools.org/">GPG Suite</a> 进行操作，可以避免一些奇奇怪怪的问题</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">brew cask install gpg-suite
</code></pre></div><p><del>仅安装 GPG 本体</del></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># deprecated</span>
brew install gpg
</code></pre></div><h2 id="生成密钥">生成密钥</h2>
<p>GPG 采用非对称加密，一切的操作都需要有密钥。网上一些教程中的操作与我使用的 GPG 版本 <code>gpg (GnuPG/MacGPG2) 2.2.17</code> 有点出入，以下操作都在我所使用的版本下进行</p>
<p>有两个命令用于生成密钥，为<code>gpg --gen-key</code>和<code>gpg --full-gen-key</code>，区别是前者采用默认的配置不可更改，后者能自定义配置。我们采用后一种，首先选择密钥类型，默认的<code>1</code>就可以了</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ gpg --full-gen-key
gpg <span class="o">(</span>GnuPG/MacGPG2<span class="o">)</span> 2.2.17<span class="p">;</span> Copyright <span class="o">(</span>C<span class="o">)</span> <span class="m">2019</span> Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

请选择您要使用的密钥类型：
   <span class="o">(</span>1<span class="o">)</span> RSA 和 RSA （默认）
   <span class="o">(</span>2<span class="o">)</span> DSA 和 Elgamal
   <span class="o">(</span>3<span class="o">)</span> DSA（仅用于签名）
   <span class="o">(</span>4<span class="o">)</span> RSA（仅用于签名）
您的选择是？ <span class="m">1</span>
</code></pre></div><p>接着选择密钥长度，默认<code>2048</code>即可</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">RSA 密钥的长度应在 1024 位与 4096 位之间。
您想要使用的密钥长度？(2048) 2048
</code></pre></div><p>然后设定密钥的有效期限，我们没有特殊需求，设置永不过期即可</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">请设定这个密钥的有效期限。
         0 = 密钥永不过期
      &lt;n&gt;  = 密钥在 n 天后过期
      &lt;n&gt;w = 密钥在 n 周后过期
      &lt;n&gt;m = 密钥在 n 月后过期
      &lt;n&gt;y = 密钥在 n 年后过期
密钥的有效期限是？(0) 0
</code></pre></div><p>确认上述设置后，依次输入姓名、邮箱和注释，这里我使用随机信息用于演示</p>
<pre><code>GnuPG 需要构建用户标识以辨认您的密钥。

真实姓名： naive
电子邮件地址： naive@test.com
注释： too young too simple
您选定了此用户标识：
    “naive (too young too simple) &lt;naive@test.com&gt;”

更改姓名（N）、注释（C）、电子邮件地址（E）或确定（O）/退出（Q）？
</code></pre>
<p>确定后，需要设定密钥的密码，如果你采用了 <code>GPG Suite</code> ，会出现一个窗口，在此输入密码</p>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/UTOOLS1585796741624.png/compress" alt="UTOOLS1585796741624.png"></p>
<p>如果没使用<code>GPG Suite</code>，则会在你当前终端弹出一个全屏终端窗口，同样是输入密码。</p>
<blockquote>
<p>注意，在 mac 终端环境下，如果语言是中文的话，这个终端窗口可能会乱码，但不影响使用，也可以临时设置语言为英文解决这个问题<code>LANGUAGE=en gpg --full-generate-key</code>。但千万不要用<code>ctrl-c</code>结束这个进程，这会破坏当前终端环境，后面的输入会变得很奇怪，而且后台进程不会结束，会占满你的CPU</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">我们需要生成大量的随机字节。在质数生成期间做些其他操作（敲打键盘
、移动鼠标、读写硬盘之类的）将会是一个不错的主意；这会让随机数
发生器有更好的机会获得足够的熵。
gpg: 密钥 4C26D2E451FFDAF1 被标记为绝对信任
gpg: 目录‘/Users/creedowl/.gnupg/openpgp-revocs.d’已创建
gpg: 吊销证书已被存储为‘/Users/creedowl/.gnupg/openpgp-revocs.d/0B3C52F1EF07B14EA7C45C9A4C26D2E451FFDAF1.rev’
公钥和私钥已经生成并被签名。

pub   rsa2048 2020-04-02 [SC]
      0B3C52F1EF07B14EA7C45C9A4C26D2E451FFDAF1
uid                      naive (too young too simple) &lt;naive@test.com&gt;
sub   rsa2048 2020-04-02 [E]
</code></pre></div><p>这样，密钥就生成完成，其中<code>4C26D2E451FFDAF1</code>就是你的密钥名，后续操作都需要通过这个密钥名选择密钥，但也可以通过之前设置的姓名或邮箱代替操作</p>
<h2 id="gpg-常用操作">GPG 常用操作</h2>
<p>GPG 最基础的操作就是对文件等信息进行加密、签名，首先创建一个测试文件<code>test.txt</code></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">echo</span> <span class="nb">test</span> &gt; test.txt
</code></pre></div><h3 id="加密">加密</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg --recipient creedowl --output test.txt.gpg --encrypt test.txt
</code></pre></div><p>其中<code>--recipient</code>指定接收者，简写为<code>-r</code>，设定接受者时需要你本地有接收者的<strong>公钥</strong>，可以用密钥名、姓名或者邮箱进行指定。<code>--output</code>指定输出文件名，可省略。<code>--encrypt</code>指定待加密的文件，简写为<code>-e</code>。这样在你当前目录下会生成一个<code>test.txt.gpg</code>即加密后的文件，你就可以把这个文件发送给接受者，不必担心文件内容被第三方读取</p>
<p><strong>注意</strong>这里生成加密文件为二进制格式，有时候（如通过邮件发送）不便于操作，可以加上<code>--armor</code>参数（简写为<code>-a</code>）生成文本格式的密文，如</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg -r creedowl -ae test.txt
</code></pre></div><p>生成的加密文件为<code>test.txt.asc</code></p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">-----BEGIN PGP MESSAGE-----

hQEMA9KmvDhAMTGrAQf+KITqx4HTpWsevIEfRFlw5g+jt8l8ol3fuww0gBoMEPBG
KaqxCmjIpHZdGmaXwBSKadmeieZGLsm1CYuf4gbv4FpdWgveVWnLvB/HmwuvnmJt
YhTtapNgkQ++mwPbH4WKeOFQ58U5dZ7C+R8rrucRRYQBRTH6AJQY82aV1KXTqyF1
D8c/2ANW7aCWr8W/ogCbEqH47VE3foP+aSD+JMPtdnaYWIPzyr5x5lw6ASwxD4hB
ikOUcJTxp+GyFLTd3n1zCvSP9ZQzvolur7soqZVP8t4hxlALGL+KYN4YgubcPt5y
bucMYWkbLlZM+AuAYzSCLaSmkgkiYUFEkwKJWdLr+NJGAY5Mk+bnEP2k/kKxl9vo
/LVsloiYbg9M184LxUNfZRBnKcI9vKw/C6uU2Ee5wKUMsy3Epnp60Fe5u5fj5yn7
0JjMBmY+gQ==
=8K/i
-----END PGP MESSAGE-----
</code></pre></div><h3 id="解密">解密</h3>
<p>有了密文就要对其进行解密得到原文。注意要进行解密，你必须有接受者的<strong>私钥</strong>。公钥是公开的，任何人都可以查看、使用，而<strong>私钥</strong>是私有的，一定要保管好，如果泄露了这个 GPG 密钥就等同于失效了，需要吊销。这就是非对称加密</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">	gpg --decrypt test.txt.asc --output out.txt
</code></pre></div><p>其中<code>--decrypt</code>声明该命令进行解密，简写为<code>-d</code>，<code>--output</code>指定输出文件，默认输出到终端。注意解密时需要输入你密钥的密码，所以也一定要保管好密码</p>
<h3 id="签名">签名</h3>
<p>有的时候不需要对文件进行签名，只需要确保文件是由本人发出的，这个时候就可以用到签名</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg --sign test.txt
</code></pre></div><p>会生成二进制的签名文件<code>test.txt.gpg</code>，如果想生成文本类型的签名，使用</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg --clearsign test.txt
</code></pre></div><p>会生成文本类型的签名文件<code>test.txt.asc</code></p>
<p>注意以上两种方式原文和签名是在同一个文件中，查看<code>test.txt.asc</code></p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

test
-----BEGIN PGP SIGNATURE-----

iQFDBAEBCAAtFiEECzxS8e8HsU6nxFyaTCbS5FH/2vEFAl6FX+cPHG5haXZlQHRl
c3QuY29tAAoJEEwm0uRR/9rxGNsH/AmjJiT19q5caq9Pe8tMRnR2yvZIGWbMD3Ch
UTkyGMkSPMIo6XRpYPlANe2/dddBT2l7EAPy2lAxaa8LcjsxtRhJG4GxMaCcujik
M6MX3IOfa1m9aDP1IY3Sh2U07j3t+8dawahR8EUF2D+rtvx24ybnwpWpKbDVsGyp
Mt06BI3pWC3opMRYPCl21IBhPhaPPnvXF7X8DMP+2VqZye2juX2oG1KMkZWQuiBb
/D7DYlx6/ainu0cJw6UL8YXHag7tkUeKtTPQbBpCsszOuxJZ74gduIUzDcokayCB
DM9qB/GpUyVOOTwfLMBta6JP5BO8ppPaPdPX46kKDqLKG7eh4bQ=
=Q4/W
-----END PGP SIGNATURE-----
</code></pre></div><p>因为是签名，不会对内容进行加密，所以直接显示原文。如果想把原始文件分离出来，使用</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg --output out.txt -d test.txt.gpg
</code></pre></div><p>分离的同时还顺便校验了签名。注意这里<code>test.txt.gpg</code>是上面生成的二进制<strong>签名</strong>文件，也可以用<code>test.txt.asc</code></p>
<p>如果每次都要分离，就很麻烦，而且没有安装 GPG 的用户就无法使用源文件了。所以更好的方式是分离源文件和签名文件</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg --detach-sign --armor test.txt
</code></pre></div><p>这样会生成一个单独的、文本类型的签名文件<code>test.txt.sig</code></p>
<blockquote>
<p>注意：如果有多个私钥，可以用<code>-u</code>参数选择</p>
</blockquote>
<h3 id="签名校验">签名校验</h3>
<p>收到文件和签名文件后，需要对签名进行校验</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg --verify test.txt.sig test.txt
</code></pre></div><p>如果签名校验成功，会显示</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg: 签名建立于 四  4/ <span class="m">2</span> 11:49:35 <span class="m">2020</span> CST
gpg:               使用 RSA 密钥 34B368EFC6FA8941B4A096CFFA4C884FBE8164D7
gpg: 完好的签名，来自于 “creedowl &lt;creedowl@gmail.com&gt;” <span class="o">[</span>绝对<span class="o">]</span>
</code></pre></div><h3 id="导入导出">导入导出</h3>
<p>当你需要与他人交换数据时，需要导出自己的公钥，同时导入他人的公钥；而如果你更换电脑，就需要导出自己的私钥。这就涉及到了密钥的导入导出</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg -a --output public_key.txt --export naive
</code></pre></div><p>上述命令用于导出公钥，相关参数在上文都有介绍。接着你就可以把<code>public_key.txt</code>发布给他人</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg -a --output private_key.txt --export-secret-keys naive
</code></pre></div><p>上述命令用于导出私钥，一定要保管好，建议在脱机情况下进行操作</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg --improt <span class="o">[</span>密钥文件<span class="o">]</span>
</code></pre></div><p>上述命令用于导入密钥，不区分公钥私钥</p>
<h3 id="查看所有密钥">查看所有密钥</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg -k
</code></pre></div><h3 id="生成吊销证书">生成吊销证书</h3>
<p>当你的私钥泄露或者更换时，需要吊销失效的密钥，这时就需要使用吊销证书</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg --gen-revoke naive
</code></pre></div><p>接着选择吊销原因，就能生成吊销证书</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">sec  rsa2048/4C26D2E451FFDAF1 2020-04-02 naive (too young too simple) &lt;naive@test.com&gt;

要为这个密钥创建一个吊销证书吗？(y/N) y
请选择吊销的原因：
  0 = 未指定原因
  1 = 密钥已泄漏
  2 = 密钥被替换
  3 = 密钥不再使用
  Q = 取消
（也许您会想要在这里选择 1）
您的决定是什么？ 1
请输入描述（可选）；以空白行结束：
&gt;
吊销原因：密钥已泄漏
（未给定描述）
这样可以吗？ (y/N) y
已强行使用 ASCII 字符封装过的输出。
-----BEGIN PGP PUBLIC KEY BLOCK-----
Comment: This is a revocation certificate

****
-----END PGP PUBLIC KEY BLOCK-----
已创建吊销证书。

请把这个文件转移到一个您可以藏起来的介质上；如果坏人获取到了这
份证书的话，那么他就能使用它并让您的密钥无法继续使用。把此证书
打印出来再存放到安全的地方也是很好的方法，以免您的保存媒体变得
不可读。但是千万小心：您机器上的打印系统可能会在打印过程中储存
这些数据，并使得其他人看到！
</code></pre></div><p>只需要保存中间的吊销证书，当密钥泄露时将其发送到公钥服务器，就可以吊销旧密钥</p>
<h3 id="编辑密钥">编辑密钥</h3>
<p>有时候需要对密钥进行编辑，如修改信任度，生成子密钥等，使用以下命令</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">gpg --edit-key naive
</code></pre></div><p>接着就会进入交互模式等待命令，输入<code>help</code>可以查看所有操作</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">gpg (GnuPG/MacGPG2) 2.2.17; Copyright (C) 2019 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

私钥可用。

sec  rsa2048/4C26D2E451FFDAF1
     创建于：2020-04-02  有效至：永不       可用于：SC
     信任度：绝对        有效性：绝对
ssb  rsa2048/A86AB46BDC677F8F
     创建于：2020-04-02  有效至：永不       可用于：E
[ 绝对 ] (1). naive (too young too simple) &lt;naive@test.com&gt;

gpg&gt;
</code></pre></div><h2 id="使用-gpg-签名-git-commit">使用 GPG 签名 Git Commit</h2>
<p>这就是我使用 GPG 的原因，下面开始配置，首先配置 git</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 设置全局默认密钥</span>
git config --global user.signingkey &lt;密钥ID&gt;

<span class="c1"># 设置强制使用GPG签名</span>
git config --global commit.gpgsign <span class="nb">true</span>
</code></pre></div><p>之后在提交时，只需要带上<code>-S</code>参数，就能对提交进行签名</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git commit -S -m <span class="s2">&#34;xxx&#34;</span>
</code></pre></div><p>查看 git 日志时，带上<code>--show-signature</code>参数就能看到签名信息</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git log --show-signature
</code></pre></div><p>最后一步，需要把你的公钥提交到 github，否则它怎么知道这个签名是你的呢？将之前生成的文本类型的公钥<code>public_key.txt</code>提交到 <a href="https://github.com/settings/keys">github</a>，之后你的提交在 github 上就有像开头那样的绿色小勾了</p>
<h2 id="faq">FAQ</h2>
<h3 id="解决git提交时出现error-gpg-failed-to-sign-the-data">解决git提交时出现<code>error: gpg failed to sign the data</code></h3>
<p>以下是原始解决方案，虽然能解决问题，但体验不好，在 IDE 中提交时难以输入密码，建议 MacOS 用户采用上面说的 <code>GPG Suite</code>进行操作，它可以接管密码输入操作，弹出一个独立窗口用于输入，还能将密码添加到 iCloud 钥匙串中，避免重复输入密码。如果你已经在使用<code>GPG Suite</code>，但仍然遇到了这个问题，可以尝试重装<code>GPG Suite</code></p>
<ol>
<li>
<p>导出密钥（私钥）<strong>重要</strong></p>
</li>
<li>
<p>卸载 GPG</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">brew uninstall gnupg gnutls
   
brew cask uninstall gpg-suite
</code></pre></div></li>
<li>
<p>删除 gpg 文件夹，<strong>请确认已经导出密钥</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">rm -rf ~/.gnupg
</code></pre></div></li>
<li>
<p>重新安装<code>GPG Suite</code>，<strong>不需要手动安装 GPG</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">brew cask install gpg-suite
</code></pre></div></li>
<li>
<p>导入密钥</p>
</li>
</ol>
<p>这时 <code>GPG Suite</code>应该已经可以正常工作了</p>
<hr>
<p><em>原始方案</em></p>
<p>首先测试<code>gpg</code>工作是否正常</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">echo</span> <span class="s2">&#34;test&#34;</span> <span class="p">|</span> gpg --clearsign
</code></pre></div><p>如果出现下面的错误</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

test
gpg: 签名时失败： Inappropriate ioctl for device
gpg: [stdin]: clear-sign failed: Inappropriate ioctl for device
</code></pre></div><p>说明<code>gpg</code>无法打开输入密码的窗口。在生成<code>gpg key</code>时，如果指定了密码，在签名时就需要输入。而这时<code>gpg</code>不知道从哪里读取输入，所以可以用以下的命令指定<code>tty</code></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">export</span> <span class="nv">GPG_TTY</span><span class="o">=</span><span class="k">$(</span>tty<span class="k">)</span> 
</code></pre></div><p>这样就可以正常弹出输入密码的窗口。</p>
<hr>
<p>但我不喜欢这个全屏窗口，主要是在mac上<code>gpg</code>语言为中文时，这个窗口会乱码，所以用另一个方法解决。编辑<code>~/.gnupg/gpg.conf</code>，添加以下内容</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">use-agent 
pinentry-mode loopback
</code></pre></div><p>再编辑<code>~/.gnupg/gpg-agent.conf</code>，添加以下内容</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">allow-loopback-pinentry
</code></pre></div><p>最后输入<code>echo RELOADAGENT | gpg-connect-agent</code>重启<code>agent</code>就生效了，这样可以直接在终端输入密码</p>
<blockquote>
<p><a href="https://d.sb/2016/11/gpg-inappropriate-ioctl-for-device-errors">source</a></p>
</blockquote>]]></content>
        <author>
            <name><![CDATA[Creedowl’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.creedowl.com/posts/renew/</id>
        <title><![CDATA[重新开始]]></title>
        <updated>2020-03-19T13:28:13+08:00</updated>
        <link href="https://blog.creedowl.com/posts/renew/"/>
        <content type="text/html" src="https://blog.creedowl.com/posts/renew/"><![CDATA[<p>突然发现距上一篇blog发布已经过去了快一年的时间，原先的blog也疏于打理，只有寥寥几篇文章，图床基本失效。主要因为我比较懒，认真整理一篇blog也是费时费力的事情。但自己整理一些文章是很有意义的事情，能记录下自己的学习历程，总结知识，再次遇到相同的问题也可以回头参考。</p>
<p>blog一直没更新有个诱因是微博图床开启了防盗链，导致blog中许多图片都无法访问了<del>老王背锅</del>，又懒得修复。同时看上了<a href="https://gohugo.io/">hugo</a>这个框架，正好也在学习<code>golang</code>，就想从<code>hexo</code>更换到<code>hugo</code>。但这两个框架有个很大的区别<del>我觉得</del>，就是<code>hexo</code>是一堆前端工程师搞的，而<code>hugo</code>是一堆后端工程师搞的，这就导致了<code>hugo</code>没有啥好看的主题，也就一直鸽下去了。</p>
<p>去年年中的时候就打算和@queensferry写一个Hugo主题<a href="https://github.com/queensferryme/hugo-theme-verse">verse</a>，立项的时候很多想法，但做起来就不想动了。摸完页面框架后就鸽了，一方面实在不会设计，另一方面调各种样式是真的蛋疼。鸽了半年又捡起来<del>虽然我没写啥</del>，不过渐渐也有点样子了。但今天发现了一个很棒的主题<a href="https://github.com/Track3/hermit">hermit</a>，几乎就是我想要的，里面很多设计就是我当初构想的内容，马上捡起了blog。</p>
<p>这一年来也计划整理个人笔记软件，在尝试了数个软件后，有印象笔记，为知笔记，有道云笔记，onenote及一堆开源笔记应用，都不太满足我的需求。最后发现了notion这个东西贼香（主要对学生免费了），最后就选择了它。不过这也导致我手上一堆笔记分散在各处，打算后面整理清楚<del>水</del>几篇blog出来。</p>]]></content>
        <author>
            <name><![CDATA[Creedowl’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.noisyfox.io/moe-native-types.html</id>
        <title><![CDATA[Working with native types: Advanced]]></title>
        <updated>2019-09-22T05:23:17+08:00</updated>
        <link href="https://www.noisyfox.io/moe-native-types.html"/>
        <content type="text/html" src="https://www.noisyfox.io/moe-native-types.html"><![CDATA[<p>After using MOE for several years we discovered some common problems when dealing with native types (Core Foundation Types &amp; Cocoa Types). Here are some of our findings.</p>



<h1>Container Types (NSArray, NSDictionary, CFArrayRef, etc.)</h1>



<ol><li>The content in those containers must be corresponding native types, e.g., values of a <code>NSArray</code> must all be <code>NSObject</code>s, while values of a <code>CFArrayRef</code> must all be <code>OpaquePtr</code>s.<ol><li>NatJ does not automatically convert Java-only types (include primitive types) to compatible native types and vice versa when dealing with containers. When adding values to those containers you need to manually convert it to a corresponding native type. And when reading the value you also need to explicitly convert it to a Java type.</li><li>If you try to store a <strong>Core Foundation</strong> type in a <strong>Cocoa</strong> container, you need to cast it using the <strong>Toll-Free Bridging</strong> which I will talk about later.</li></ol></li><li>Arrays and dictionaries can not have <code>null</code> as either key or value.</li></ol>



<p>If you ever used the iOS <strong>KeyChain</strong> APIs you may did something similar as follows in Objective-C(simplified):</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">CFErrorRef error = NULL;

SecAccessControlRef access =
SecAccessControlCreateWithFlags(kCFAllocatorDefault,
                                kSecAttrAccessibleWhenUnlockedThisDeviceOnly,
                                kSecAccessControlPrivateKeyUsage|kSecAccessControlUserPresence,
                                &amp;error);

NSData* tag = [@"some tag" dataUsingEncoding:NSUTF8StringEncoding];

NSDictionary* attributes =
@{ (id)kSecClass:                   (id)kSecClassKey,
   (id)kSecAttrKeyType:             (id)kSecAttrKeyTypeECSECPrimeRandom,
   (id)kSecAttrKeySizeInBits:       @256,
   (id)kSecAttrTokenID:             (id)kSecAttrTokenIDSecureEnclave,
   (id)kSecPrivateKeyAttrs:
       @{ (id)kSecAttrIsPermanent:    @YES,
          (id)kSecAttrApplicationTag:  tag,
          (id)kSecAttrAccessControl:  (__bridge id)access
        },
   };

SecKeyRef privateKey = SecKeyCreateRandomKey((__bridge CFDictionaryRef)attributes,
                                             &amp;error);</pre>



<p>The corresponding Kotlin code will be:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">val pError = PtrFactory.newOpaquePtrReference(CFErrorRef::class.java)

val access = Security.SecAccessControlCreateWithFlags(
    CoreFoundation.CFAllocatorGetDefault(),
    Security.kSecAttrAccessibleWhenUnlockedThisDeviceOnly(),
    SecAccessControlCreateFlags.PrivateKeyUsage or SecAccessControlCreateFlags.UserPresence,
    pError
)
val tag = NSString.stringWithString("some tag").dataUsingEncoding(NSUTF8StringEncoding)

// Helper function to convert a CF type to Cocoa type
fun OpaquePtr.toNSObject() = ObjCRuntime.cast(this, NSObject::class.java)

val privateKeyAttrs = NSMutableDictionary.dictionary&lt;Any, Any>() as NSMutableDictionary&lt;Any, Any>
privateKeyAttrs[Security.kSecAttrIsPermanent().toNSObject()] = NSNumber.numberWithBool(true) // Convert Java `boolean` to Cocoa type
privateKeyAttrs[Security.kSecAttrApplicationTag().toNSObject()] = tag
privateKeyAttrs[Security.kSecAttrAccessControl().toNSObject()] = access.toNSObject()

val attributes = NSMutableDictionary.dictionary&lt;Any, Any>() as NSMutableDictionary&lt;Any, Any>
attributes[Security.kSecClass().toNSObject()] = Security.kSecClassKey().toNSObject()
attributes[Security.kSecAttrKeyType().toNSObject()] = Security.kSecAttrKeyTypeECSECPrimeRandom().toNSObject()
attributes[Security.kSecAttrKeySizeInBits().toNSObject()] = NSNumber.numberWithInt(256) // Convert Java `int` to Cocoa type
attributes[Security.kSecAttrTokenID().toNSObject()] = Security.kSecAttrTokenIDSecureEnclave().toNSObject()
attributes[Security.kSecPrivateKeyAttrs().toNSObject()] = privateKeyAttrs

// Cast NSDictionary to CFDictionaryRef
val cfAttributes = ObjCRuntime.cast(attributes, CFDictionaryRef::class.java)

val privateKey = Security.SecKeyCreateRandomKey(cfAttributes, pError)</pre>



<p>With the help of <a href="https://github.com/Noisyfox/NatJ-Kotlin">this library</a> I created, the code can be simplified as:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">val pError = PtrFactory.newOpaquePtrReference(CFErrorRef::class.java)

val access = Security.SecAccessControlCreateWithFlags(
    CoreFoundation.CFAllocatorGetDefault(),
    Security.kSecAttrAccessibleWhenUnlockedThisDeviceOnly(),
    SecAccessControlCreateFlags.PrivateKeyUsage or SecAccessControlCreateFlags.UserPresence,
    pError
)

val attributes = mapOf&lt;Any,Any>(
    Security.kSecClass() to Security.kSecClassKey(),
    Security.kSecAttrKeyType() to Security.kSecAttrKeyTypeECSECPrimeRandom(),
    Security.kSecAttrKeySizeInBits() to 256,
    Security.kSecAttrTokenID() to Security.kSecAttrTokenIDSecureEnclave(),
    Security.kSecPrivateKeyAttrs() to mapOf&lt;Any,Any>(
        Security.kSecAttrIsPermanent() to true,
        Security.kSecAttrApplicationTag() to "some tag".toNSData(),
        Security.kSecAttrAccessControl() to access
    )
).toNSDictionary()

val privateKey = Security.SecKeyCreateRandomKey(attributes.bridge(), pError)</pre>



<p>This library also has a help function for creating <code>NSArray</code> from a Java <code>Collection</code>:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">val nsArray = listOf(1, 2, 3, "some string", someCFRef, someNSType).toNSArray()</pre>



<h1>Toll-Free Bridging &amp; Memory Management</h1>



<p>iOS developers are most likely to be familiar with&nbsp;<strong>Cocoa Touch</strong>&nbsp;frameworks/APIs (does&nbsp;<strong>Foundation</strong>&nbsp;framework sound familiar to you?), which use the programming languages&nbsp;<strong>Objective-C</strong>&nbsp;or&nbsp;<strong>Swift</strong>. </p>



<p>However, you may also heard about another framework called&nbsp;<strong>Core Foundation</strong>.&nbsp;It is a pure&nbsp;<strong>C</strong>&nbsp;framework and provides access to lower level APIs and types.</p>



<p>For iOS development, most frameworks you will use are all designed based on the&nbsp;<strong>Foundation</strong>&nbsp;framework which means the types they use are all&nbsp;<code>NSObject</code>s so&nbsp;<strong>ARC</strong>&nbsp;manages the memory for you and the memory will be automatically released when the object is no longer used.&nbsp;<strong>MOE</strong> does some tricks so&nbsp;<strong>Java</strong>&#8216;s&nbsp;<strong>GC</strong>&nbsp;also helps when you use those types on&nbsp;<strong>Java</strong>&nbsp;side.</p>



<p>However some low level functions (such as&nbsp;<strong>Security</strong>&nbsp;framework if you try to use&nbsp;<strong>TouchId</strong>) are available in only&nbsp;<strong>C</strong>&nbsp;functions. Hens they use&nbsp;<strong>Core Foundation</strong>&nbsp;types which does not have&nbsp;<strong>ARC</strong>&nbsp;and requires manual memory management. Sadly&nbsp;<strong>Java</strong>&#8216;s&nbsp;<strong>GC</strong>&nbsp;does no help here (and may even create new issues which I will talk about later).</p>



<h2 id="ownership-cfretain-and-cfrelease">Ownership, CFRetain() and CFRelease()</h2>



<p>Anyone has any&nbsp;<strong>C</strong>&nbsp;experience might still remember those good old days struggling with&nbsp;<code>malloc()</code>&nbsp;and&nbsp;<code>free()</code>&nbsp;while&nbsp;<strong>Core Foundation</strong>&nbsp;brings you&nbsp;<code>CFRetain()</code>&nbsp;and&nbsp;<code>CFRelease()</code>.</p>



<p>Apple has a fantastic document that tells you how&nbsp;<em>Ownership</em>&nbsp;works in manual memory management and when you should use&nbsp;<code>CFRetain()</code>and&nbsp;<code>CFRelease()</code>&nbsp;respectively. I highly recommend you to read it first:</p>



<p>Link:&nbsp;<a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html">Memory Management Programming Guide for Core Foundation &#8211; Ownership Policy</a></p>



<p>Basically if an Core Foundation object is owned by you, you need to call&nbsp;<code>CFRelease()</code>&nbsp;once you are done with it; if it&#8217;s NOT owned by you, in most cases, you need to&nbsp;<code>CFRetain()</code>&nbsp;it, use it, then&nbsp;<code>CFRelease()</code>&nbsp;it afterwards:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="c" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// Create a CFString, which is owned by you
CFStringRef urlStr = CFStringCreateWithCString(kCFAllocatorDefault,
    "https://www.noisyfox.io", kCFStringEncodingUTF8);

/* Do something with urlStr here. */

// Release it afterwards
CFRelease(urlStr);
</pre>



<pre class="EnlighterJSRAW" data-enlighter-language="c" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">// Get something from a dict, which is not owned, so a CFRetain() is required
CFStringRef title = (CFStringRef)CFRetain(CFDictionaryGetValue(dict, CFSTR("title")));

/* Do something with title here. */

// Release it afterwards
CFRelease(urlStr);
</pre>



<p>You can easily convert above code to&nbsp;<strong>Java</strong>&nbsp;since MOE bindings provide all necessary functions. And with a little help from my library, you could write something like these in&nbsp;<strong>Kotlin</strong>:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">CFStringCreateWithCString(kCFAllocatorDefault(), "title", CFStringBuiltInEncodings.UTF8).use { key ->

    CFDictionaryGetValue(dict, key).cast&lt;CFStringRef>().retain().use { title ->
        /* Do something with title here. */
    }
}
// CFRelease is automatically called when block returns
</pre>



<p>The&nbsp;<code>action</code>&nbsp;block of&nbsp;<code>.use()</code>&nbsp;is wrapped in a&nbsp;<code>try</code>&nbsp;block so the resource is guaranteed to be released even if&nbsp;<strong>Exception</strong>&nbsp;is raised in the block.</p>



<h2 id="autoreleasepool-for-core-foundation-types"><code>autoreleasepool</code>&nbsp;for&nbsp;<strong>Core Foundation</strong>&nbsp;types</h2>



<p><code>.use()</code>&nbsp;mentioned above will create a lot of nested scopes if you have a lot of those&nbsp;<strong>Core Foundation</strong>&nbsp;objects. That makes the code unreadable. With the help of&nbsp;<code>autoreleasepool</code>&nbsp;you could rewrite the above code to something like this:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">autoreleasepool {
    val key = CFStringCreateWithCString(kCFAllocatorDefault(), "title", CFStringBuiltInEncodings.UTF8).autorelease()
    val title = CFDictionaryGetValue(dict, key).cast&lt;CFStringRef>().retain().autorelease()

    /* Do something with title here. */
}
// CFRelease is automatically called for each object that called .autorelease() when autoreleasepool block ends
</pre>



<p><strong>NB</strong>: Make sure the&nbsp;<code>autoreleasepool</code>&nbsp;you called is imported from package&nbsp;<code>io.noisyfox.moe.natj</code>&nbsp;since&nbsp;<strong>NatJ</strong>&nbsp;has it&#8217;s own impl&nbsp;<code>org.moe.natj.objc.ObjCRuntime#autoreleasepool(java.lang.Runnable)</code>&nbsp;which is not a&nbsp;<strong>Kotlin</strong>&nbsp;<code>inline</code>&nbsp;function which doesn&#8217;t support certain features (such as&nbsp;<a href="https://kotlinlang.org/docs/reference/inline-functions.html#non-local-returns">non-local returns</a>&nbsp;and&nbsp;<a href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters">reified type parameters</a>).</p>



<h2 id="type-bridging">Type Bridging</h2>



<p>WIP</p>



<h1>Misc</h1>



<p>The library also contains some other help functions for converting between Java types and native types such as <code>ByteArray</code> &lt;=&gt; <code>NSData</code>. I won&#8217;t list all functions here since you could easily find them in source code.</p>



<h1>The library &#8211; <strong><a href="https://github.com/Noisyfox/NatJ-Kotlin">NatJ-Kotlin</a></strong></h1>



<p>This is a library I created that contains some helper functions I used in my work. It&#8217;s currently available in only source code form. I will create a jar release and publish it to jcenter ASAP.</p>



<p>The library is written in Kotlin but most of the functions can also be used in Java.</p>



<h1>Discussion</h1>



<p>Any idea of  library improving are welcomed. If you found any mistake in my post, or have any other problem that is not covered, please not hesitate to share with us by leaving comments.</p>
<p><a rel="nofollow" href="https://www.noisyfox.io/moe-native-types.html">Working with native types: Advanced</a>，首发于<a rel="nofollow" href="https://www.noisyfox.io">狐狸的小小窝</a>。</p>]]></content>
        <author>
            <name><![CDATA[狐狸的小小窝]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.creedowl.com/posts/vue-demo-instruction/</id>
        <title><![CDATA[Vue.js 从入坑到入土]]></title>
        <updated>2019-04-23T13:25:25+08:00</updated>
        <link href="https://blog.creedowl.com/posts/vue-demo-instruction/"/>
        <content type="text/html" src="https://blog.creedowl.com/posts/vue-demo-instruction/"><![CDATA[<h1 id="vuejs-从入坑到入土">Vue.js 从入坑到入土</h1>
<p>近年来前端领域发展飞速，从最早的直接写html, js, css 到使用jQuery快速开发，再到近年来使用Vuejs，Reactjs 实现工程化开发，也就短短十几年。虽然前端项目结构越来越复杂，但也越来越规范，清晰，更加工程化。当前较为流行的前端框架有Vuejs、Reactjs、Angularjs 等，而Vuejs由于其灵(zhong)活(wen)轻(wen)便(dang)，较为流行。虽然Vuejs有完善的中文文档，但文档主要在介绍其用法，缺少如何实现一个完整项目的指导，本文就介绍如何用Vuejs创建一个完整的前端项目，并与后端进行交互。</p>
<p><strong>本文基于<a href="mailto:Vuejs@2.x">Vuejs@2.x</a>及<a href="mailto:VueCLI@3.x">VueCLI@3.x</a></strong></p>
<ol>
<li>所需技术栈：html, javascript, css基础知识，其中js建议了解<strong>ES2015</strong>标准，特别要掌握<strong>promise</strong>的使用</li>
<li>使用的工具：<del>宇宙第一编辑器</del> VSCode —— 现在对vue项目的支持已经很好了，可以自动安装vue项目需要的插件</li>
</ol>
<h1 id="0x0-安装">0x0 安装</h1>
<blockquote>
<p>推荐使用<a href="https://yarnpkg.com/lang/zh-hans">yarn</a>代替npm作为包管理器</p>
</blockquote>
<h2 id="安装vuecli">安装VueCLI</h2>
<blockquote>
<p>VueCLI是Vuejs官方推出的项目脚手架工具，可以方便的创建、管理Vue项目，还提供优雅的web管理界面</p>
</blockquote>
<p>全局安装<a href="https://cli.vuejs.org/zh/">VueCLI</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">yarn global add @vue/cli
</code></pre></div><h2 id="安装vue-devtools">安装Vue-devtools</h2>
<blockquote>
<p><a href="https://github.com/vuejs/vue-devtools">Vue-devtools</a> 是vue官方的浏览器开发插件，可以方便的在浏览器中调试vue应用</p>
</blockquote>
<p>Vue-devtools 提供多平台的浏览器插件可以直接安装使用</p>
<p><a href="https://github.com/vuejs/vue-devtools#installation">installation</a></p>
<h1 id="0x1-新建项目">0x1 新建项目</h1>
<p>使用 <code>vue create vue_demo</code> 创建新项目，接下来会出现一个交互式命令行帮你配置项目。</p>
<p><strong>注意此处不要使用默认的配置！具体配置参考下图</strong></p>
<blockquote>
<p>坑x1 默认的配置十分简单，新手经常不知道怎么写多页面，弄不明白项目怎么组织的，所以需要自定义配置，添加vue-router插件实现多页面跳转</p>
</blockquote>
<p><a href="https://asciinema.org/a/240155"><img src="https://asciinema.org/a/240155.svg" alt="asciicast"></a></p>
<h1 id="0x2-项目框架">0x2 项目框架</h1>
<p>此时项目已经创建成功，如果你按照提示启动项目就能看到经典的vue启动页</p>
<p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1g1yg2r5ysxj30up0mx3zv.jpg" alt="image"></p>
<p>当前的项目结构如下</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">.                     项目根目录
├── README.md 
├── babel.config.js
├── package.json      项目主配置文件
├── public            公共资源文件夹
│   ├── favicon.ico
│   └── index.html    入口html
├── src               源码根目录
│   ├── App.vue       入口文件
│   ├── assets        资源文件夹
│   │   └── logo.png
│   ├── components    组件文件夹
│   │   └── HelloWorld.vue 
│   ├── main.js       入口配置文件
│   ├── router.js     路由文件
│   ├── store.js      状态管理
│   └── views         页面文件夹
│       ├── About.vue
│       └── Home.vue
└── yarn.lock         依赖文件
</code></pre></div><p>在下面的章节具体介绍各个文件、文件夹的用处和如何组织项目。</p>
<h1 id="0x3-项目结构">0x3 项目结构</h1>
<p>用vue开发的项目一般是<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8">SPA(单页应用)</a>，通过动态重写当前页面来与用户交互，而不会重新加载整个新页面。所以要组织多页面就要通过vue-router来组织页面，而vuex用来保存状态。</p>
<p>作为单页应用，当然需要一个入口html文件，也就是 <code>public/index.html</code> :</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html">public/index.html

<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;utf-8&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&#34;X-UA-Compatible&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;IE=edge&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width,initial-scale=1.0&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;icon&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;&lt;%= BASE_URL %&gt;favicon.ico&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>vue_demo<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">noscript</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">strong</span><span class="p">&gt;</span>We&#39;re sorry but vue_demo doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.<span class="p">&lt;/</span><span class="nt">strong</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">noscript</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;app&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="c">&lt;!-- built files will be auto injected --&gt;</span>
  <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><p>这是默认生成的 <code>index.html</code> ，而编译好的文件（网页内容）会被自动注入到 `` 中，也就意味着要使用vue开发的应用，浏览器必须支持js。</p>
<p>而#app所绑定的vue实例，则位于 <code>src/main.js</code></p>
<hr>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">src</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="nx">js</span>

<span class="kr">import</span> <span class="nx">Vue</span> <span class="nx">from</span> <span class="s1">&#39;vue&#39;</span>
<span class="kr">import</span> <span class="nx">App</span> <span class="nx">from</span> <span class="s1">&#39;./App.vue&#39;</span>
<span class="kr">import</span> <span class="nx">router</span> <span class="nx">from</span> <span class="s1">&#39;./router&#39;</span>
<span class="kr">import</span> <span class="nx">store</span> <span class="nx">from</span> <span class="s1">&#39;./store&#39;</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">productionTip</span> <span class="o">=</span> <span class="kc">false</span>
<span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
  <span class="nx">router</span><span class="p">,</span> <span class="c1">// 使用vue-router插件
</span><span class="c1"></span>  <span class="nx">store</span><span class="p">,</span> <span class="c1">// 使用vuex插件
</span><span class="c1"></span>  <span class="nx">render</span><span class="o">:</span> <span class="nx">h</span> <span class="p">=&gt;</span> <span class="nx">h</span><span class="p">(</span><span class="nx">App</span><span class="p">)</span> <span class="c1">// 渲染页面
</span><span class="c1"></span><span class="p">}).</span><span class="nx">$mount</span><span class="p">(</span><span class="s1">&#39;#app&#39;</span><span class="p">)</span> <span class="c1">// 绑定到 index.html -&gt; div#app
</span></code></pre></div><p>其中渲染的页面位于 <code>src/App.vue</code></p>
<hr>
<blockquote>
<p>xxx.vue 是vue中的<a href="https://cn.vuejs.org/v2/guide/single-file-components.html">单文件组件</a>，将 <code>html css javascript</code> 集合在同一个文件，便于组织管理</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html">src/App.vue

<span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;app&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;nav&#34;</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">router-link</span> <span class="na">to</span><span class="o">=</span><span class="s">&#34;/&#34;</span><span class="p">&gt;</span>Home<span class="p">&lt;/</span><span class="nt">router-link</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">router-link</span> <span class="na">to</span><span class="o">=</span><span class="s">&#34;/about&#34;</span><span class="p">&gt;</span>About<span class="p">&lt;/</span><span class="nt">router-link</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">router-view</span><span class="p">/&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">style</span><span class="p">&gt;</span>
<span class="p">#</span><span class="nn">app</span> <span class="p">{</span>
  <span class="k">font-family</span><span class="p">:</span> <span class="s1">&#39;Avenir&#39;</span><span class="p">,</span> <span class="n">Helvetica</span><span class="p">,</span> <span class="n">Arial</span><span class="p">,</span> <span class="kc">sans-serif</span><span class="p">;</span>
  <span class="kp">-webkit-</span><span class="n">font-smoothing</span><span class="p">:</span> <span class="n">antialiased</span><span class="p">;</span>
  <span class="kp">-moz-</span><span class="n">osx-font-smoothing</span><span class="p">:</span> <span class="n">grayscale</span><span class="p">;</span>
  <span class="k">text-align</span><span class="p">:</span> <span class="kc">center</span><span class="p">;</span>
  <span class="k">color</span><span class="p">:</span> <span class="mh">#2c3e50</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">#</span><span class="nn">nav</span> <span class="p">{</span>
  <span class="k">padding</span><span class="p">:</span> <span class="mi">30</span><span class="kt">px</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">#</span><span class="nn">nav</span> <span class="nt">a</span> <span class="p">{</span>
  <span class="k">font-weight</span><span class="p">:</span> <span class="kc">bold</span><span class="p">;</span>
  <span class="k">color</span><span class="p">:</span> <span class="mh">#2c3e50</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">#</span><span class="nn">nav</span> <span class="nt">a</span><span class="p">.</span><span class="nc">router-link-exact-active</span> <span class="p">{</span>
  <span class="k">color</span><span class="p">:</span> <span class="mh">#42b983</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span>
</code></pre></div><p>其中 <code>是页面的 `html` 元素，`style` 是样式元素，还可以添加一个 `javascript` 为js元素。其中</code> 是路由组件，会被自动渲染成当前路由对应的页面</p>
<hr>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">src</span><span class="o">/</span><span class="nx">router</span><span class="p">.</span><span class="nx">js</span>

<span class="kr">import</span> <span class="nx">Vue</span> <span class="nx">from</span> <span class="s1">&#39;vue&#39;</span>
<span class="kr">import</span> <span class="nx">Router</span> <span class="nx">from</span> <span class="s1">&#39;vue-router&#39;</span>
<span class="kr">import</span> <span class="nx">Home</span> <span class="nx">from</span> <span class="s1">&#39;./views/Home.vue&#39;</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">Router</span><span class="p">)</span>
<span class="kr">export</span> <span class="k">default</span> <span class="k">new</span> <span class="nx">Router</span><span class="p">({</span>
  <span class="nx">mode</span><span class="o">:</span> <span class="s1">&#39;history&#39;</span><span class="p">,</span>
  <span class="nx">base</span><span class="o">:</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">BASE_URL</span><span class="p">,</span>
  <span class="nx">routes</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span>
      <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;home&#39;</span><span class="p">,</span>
      <span class="nx">component</span><span class="o">:</span> <span class="nx">Home</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/about&#39;</span><span class="p">,</span>
      <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;about&#39;</span><span class="p">,</span>
      <span class="c1">// route level code-splitting
</span><span class="c1"></span>      <span class="c1">// this generates a separate chunk (about.[hash].js) for this route
</span><span class="c1"></span>      <span class="c1">// which is lazy-loaded when the route is visited.
</span><span class="c1"></span>      <span class="nx">component</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="kr">import</span><span class="p">(</span><span class="cm">/* webpackChunkName: &#34;about&#34; */</span> <span class="s1">&#39;./views/About.vue&#39;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">})</span>
</code></pre></div><p>如 <code>http://localhost:8080/</code> 下 <code>被渲染成 `home` 页面，`http://localhost:8080/about` 下</code> 被渲染成 <code>about</code> 页面。</p>
<blockquote>
<p>技巧 这里加载组件使用函数加载，就可以实现懒加载以优化性能。</p>
</blockquote>
<hr>
<p><code>src/views/</code> 则是保存页面文件，例如</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html">src/views/Home.vue

<span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;home&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">img</span> <span class="na">alt</span><span class="o">=</span><span class="s">&#34;Vue logo&#34;</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;../assets/logo.png&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">HelloWorld</span> <span class="na">msg</span><span class="o">=</span><span class="s">&#34;Welcome to Your Vue.js App&#34;</span><span class="p">/&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="c1">// @ is an alias to /src
</span><span class="c1"></span><span class="kr">import</span> <span class="nx">HelloWorld</span> <span class="nx">from</span> <span class="s1">&#39;@/components/HelloWorld.vue&#39;</span>
<span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;home&#39;</span><span class="p">,</span>
  <span class="nx">components</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">HelloWorld</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div><p>这就是路由 <code>home</code> 对应的页面，其中用到了 <code>HelloWorld</code> 组件，需要在js中引入。</p>
<hr>
<p><code>src/components/</code> 里面保存可复用的组件，例如上面的 `` 就是一个独立的组件（component）</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html">src/components/HelloWorld.vue

<span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;hello&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>{{ msg }}<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>
      For a guide and recipes on how to configure / customize this project,<span class="p">&lt;</span><span class="nt">br</span><span class="p">&gt;</span>
      check out the
      <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://cli.vuejs.org&#34;</span> <span class="na">target</span><span class="o">=</span><span class="s">&#34;_blank&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;noopener&#34;</span><span class="p">&gt;</span>vue-cli documentation<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>.
    <span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;HelloWorld&#39;</span><span class="p">,</span>
  <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">msg</span><span class="o">:</span> <span class="nb">String</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="c">&lt;!-- Add &#34;scoped&#34; attribute to limit CSS to this component only --&gt;</span>
<span class="p">&lt;</span><span class="nt">style</span> <span class="na">scoped</span><span class="p">&gt;</span>
<span class="nt">h1</span> <span class="p">{</span>
  <span class="k">margin</span><span class="p">:</span> <span class="mi">40</span><span class="kt">px</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span>
</code></pre></div><p>这就是一个典型的组件，结构就是一个正常的单文本组件，说明组件就是把一部分页面逻辑抽出来组成一个文件。这样的好处是分离与页面无关的组件，使页面逻辑更加清晰，同时也便于复用组件。如果有以下情况，我建议把部分代码分离成独立的组件：</p>
<ol>
<li>需要多次复用的组件，如基础按钮、表单等</li>
<li>较为复杂但与页面逻辑无关的，如页面的Header、Footer等</li>
</ol>
<blockquote>
<p>技巧 在 <code>style</code> 表情上添加 <code>scoped</code> 属性可以限制CSS生效范围为该组件，不会影响其他元素，在编译时vue解释器会给这些css属性加上随机的hash保证唯一</p>
</blockquote>
<hr>
<p>vue还提供了一个状态管理模式 <a href="https://vuex.vuejs.org/zh/">vuex</a>，可以很方便的管理所有组件的状态。对应文件 <code>src/store.js</code></p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">src</span><span class="o">/</span><span class="nx">store</span><span class="p">.</span><span class="nx">js</span>

<span class="kr">import</span> <span class="nx">Vue</span> <span class="nx">from</span> <span class="s1">&#39;vue&#39;</span>
<span class="kr">import</span> <span class="nx">Vuex</span> <span class="nx">from</span> <span class="s1">&#39;vuex&#39;</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">Vuex</span><span class="p">)</span>
<span class="kr">export</span> <span class="k">default</span> <span class="k">new</span> <span class="nx">Vuex</span><span class="p">.</span><span class="nx">Store</span><span class="p">({</span>
  <span class="nx">state</span><span class="o">:</span> <span class="p">{</span>
  <span class="p">},</span>
  <span class="nx">mutations</span><span class="o">:</span> <span class="p">{</span>
  <span class="p">},</span>
  <span class="nx">actions</span><span class="o">:</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div><p><del>由于我还没用过 <code>vuex</code> 所以自己看文档吧</del></p>
<p>对于简单的应用也可以不用 <code>vuex</code> ，一个简单的 <a href="https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8"><code>store</code> 模式</a> 就足够了</p>
<h1 id="0x4-开发指引">0x4 开发指引</h1>
<p>有了上面的基础，我们就可以开始写代码了，这里以添加一个 <code>Foo</code> 页面展示从远端获得的数据为例</p>
<h2 id="1-给页面添加一个-tab">1. 给页面添加一个 <code>Tab</code></h2>
<p><code>Tab</code> 属于与页面逻辑无关，但又处处要使用的元素，所以我们将其独立成为一个组件</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html">src/components/Tab.vue

<span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;tab&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span> <span class="err">@</span><span class="na">click</span><span class="o">=</span><span class="s">&#34;router(&#39;/&#39;)&#34;</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>home<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span> <span class="err">@</span><span class="na">click</span><span class="o">=</span><span class="s">&#34;router(&#39;/about&#39;)&#34;</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>about<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;item&#34;</span> <span class="err">@</span><span class="na">click</span><span class="o">=</span><span class="s">&#34;router(&#39;/foo&#39;)&#34;</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>foo<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Tab&#39;</span><span class="p">,</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">router</span> <span class="p">(</span><span class="nx">url</span><span class="p">){</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">$router</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">style</span> <span class="na">scoped</span><span class="p">&gt;</span>
<span class="p">#</span><span class="nn">tab</span> <span class="p">{</span>
  <span class="k">display</span><span class="p">:</span> <span class="kc">flex</span><span class="p">;</span>
  <span class="k">justify-content</span><span class="p">:</span> <span class="kc">space</span><span class="o">-</span><span class="n">around</span><span class="p">;</span>
  <span class="k">align-items</span><span class="p">:</span> <span class="kc">center</span><span class="p">;</span>
  <span class="k">bottom</span><span class="p">:</span> <span class="mi">0</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">position</span><span class="p">:</span> <span class="kc">fixed</span><span class="p">;</span>
  <span class="k">height</span><span class="p">:</span> <span class="mi">65</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">left</span><span class="p">:</span> <span class="mi">0</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">width</span><span class="p">:</span> <span class="mi">100</span><span class="kt">%</span><span class="p">;</span>
  <span class="k">background-color</span><span class="p">:</span> <span class="kc">aquamarine</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">.</span><span class="nc">item</span> <span class="p">{</span>
  <span class="k">padding-top</span><span class="p">:</span> <span class="mi">5</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">display</span><span class="p">:</span> <span class="kc">flex</span><span class="p">;</span>
  <span class="k">flex-direction</span><span class="p">:</span> <span class="kc">column</span><span class="p">;</span>
  <span class="k">justify-content</span><span class="p">:</span> <span class="kc">center</span><span class="p">;</span>
  <span class="k">align-items</span><span class="p">:</span> <span class="kc">center</span><span class="p">;</span>
  <span class="k">height</span><span class="p">:</span> <span class="mi">50</span><span class="kt">px</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span>
</code></pre></div><p>在这里我们创建了一个底部导航栏，有三个 <code>Tab</code> ，并且对应跳转到不同的页面</p>
<h2 id="2-创建-foovue-相关逻辑并与后端交互">2. 创建 <code>Foo.vue</code> 相关逻辑并与后端交互</h2>
<p>因为我们需要从远端API获取数据并进行展示，就涉及网络请求。在vue中，官方推荐使用 <a href="https://github.com/axios/axios">axios</a> 发起请求。<code>axios</code> 是一个基于 <code>promise</code> 的异步网络请求库，相关用法可参考文档或网上教程</p>
<p>安装 <code>axios</code></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">yarn add axios
</code></pre></div><p>接着在 <code>src/main.js</code> 中加入以下语句启用 <code>axios</code></p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">Axios</span> <span class="nx">from</span> <span class="s1">&#39;axios&#39;</span>
<span class="c1">// 把axios添加到原型链
</span><span class="c1"></span><span class="nx">Vue</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">$axios</span> <span class="o">=</span> <span class="nx">Axios</span>
</code></pre></div><p>现在就可以在vue实例中用 <code>this.$router</code> 来访问路由了</p>
<hr>
<p>接着来创建 <code>Foo.vue</code></p>
<div class="highlight"><pre class="chroma"><code class="language-vue" data-lang="vue"><span class="nx">src</span><span class="o">/</span><span class="nx">views</span><span class="o">/</span><span class="nx">Foo</span><span class="p">.</span><span class="nx">vue</span>

<span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;foo&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;{{</span> <span class="nx">result</span> <span class="p">}}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">button</span> <span class="nt">@click</span><span class="s">=&#34;bar()&#34;</span><span class="p">&gt;</span><span class="na">bar</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Foo&#39;</span><span class="p">,</span>
  <span class="nx">data</span><span class="p">(){</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">result</span> <span class="o">:</span> <span class="s1">&#39;naive&#39;</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">bar</span><span class="p">(){</span>
      <span class="cm">/* eslint-disable */</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">result</span> <span class="o">=</span> <span class="s1">&#39;loading...&#39;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">$axios</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;http://httpbin.org/post&#39;</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">result</span> <span class="o">=</span> <span class="nx">res</span><span class="p">})</span>
        <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">res</span> <span class="p">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">res</span><span class="p">)})</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">style</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span>
</code></pre></div><p><del>具体实现代码里面很清楚了</del> 这个文件的作用就是请求 <code>http://httpbin.org/get</code> 并把结果显示在界面上</p>
<p><strong>注意前后端分离的项目会有<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">跨域(CORS)问题</a>，这个问题比较复杂，巨坑，网上也有较多解决的文章<del>咕咕咕</del></strong></p>
<h1 id="0x5-技巧及坑们">0x5 技巧及坑们</h1>
<p>这里介绍一些我写vue项目遇到的坑和使用的技巧</p>
<h2 id="data-methods-computed-props-的区别">data methods computed props 的区别</h2>
<p><del>TODO</del></p>
<p>vue中存储数据有几种方式——data、</p>
<h1 id="0x6-结语">0x6 结语</h1>
<p>到此，一个简单的vue项目就完成了，对于如何组织项目，前后端如何交互应该已经有了初步了解。本文也会持续更新，欢迎关注我的<a href="https://blog.creedowl.com/">blog</a></p>
<p>本文的实例请访问<a href="https://github.com/creedowl/vue_demo/">github</a></p>]]></content>
        <author>
            <name><![CDATA[Creedowl’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://blog.creedowl.com/posts/ipv6_and_nat6_in_nuaa/</id>
        <title><![CDATA[南航校园网OpenWRT配置IPv6 NAT6]]></title>
        <updated>2019-04-04T15:29:39+08:00</updated>
        <link href="https://blog.creedowl.com/posts/ipv6_and_nat6_in_nuaa/"/>
        <content type="text/html" src="https://blog.creedowl.com/posts/ipv6_and_nat6_in_nuaa/"><![CDATA[<blockquote>
<p>当前IPv6越来越流行，不但解决了IPv4地址不够用的问题，还能给接入的设备提供公网访问的支持。但由于校园网的特殊性，虽然很早就有了IPv6支持，大部分学校在IPv6地址分配上却有剧毒，无法向下游设备分配独立的IPv6地址（正常家庭网络环境中路由器及下游设备都能自动分配独立的公网IPv6地址），以南航为例，OpenWRT上虽然获取到了2001开头，/64结尾的公网IPv6地址，但下游设备却无IPv6访问权限。本文介绍南航校园网环境下如何在OpenWRT下获取IPv6并配置NAT6使下游设备拥有IPv6访问权限。</p>
</blockquote>
<h2 id="0软硬件需求">0：软硬件需求</h2>
<p><strong>硬件</strong>：支持OpenWRT固件的路由器或软路由（推荐使用软路由，性能更好，支持启用更多服务，且不需要考虑太多兼容性问题，x86版本OpenWRT一把梭）</p>
<p><strong>软件</strong>：较新版本的OpenWRT或其衍生版本（lede，pandorabox等，但原版OpenWRT最佳）</p>
<p><strong>OpenWRT内核需高于3.7</strong>， linux kernel在3.7版本开始支持NAT6</p>
<p><del>内核版本不够高且无法升级可以尝试早年由北邮大佬开发的NAT66项目，但不推荐</del></p>
<p>所需软件包：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">ip6tables kmod-ipt-nat6 kmod-ip6tables kmod-ip6tables-extra luci-proto-ipv6 iputils-traceroute6
</code></pre></div><p>较新版本已经自带IPv6支持，老版本需要自己安装相关软件包，但兼容性较差，或者内核版本不足，建议找较新版本或者自行编译。</p>
<h2 id="1openwrt配置获取ipv6">1：OpenWRT配置获取IPv6</h2>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/UTOOLS1588304901671.png/compress" alt="IPv6_setting_1"></p>
<h3 id="1-修改ipv6-ula前缀为fd开头默认为dd开头">1. 修改IPv6 ULA前缀为fd开头（默认为dd开头）</h3>
<h3 id="2-修改wan6口配置如下图所示">2. 修改wan6口配置（如下图所示）</h3>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/UTOOLS1588304939503.png/compress" alt="IPv6_setting_2"></p>
<h3 id="3-修改lan口dhcp服务器配置如下图所示">3. 修改lan口DHCP服务器配置（如下图所示）</h3>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/UTOOLS1588304973656.png/compress" alt="IPv6_setting_3"></p>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/UTOOLS1588304997028.png/compress" alt="IPv6_setting_4"></p>
<p>此时稍等片刻，在概况中应该就能看到获取到的IPv6地址及下游设备DHCPv6分配内网IPv6地址</p>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/UTOOLS1588305013341.png/compress" alt="IPv6_setting_5"></p>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/UTOOLS1588305030637.png/compress" alt="IPv6_setting_6"></p>
<p>现在你的路由器已经可以使用IPv6了，但下游设备并不行，就需要配置NAT6。</p>
<h2 id="2配置nat6">2：配置NAT6</h2>
<p>虽然NAT6并不符合IPv6的设计哲学，但却能解决一些问题，如安全隔离，或者像我们这样通过单一地址转发给多个设备使用。</p>
<h3 id="1-修改防火墙">1. 修改防火墙</h3>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/UTOOLS1588305046715.png/compress" alt="IPv6_setting_7"></p>
<p>加入以下自定义规则</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">WAN6</span><span class="o">=</span>pppoe-wan
<span class="nv">LAN</span><span class="o">=</span>br-lan
ip6tables -t nat -A POSTROUTING -o <span class="nv">$WAN6</span> -j MASQUERADE
ip6tables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
ip6tables -A FORWARD -i <span class="nv">$LAN</span> -j ACCEPT
</code></pre></div><p><strong>注意这里WAN6和LAN要改为外网IPv6和内网网卡名字，在终端使用ifconfig查看</strong></p>
<p><img src="https://blog-1251984664.cos.ap-shanghai.myqcloud.com/UTOOLS1588305068355.png/compress" alt="IPv6_setting_8"></p>
<h3 id="2-配置网关">2. 配置网关</h3>
<p>在终端执行 <code>ip -6 r</code> 查看默认网关（default开头），如果是类似</p>
<p><code>default from 2001:xxxx:xxxx:xxxx::/64 via fe80::ded2:fcff:fe98:64f7 dev pppoe-wan proto static metric 512 pref medium</code></p>
<p>这样蛋疼的网关，需要去掉<code>from 2001:xxxx:xxxx:xxxx::/64</code> 这段再添加默认网关，例如</p>
<p><code>ip -6 route add default via fe80::ded2:fcff:fe98:64f7 dev pppoe-wan proto static metric 512</code></p>
<p>可以建立一个<code>/etc/hotplug.d/iface/99-ipv6</code>实现自动配置</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="cp">#!/bin/sh
</span><span class="cp"></span><span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$ACTION</span><span class="s2">&#34;</span> <span class="o">=</span> ifup <span class="o">]</span> <span class="o">||</span> <span class="nb">exit</span> <span class="m">0</span>
<span class="nv">iface</span><span class="o">=</span>wan6
<span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$iface</span><span class="s2">&#34;</span> -o <span class="s2">&#34;</span><span class="nv">$INTERFACE</span><span class="s2">&#34;</span> <span class="o">=</span> <span class="s2">&#34;</span><span class="nv">$iface</span><span class="s2">&#34;</span> <span class="o">]</span> <span class="o">||</span> <span class="nb">exit</span> <span class="m">0</span>
ip -6 route add <span class="sb">`</span>ip -6 route show default<span class="p">|</span>sed -e <span class="s1">&#39;s/from [^ ]* //&#39;</span><span class="sb">`</span>
logger -t IPv6 <span class="s2">&#34;Add IPv6 default route.&#34;</span>
</code></pre></div><p>最后别忘了修改权限</p>
<p><code>chmod +x /etc/hotplug.d/iface/99-ipv6</code></p>
<p>重启路由器就可以愉快的玩耍了。</p>
<p><del>本来还想折腾IPv6端口转发，但一直无法配置成功。后来突然发现南航校园网下没有对IPv4做严格隔离（除了80端口基本上都能直接访问），就直接做IPv4端口转发配合DDNS，连接校园WIFI（nuaa.portal，<strong>付费版本</strong>）就可以直接使用，速度还挺快。。。就真香了。。不过配置IPv6端口转发还是有意义，比如可以从非校园网访问，校园网访问IPv6无需认证（不要充钱了），相关教程有空再补上（咕咕咕）有需求可以参考<a href="https://shura.eu.org/2018/12/06/ipv6-NAT%E5%90%8E%E9%85%8D%E7%BD%AE%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/">ipv6 NAT后配置端口转发</a></del></p>
<h2 id="参考资料">参考资料</h2>
<blockquote>
<p><a href="https://github.com/tuna/ipv6.tsinghua.edu.cn/blob/master/openwrt.md">清华OpenWRT 路由器作为 IPv6 网关的配置</a></p>
</blockquote>]]></content>
        <author>
            <name><![CDATA[Creedowl’s Blog]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://doublemice.github.io/linux%E5%86%85%E6%A0%B8gdb+qemu%E8%B0%83%E8%AF%95/</id>
        <title><![CDATA[Linux内核gdb+qemu调试]]></title>
        <updated>2019-01-28T00:00:00+08:00</updated>
        <link href="https://doublemice.github.io/linux%E5%86%85%E6%A0%B8gdb+qemu%E8%B0%83%E8%AF%95/"/>
        <content type="text/html" src="https://doublemice.github.io/linux%E5%86%85%E6%A0%B8gdb+qemu%E8%B0%83%E8%AF%95/"><![CDATA[Linux内核gdb+qemu调试]]></content>
        <author>
            <name><![CDATA[DoubleMice]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.noisyfox.io/foxwinshave2.html</id>
        <title><![CDATA[FoxWinShave 2 中文使用手册]]></title>
        <updated>2019-01-12T08:45:27+08:00</updated>
        <link href="https://www.noisyfox.io/foxwinshave2.html"/>
        <content type="text/html" src="https://www.noisyfox.io/foxwinshave2.html"><![CDATA[<p>FoxWinShave 2 现已上架 GameMaker: Marketplace，支持 GM8, GMS 1.4 和 GMS 2。<a href="https://marketplace.yoyogames.com/assets/7696/foxwinshave" target="_blank" rel="noreferrer noopener" aria-label="（在新窗口打开）">点此从Marketplace下载最新版本</a>。</p>



<hr class="wp-block-separator"/>



<h2>0. 前置条件</h2>



<ul><li>仅支持 Windows 平台。</li><li>支持 Windows XP, Windows Vista, Windows 7, Windows 8, Windows 8.1, Windows 10。</li><li>支持 GameMaker 7, GameMaker 8, GameMaker 8.1, GameMaker Studio 1.4.x, GameMaker Studio 2 Desktop。</li></ul>



<hr class="wp-block-separator"/>



<h2>1. 安装插件</h2>



<h3>1.0 GM 7, 8, 8.1</h3>



<p>菜单栏 File-&gt; Import Resources&#8230; 选择 FoxWinShave-GM8.gmres 导入插件及 Demo。</p>



<ul><li>在弹出的 Importing Resources 对话框中，请务必勾选 Scripts 和 Include Files 以导入插件运行所必须的文件和脚本。</li><li>如需同时导入 Demo 代码及素材，请将 Sprites，Objects 和 Rooms 一并勾选上。</li></ul>



<h3>1.1 GMS 1.4.x 及 GMS 2 Desktop</h3>



<div class="wp-block-image"><figure class="aligncenter"><a href="https://www.noisyfox.io/wp-content/uploads/2019/01/image.png" target="_blank" rel="noreferrer noopener"><img loading="lazy" width="300" height="189" src="https://www.noisyfox.io/wp-content/uploads/2019/01/image-300x189.png" alt="" class="wp-image-569" srcset="https://www.noisyfox.io/wp-content/uploads/2019/01/image-300x189.png 300w, https://www.noisyfox.io/wp-content/uploads/2019/01/image-768x483.png 768w, https://www.noisyfox.io/wp-content/uploads/2019/01/image-1024x644.png 1024w, https://www.noisyfox.io/wp-content/uploads/2019/01/image.png 1588w" sizes="(max-width: 300px) 100vw, 300px" /></a><figcaption>Import resources: FoxWinShave 对话框</figcaption></figure></div>



<ol><li>在 GameMaker: Marketplace 上购买本插件。<a rel="noreferrer noopener" aria-label="（在新窗口打开）" href="https://marketplace.yoyogames.com/assets/7696/foxwinshave" target="_blank">（点此购买）</a></li><li>在 GMS 中菜单栏选择 Marketplace -&gt; MyLibrary，找到 FoxWinShave，点击 Download。</li><li>下载完成后，点击 Import。</li><li>在弹出的 Import resources: FoxWinShave 对话框中，选中 Scripts 和 Included Files，然后点击中间的 Add 按钮以导入插件运行所必须的文件和脚本。</li><li>如需同时导入 Demo 代码及素材，那就直接点击中间的 Add All 按钮。</li><li>点击左下角 Import 按钮完成插件的导入。</li></ol>



<hr class="wp-block-separator"/>



<h2>2. 插件入门 101</h2>



<h3>2.0 基础准备</h3>



<p>请务必在游戏设置中将窗口设置为无边框（borderless window）:</p>



<div class="wp-block-image"><figure class="aligncenter"><a href="https://www.noisyfox.io/wp-content/uploads/2019/01/image-2.png" target="_blank" rel="noreferrer noopener"><img loading="lazy" width="300" height="240" src="https://www.noisyfox.io/wp-content/uploads/2019/01/image-2-300x240.png" alt="" class="wp-image-592" srcset="https://www.noisyfox.io/wp-content/uploads/2019/01/image-2-300x240.png 300w, https://www.noisyfox.io/wp-content/uploads/2019/01/image-2.png 512w" sizes="(max-width: 300px) 100vw, 300px" /></a><figcaption>GM 8 设置无边框</figcaption></figure></div>



<div class="wp-block-image"><figure class="aligncenter"><a href="https://www.noisyfox.io/wp-content/uploads/2019/01/image-1.png" target="_blank" rel="noreferrer noopener"><img loading="lazy" width="300" height="237" src="https://www.noisyfox.io/wp-content/uploads/2019/01/image-1-300x237.png" alt="" class="wp-image-591" srcset="https://www.noisyfox.io/wp-content/uploads/2019/01/image-1-300x237.png 300w, https://www.noisyfox.io/wp-content/uploads/2019/01/image-1.png 695w" sizes="(max-width: 300px) 100vw, 300px" /></a><figcaption>GMS 2 设置无边框</figcaption></figure></div>



<p>稍后将会解释需要设置为无边框的原因。</p>



<h3>2.1 插件初始化</h3>



<p>使用本插件的任何脚本前需要先进行插件的初始化。建议在首个 Room 的 Creation Code 内或者某个控制用的 Object 的 Game Start 事件里执行：</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
NF_WS_Init();
</pre></div>


<p>插件初始化后请勿再次调用该函数。</p>



<h3>2.2 插件释放</h3>



<p>当不再需要更改窗口形状后，可以执行以下函数将插件卸载以释放资源：</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; highlight: [2]; title: ; notranslate">
NF_WS_ResetWindow(); // 重置窗口形状为默认，非必要
NF_WS_Free(); // 释放插件
</pre></div>


<p>在释放插件后如果需要再次使用本插件，需要重新进行插件的初始化。</p>



<h3>2.3 基础原理解释</h3>



<h4>2.3.0 窗口坐标系</h4>



<p>将游戏窗口想象成一个画布，按照窗口的边框开始算左上角坐标为 (0, 0)，右下角边框最外处坐标为 (viewport_width + 左边框宽 + 右边框宽, viewport_height + 上边框高 + 下边框高)，如下图所示：</p>



<div class="wp-block-image"><figure class="aligncenter"><a href="https://www.noisyfox.io/wp-content/uploads/2019/01/win-coord-1.png" target="_blank" rel="noreferrer noopener"><img loading="lazy" width="574" height="447" src="https://www.noisyfox.io/wp-content/uploads/2019/01/win-coord-1.png" alt="" class="wp-image-635" srcset="https://www.noisyfox.io/wp-content/uploads/2019/01/win-coord-1.png 574w, https://www.noisyfox.io/wp-content/uploads/2019/01/win-coord-1-300x234.png 300w" sizes="(max-width: 574px) 100vw, 574px" /></a><figcaption> <br>窗口坐标系统 </figcaption></figure></div>



<p>然而问题在于窗口的边框宽度是由 Windows 系统定义的，不同 Windows 版本或者不同的主题都有可能带有不同尺寸的边框，给在定义窗口的形状时计算坐标带来了麻烦。因此如上文所述，请<strong>务必</strong>在游戏全局设置中关闭窗口边框的显示，这样窗口的坐标系统就和游戏 View Port 的坐标系统的原点能够统一，便于将窗口形状与游戏绘制内容对齐。</p>



<p>下文在描述坐标时将默认使用无边框窗口。</p>



<h4>2.3.1 游戏绘制与 View Port</h4>



<p>GM 支持在一个窗口中同时显示多个 View Port。View Port 的作用是将 Room 的一部分内容按一定比例、缩放和位移映射在窗口中显示出来。用户实际看到的内容是经过 View Port 变换后的结果，并不（一定）是游戏中调用绘制代码时使用的坐标。</p>



<p>由于我们只关心用户实际看到了什么，因此下文中提到的<strong>“游戏绘制内容”</strong>的尺寸、坐标，皆为经过 View Port 变换后映射到窗口坐标系中的尺寸和坐标。</p>



<p>更多关于 View Port 的内容，请参考 GM 官方文档，下文将不再赘述。</p>



<h4>2.3.2 窗口形状遮罩</h4>



<p>本插件采用遮罩形式设置窗口形状，支持根据 Sprite 和 Surface（仅限 GMS）设置窗口遮罩。以下核心函数</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
NF_WS_ShaveWindow(sprite, subimage, x, y);
NF_WS_ShaveWindowAlpha(sprite, subimage, x, y, alpha);
NF_WS_ShaveWindowExt(sprite, subimage, x, y, xscale, yscale, alpha);
NF_WS_ShaveWindowSurfaceExt(surface, x, y, xscale, yscale, alpha); // 仅限 GMS
</pre></div>


<p>与 draw_sprite_* 系列绘制函数有着十分类似的形式，除了不支持 rot 和  <br>colour参数，同时 alpha 参数有不同的意义。可以理解为将给定的 Sprite / Surface 用提供的参数放置于窗口坐标系内作为遮罩（不经过 View Port 等任何变换），同时将窗口没有被遮罩覆盖的区域给“消去”变为透明：</p>



<div class="wp-block-image"><figure class="aligncenter"><a href="https://www.noisyfox.io/wp-content/uploads/2019/01/mask.png" target="_blank" rel="noreferrer noopener"><img loading="lazy" width="640" height="480" src="https://www.noisyfox.io/wp-content/uploads/2019/01/mask.png" alt="" class="wp-image-654" srcset="https://www.noisyfox.io/wp-content/uploads/2019/01/mask.png 640w, https://www.noisyfox.io/wp-content/uploads/2019/01/mask-300x225.png 300w" sizes="(max-width: 640px) 100vw, 640px" /></a><figcaption>“遮罩层”内容</figcaption></figure></div>



<p>如图所示，红色部分的窗口会被保留下来，其余部分将会被消去。需要注意的是上图所谓的“遮罩层”是一个与窗口同样大小的位于窗口之上的想象出的一层，并不是实际存在的可见图层，其内容仅为了作为遮罩所用，并不会显示出来。</p>



<p>遮罩层使用的图像为彩色图像带 Alpha 通道。在实际运行时色彩通道会被完全忽略，最终窗口形状仅受遮罩层的 Alpha 通道影响。默认情况下每个 Alpha 通道值为 0 的像素（即纯透明像素）被认为是窗口需要被消去的部分。这个值可以通过上文所述的几个函数中的 alpha 参数（范围 [0, 1.0]）来改变。任何 Alpha 通道值 &lt;= 该参数的像素将被认为是需要消去的。注意，这意味着如果你传入的 alpha 参数为 1，则<strong>任何</strong>像素都会被认定为透明像素。</p>



<p>另外，如果使用 Surface 来传入遮罩内容，请注意 Surface 的背景需要用透明色填充：</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; highlight: [2]; title: ; notranslate">
surface_set_target(mask_surface);
draw_clear_alpha(c_white, 0); // Alpha = 0, 使用的颜色无所谓.
</pre></div>


<h4>2.3.3 遮罩对齐</h4>



<p>使用本插件的目的通常是想将游戏窗口的形状，裁剪成游戏绘制的有意义的内容的形状：</p>



<div class="wp-block-image"><figure class="aligncenter"><a href="https://www.noisyfox.io/wp-content/uploads/2019/01/purpose.png" target="_blank" rel="noreferrer noopener"><img loading="lazy" width="640" height="480" src="https://www.noisyfox.io/wp-content/uploads/2019/01/purpose-1.png" alt="" class="wp-image-661" srcset="https://www.noisyfox.io/wp-content/uploads/2019/01/purpose-1.png 640w, https://www.noisyfox.io/wp-content/uploads/2019/01/purpose-1-300x225.png 300w" sizes="(max-width: 640px) 100vw, 640px" /></a><figcaption>游戏实际绘制内容</figcaption></figure></div>



<p>上图中，女牛仔的部分是有意义的、需要保留的部分，而黑色背景需要被裁剪掉，也就意味着我们在遮罩层“绘制”的遮罩需要与女牛仔的位置、形状相同。</p>



<p>这乍一听似乎很容易，只要使用相同的 x，y 参数将同样的女牛仔 Sprite 绘制到 Application Surface 和遮罩层即可。但是正如上文所说，用户实际看到的内容是经过 View Port 变换过的，因此其实际显示的坐标和尺寸可能与绘制时传入的参数不同；然而遮罩层是不受 View Port 影响的，因此开发者需要自行计算遮罩层图像的位置和尺寸，用以对齐经过 View Port 变换后的游戏内容。建议不要用过于复杂的 View Port 设置。</p>



<h4>2.3.4 窗口形状更新时间与绘制事件顺序</h4>



<p>由于 GM 运行原理所致，游戏绘制的内容并不会在绘制语句执行的瞬间显示出来，而是要等到当前 Step 所有绘制完成后才会刷新绘制缓存以显示绘制的内容。这意味着窗口外形的更新需要与绘制内容的刷新同步发生，否则就会发生窗口形状与所显示内容有所偏差的问题（比如游戏仍然显示的是上一帧的内容，但是窗口形状已经被裁剪成了下一帧所需的形状）：</p>



<div class="wp-block-image"><figure class="aligncenter"><a href="https://www.noisyfox.io/wp-content/uploads/2019/01/image-4.png" target="_blank" rel="noreferrer noopener"><img loading="lazy" width="286" height="262" src="https://www.noisyfox.io/wp-content/uploads/2019/01/image-4.png" alt="" class="wp-image-669"/></a><figcaption> <br>绘制内容与窗口形状没有同步更新 </figcaption></figure></div>



<p>由于 Windows 窗口外形更新时机所限，本插件需要在 GM 的每个 Step 中，于每个 Step 开始 （Begin Step）至 Draw 系列事件开始之前对窗口形状进行更新，以保证窗口形状的更新与绘制内容的更新能够同步完成。如果在 Draw 系列事件中进行窗口形状的修改，则会发生窗口形状与绘制内容不同步的问题，请务必注意。建议在 End Step 事件之中更新窗口形状。</p>



<p>再次提示，请<strong>不要</strong>在 Draw <strong>系列</strong>事件中更新窗口形状！除非你十分清楚可能发生的后果！</p>



<h3>2.4 复杂遮罩</h3>



<p>多次执行以下任意核心函数来改变窗口形状，则后一次的遮罩将会覆盖前一次的遮罩，<strong>并不会</strong>互相叠加：</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
NF_WS_ShaveWindow(sprite, subimage, x, y);
NF_WS_ShaveWindowAlpha(sprite, subimage, x, y, alpha);
NF_WS_ShaveWindowExt(sprite, subimage, x, y, xscale, yscale, alpha);
NF_WS_ShaveWindowSurfaceExt(surface, x, y, xscale, yscale, alpha); // 仅限 GMS
</pre></div>


<p>这意味着如果所需的遮罩是由多个元素组合而成的复杂形状，则需要开发者自行准备好已经事先组合好所有元素的<strong>单张</strong> Sprite / Surface 用作实际的遮罩。</p>



<p>举例来说，如果你需要在屏幕上显示两位女牛仔，那么你需要准备如下的<strong>一张</strong> Sprite / Surface 作为遮罩：</p>



<div class="wp-block-image"><figure class="aligncenter"><a href="https://www.noisyfox.io/wp-content/uploads/2019/01/complex.png" target="_blank" rel="noreferrer noopener"><img loading="lazy" width="640" height="480" src="https://www.noisyfox.io/wp-content/uploads/2019/01/complex.png" alt="" class="wp-image-678" srcset="https://www.noisyfox.io/wp-content/uploads/2019/01/complex.png 640w, https://www.noisyfox.io/wp-content/uploads/2019/01/complex-300x225.png 300w" sizes="(max-width: 640px) 100vw, 640px" /></a><figcaption>复杂遮罩</figcaption></figure></div>



<p>连续调用两次 NF_WS_ShaveWindow_* 函数并不能实现如上所述的需求。假设第一次传入了左侧牛仔的遮罩，第二次传入了右侧的遮罩，则只有右侧会正常显示出来，而第一次设置的遮罩会被覆盖而失效。</p>



<hr class="wp-block-separator"/>



<h2>3. 常见问题</h2>



<ol><li>使用 Sprite 做遮罩时要注意所用 Sprite 的 xoffset 和 yoffset。</li></ol>
<p><a rel="nofollow" href="https://www.noisyfox.io/foxwinshave2.html">FoxWinShave 2 中文使用手册</a>，首发于<a rel="nofollow" href="https://www.noisyfox.io">狐狸的小小窝</a>。</p>]]></content>
        <author>
            <name><![CDATA[狐狸的小小窝]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://doublemice.github.io/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%94%BB%E5%87%BB%E9%9D%A2%E5%8F%8Actf%E5%87%BA%E9%A2%98%E6%8C%87%E5%8D%97/</id>
        <title><![CDATA[智能合约攻击面及ctf出题指南]]></title>
        <updated>2019-01-03T00:00:00+08:00</updated>
        <link href="https://doublemice.github.io/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%94%BB%E5%87%BB%E9%9D%A2%E5%8F%8Actf%E5%87%BA%E9%A2%98%E6%8C%87%E5%8D%97/"/>
        <content type="text/html" src="https://doublemice.github.io/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%94%BB%E5%87%BB%E9%9D%A2%E5%8F%8Actf%E5%87%BA%E9%A2%98%E6%8C%87%E5%8D%97/"><![CDATA[智能合约攻击面及ctf出题指南]]></content>
        <author>
            <name><![CDATA[DoubleMice]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://doublemice.github.io/Todo-List/</id>
        <title><![CDATA[Todo List]]></title>
        <updated>2018-11-23T00:00:00+08:00</updated>
        <link href="https://doublemice.github.io/Todo-List/"/>
        <content type="text/html" src="https://doublemice.github.io/Todo-List/"><![CDATA[Todo List]]></content>
        <author>
            <name><![CDATA[DoubleMice]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://doublemice.github.io/The-road-to-linux-kernel-exploit/</id>
        <title><![CDATA[The Road To Linux Kernel Exploit]]></title>
        <updated>2018-11-22T00:00:00+08:00</updated>
        <link href="https://doublemice.github.io/The-road-to-linux-kernel-exploit/"/>
        <content type="text/html" src="https://doublemice.github.io/The-road-to-linux-kernel-exploit/"><![CDATA[The Road To Linux Kernel Exploit]]></content>
        <author>
            <name><![CDATA[DoubleMice]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://doublemice.github.io/%E5%A0%86%E5%88%A9%E7%94%A8%E5%8F%98%E8%BF%81-glibc-2.25/</id>
        <title><![CDATA[堆利用变迁 Glibc<2.25]]></title>
        <updated>2018-10-25T00:00:00+08:00</updated>
        <link href="https://doublemice.github.io/%E5%A0%86%E5%88%A9%E7%94%A8%E5%8F%98%E8%BF%81-glibc-2.25/"/>
        <content type="text/html" src="https://doublemice.github.io/%E5%A0%86%E5%88%A9%E7%94%A8%E5%8F%98%E8%BF%81-glibc-2.25/"><![CDATA[堆利用变迁 Glibc<2.25]]></content>
        <author>
            <name><![CDATA[DoubleMice]]></name>
        </author>
    </entry>
    
    <entry>
        <id>https://www.noisyfox.io/logrotate.html</id>
        <title><![CDATA[Logrotate 日志滚动 解决日志占用空间过大]]></title>
        <updated>2017-05-03T16:23:04+08:00</updated>
        <link href="https://www.noisyfox.io/logrotate.html"/>
        <content type="text/html" src="https://www.noisyfox.io/logrotate.html"><![CDATA[<h1>起因</h1>
<p>前几天发现自己的博客没有办法登录了，每次输完密码登录完都会重新跳回登录界面。一开始是怀疑登录的session出了什么问题，因为浏览器开隐身模式后就能登录进去。然而开隐身模式进后台的时候又会出现403错误，于是打算连进数据库把session删除再试试。</p>
<p>然而当我试图连接数据库时却一直提示失败，于是试图重启数据库服务，但是系统提示启动失败。电脑坏了怎么办？重启大法！然而数据库服务依旧无法启动，当时我也是摸不着头脑。明明以前一直好好的服务器怎么说炸就炸呢？</p>
<h1>真相</h1>
<p>后来我机智的看了下磁盘的占用情况：</p>
<pre class="brush: bash; title: ; notranslate">df -hl</pre>
<p><a href="https://www.noisyfox.cn/wp-content/uploads/2017/05/df-hl.png"><img loading="lazy" class="aligncenter size-full wp-image-483" src="https://www.noisyfox.cn/wp-content/uploads/2017/05/df-hl.png" alt="df -hl" width="543" height="152" srcset="https://www.noisyfox.io/wp-content/uploads/2017/05/df-hl.png 543w, https://www.noisyfox.io/wp-content/uploads/2017/05/df-hl-300x84.png 300w" sizes="(max-width: 543px) 100vw, 543px" /></a></p>
<p>然后我就震惊了！！<span style="color: #000000;"><del>震惊！过气博主硬盘为何被榨干！这背后究竟是人性的&#8230;（啪</del></span></p>
<p>经过一番折腾，终于找到了问题的所在：</p>
<pre class="brush: bash; title: ; notranslate">du -sh .</pre>
<p><a href="https://www.noisyfox.cn/wp-content/uploads/2017/05/du-sh.png"><img loading="lazy" class="aligncenter size-full wp-image-484" src="https://www.noisyfox.cn/wp-content/uploads/2017/05/du-sh.png" alt="df -hl" width="481" height="96" srcset="https://www.noisyfox.io/wp-content/uploads/2017/05/du-sh.png 481w, https://www.noisyfox.io/wp-content/uploads/2017/05/du-sh-300x60.png 300w" sizes="(max-width: 481px) 100vw, 481px" /></a></p>
<p>Nginx 的日志文件居然占用了14G的空间！Why？</p>
<h1>论日志</h1>
<p>日志文件通常情况下是未压缩的明文文本文件，在一个运行时间较长的系统中日志文件的体积会越来越大，甚至远超你的预期。</p>
<p>默认情况下一个服务的同一个日志流（如 Nginx 默认就有 error.log access.log 两个日志流）是输出到同一个日志文件中的，也就是说随着时间的推移，这一日志文件中包含的日志的天数也会越来越多，这就给查看某一特定时间段的日志带来了麻烦（试想一下在一个容量10G，包含了一整年数据的日志文件中查找5月份的日志信息，而且还没有日志辅助工具的帮助，是一件多么痛苦的事情）。并且如果日志文件占用了过大的存储空间，那么人们通常会优先删除最老的日志，保留最近一段时间的日志。如果所有日志信息都储存在同一个文件中，那么想要只删除部分数据也不是一件轻松的活。</p>
<p>再者，日志数据通常都是纯文本数据，并且内容重复度非常之高，如果能够将其压缩存储，那么会大大减小体积。然而日志系统是没有办法将数据追加到一个压缩过的日志文件中去的。如果要压缩日志，那么势必需要将日志数据划分成新、旧两部分，其中旧日志压缩后单独存放，新日志即是当前系统活动的日志文件，仍然是纯文本形式。</p>
<p>综上所述，一个好的日志系统至少需要满足以下几个需求：</p>
<ul>
<li>能够将日志按一定规律拆分成多个文件</li>
<li>能够将非活动的日志压缩</li>
<li>能够控制日志文件体积和数量，当条件满足时自动删除旧日志以释放空间</li>
<li>日志文件名满足一定规律便于排序和筛选</li>
</ul>
<p>以上的需求，通常称为<strong>日志滚动</strong><del>（必考）</del>。</p>
<h1>日志滚动</h1>
<p>道理我都懂，但是Linux的日志系统没有提供这些功能，总不能每天手动重命名、压缩、清空、删除日志吧？</p>
<p><del>天空一声巨响，英雄闪亮登场！</del>这时候一个叫做 <strong>logrotate</strong> 的程序就派上了用处。</p>
<p>根据使用的系统不同，logrotate的安装方式也不尽相同，有些系统更是自带了 logrotate 并且带有很多默认的配置（比如我所使用的 Ubuntu Server）。</p>
<p>你可以在自己的系统上查看一下 /var/log/ 目录下的日志文件，如果见到了类似“服务名.log.0”、“服务名.log.1”等一大堆具有相同服务名称但是带有后缀序号的日志文件，那么可以99%肯定这个系统已经安装了 logrotate 并且能够工作。</p>
<p><a href="https://www.noisyfox.cn/wp-content/uploads/2017/05/logs.png"><img loading="lazy" class="aligncenter size-full wp-image-492" src="https://www.noisyfox.cn/wp-content/uploads/2017/05/logs.png" alt="logrotate" width="663" height="579" srcset="https://www.noisyfox.io/wp-content/uploads/2017/05/logs.png 663w, https://www.noisyfox.io/wp-content/uploads/2017/05/logs-300x262.png 300w" sizes="(max-width: 663px) 100vw, 663px" /></a></p>
<p>如果你的系统没有带logrotate，别担心，百度一下就能装上啦！而且配置巨简单！</p>
<p>在 /etc/logrotate.d/ 目录下（不同系统可能有所区别）通常会有很多配置文件，这些文件的名字通常对应了该文件所管辖的服务（文件名仅仅是便于管理，和实际内容没有必然关联）。</p>
<p><a href="https://www.noisyfox.cn/wp-content/uploads/2017/05/logrotate_cfg.png"><img loading="lazy" class="aligncenter size-full wp-image-494" src="https://www.noisyfox.cn/wp-content/uploads/2017/05/logrotate_cfg.png" alt="logrotate config" width="663" height="435" srcset="https://www.noisyfox.io/wp-content/uploads/2017/05/logrotate_cfg.png 663w, https://www.noisyfox.io/wp-content/uploads/2017/05/logrotate_cfg-300x197.png 300w" sizes="(max-width: 663px) 100vw, 663px" /></a></p>
<p>而这些配置文件的格式非常的简要，如图所示。通常第一行以目标日志文件路径起头，可以使用通配符，而后面的花括号内部则是需要应用于该日志文件的滚动规则。</p>
<p>其中几个常用的规则在这里稍微解释一下，通常就够用了。更详细的规则可以自行查找，不再赘述。</p>
<pre class="brush: bash; title: ; notranslate">

/var/log/nginx/*.log {
    daily  # 滚动频率，每天滚动一次。其它可选项为 hourly weekly monthly yearly
    missingok
    rotate 14  # 最多保留14次滚动，超过则删除最老的日志
    maxsize 100M  # 重要！活动日志的最大尺寸，超过该尺寸则强制滚动一次
    compress  # 重要！压缩不活动的日志，默认使用gzip
    delaycompress
    notifempty  # 如果日志为空则不滚动
    create 0640 www-data adm
    sharedscripts
    prerotate  # 在每次滚动前执行的脚本，通常是通知该服务“我要滚动日志啦！先别生成新日志咯！”
        if [ -d /etc/logrotate.d/httpd-prerotate ]; then \
        run-parts /etc/logrotate.d/httpd-prerotate; \
        fi \
    endscript
    postrotate  # 在滚动完成后执行的脚本，通常是通知该服务“日志滚动完成啦！请把后续日志写到新的活动日志文件中去！”
        invoke-rc.d nginx rotate &gt;/dev/null 2&gt;&amp;1
    endscript
}

</pre>
<p>如果发现日志滚动后 nginx 依旧在向 access.log.1 中写入日志，而新创建的 access.log 大小始终是0，那么请将上文中的 postrotate 代码改为：</p>
<pre class="brush: bash; title: ; notranslate">

service nginx rotate &gt;/dev/null 2&gt;&amp;1

</pre>
<h1>划重点</h1>
<p>同学A：慢着！刚刚不是说你服务器跑的 Ubuntu Server 默认启用了 logrotate 么？那么为什么你的硬盘还是被这些日志文件吃了个精光呢？按说一共就保留14份日志，也就只有14天的份，还都是压缩过的，怎么会占用这么多呢？</p>
<p>我：<del>谢尔曼M1，坐！</del></p>
<p>问题来了，这个 logrotate 的默认配置文件，少了 <em>maxsize 100M</em> 这一行，也就是说如果说在第二天的滚动开始前，日志就已经占用了过大的空间，以至于剩余空间不足以储存对应日志的压缩文件（因为得先压缩完才能删除原始文件，于是整个过程所需的最大空间是 <em>原始文件体积+压缩后的体积</em>，毕竟不可能一边压缩一边删除原始文件嘛）的话，整个日志滚动就会失败。而我的实际情况就是 access.log.0 文件占用了13G的空间（剩下的13个压缩后的日志一共才1G不到，完美的体现了压缩的好处），剩余的空间不足以对其进行压缩，于是整个日志滚动彻底失效了。</p>
<p>当然了，理想的情况下，如果能够将其设置成全部日志加起来的体积超过一个临界点（比如日志一共5G）那么就自动删除最老的一份日志，那是坠吼嘀！然而 logrotate 并没有提供这样的整体体积限制的功能，于是只好用一些小技巧。注意这两行：</p>
<pre class="brush: bash; title: ; notranslate">
rotate 14 # 最多保留14次滚动，超过则删除最老的日志
maxsize 100M # 重要！活动日志的最大尺寸，超过该尺寸则强制滚动一次
</pre>
<p>通过限制活动日志的体积（也就是尾号是0或者没有后缀的那个日志文件）和保留日志滚动数量，我们能够限制整体的日志大小，也即不超过 14 * 100M = 1.4G。当然这样的缺点就是如果某一天的日志特别多，那么那一天的日志会被拆分成多个（课外题：自行百度，将日志文件后缀设置为当前的日期时间）。</p>
<h1>总结</h1>
<p>不限制日志体积真是坑啊！</p>
<p><a rel="nofollow" href="https://www.noisyfox.io/logrotate.html">Logrotate 日志滚动 解决日志占用空间过大</a>，首发于<a rel="nofollow" href="https://www.noisyfox.io">狐狸的小小窝</a>。</p>]]></content>
        <author>
            <name><![CDATA[狐狸的小小窝]]></name>
        </author>
    </entry>
    
</feed>